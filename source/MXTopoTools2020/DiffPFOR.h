#pragma once

#include "Util.h"

// Differential Patched Frame of Reference
// =======================================
// A high-throughput compression scheme for 32-bit integers.
// Heavily inspired by the works of Daniel Lemire (https://arxiv.org/abs/1209.2137),
// especially the Java implementation of FastPFOR (https://github.com/lemire/JavaFastPFOR).
//
// The main conceptual difference to FastPFOR is that this scheme always applies differential coding to
// the input before bit-packing. This allows for higher compressibility for a wider variety of input patterns.
// The performance impact is measurable, but negligible under almost all circumstances.
// Furthermore, incompressible pages are automatically stored as raw data, without discarding compressible pages.
// This too, makes a wider variety of input patterns compressible, which would otherwise have to be discared entirely.
// Another significant change is that if a block has more than 32 exceptions, their locations are stored inside of a
// bit-set of a fixed size of 256 (32 bytes). This improves compressibility noticeably without meaningfully impacting
// performance.
// The trailing 0..255 words that are not compressed by PFOR are automatically differentially variable-byte coded.
//
// The implementation was entirely re-written to be clearer and easier to follow. Every important step is reasonably 
// commented on. 
// Some parts have been optimized even further, reducing branching and the number of arithmetic operations required, 
// as well as significantly lowering the overall workspace requirements.
//
// Even if this is not quite as fast as it maybe could be, you should still expect at least 600 MiB/s of compression 
// and at least 800 MiB/s decompression performance, even for *REALLY* terrible inputs.
//
// The original code is released under the Apache License Version 2.0 (c) Daniel Lemire (http://www.apache.org/licenses/)
//
// Jan Kebernik
class DiffPFOR
{
	// Class constants
	// ===============================
private:
	static constexpr const u32 EXCEPT_LOG = 3;	// Each exception location requires 8 bits if storage.
	static constexpr const u32 RUN_LOG = 5;		// We always pack 32 words at a time.
	static constexpr const u32 BLOCK_LOG = 8;	// Each block of 256 words receives its own meta-data (bit-width, etc...)
	static constexpr const u32 PAGE_LOG = 16;	// Each page consists of up to 256 blocks, resulting in up to 65536 words per page.

	static constexpr const u32 RUN_MASK = (1_u32 << RUN_LOG) - 1;	// efficient % 32

	static constexpr const u32 BLOCK_SIZE = 1_u32 << BLOCK_LOG;	// See above.
	static constexpr const u32 PAGE_SIZE = 1_u32 << PAGE_LOG;	// See above.

	static constexpr const u32 RUN_MULT = 0xFFFFFFFF_u32 << RUN_LOG;		// Masking by this value yields the largest multiple of 32.
	static constexpr const u32 BLOCK_MULT = 0xFFFFFFFF_u32 << BLOCK_LOG;	// Masking by this value yields the largest multiple of 256.

	// For each of 256 blocks: 1 byte for width, 1 byte for num exceptions, 1 byte for max width, at most 32 bytes for exception locations.
	static constexpr const u32 BUFFER_SIZE = (PAGE_SIZE >> BLOCK_LOG) * (32 + 3);	// This is ~1/8th of FastPFOR, which is quite something.

	// The differential stride. Each value that is differentially coded will be given
	// the difference to the value DIFF indices before it. Must be at least 1.
	// By increasing this value above 1, the decompressor can leverage some parallelism, because 
	// values are not dependent on their direct predecessor. While doing so has a marginally negative 
	// effect on compression speeds, it can also drastically improves decompression performance.
	// It is unlikely that this would meaningfully affect the compression ratio for most data sets.
	// There are data sets that are less compressible this way, but the opposite is equally true. 
	// For non-tailored data, it really shouldn't matter much.
	// Possible values are 1, 2, 4, 8, 16, 32. Values below 4 and above 8 tend to degrade performance, 
	// probably because of of low-level cache-thrashing.
	// This invariant requires that the first DIFF words no be differentially coded. 
	// Right now, they are simply copied.
	static constexpr const u32 DIFF = 4;

	// Any input length below this value is deemed incompressible with the current implementation because of static overheads.
	// It should just be copied alongside the input length.
	// 1 word uncompressed length
	// 1 word compressed length
	// DIFF words differential base values.
	static constexpr const u32 CUTOFF = 2 + DIFF;

	static constexpr i32 COUNTER_BASE = __COUNTER__;
	// Class internal members
	// ===============================
private:

	// Contains exception bits for a bit-width
	struct ExceptionData {

		friend class DiffPFOR;

	private:
		u32* bits;		// Array containing exception high bits
		u32 capacity;	// Array capacity
		u32 count;		// Array length

		ExceptionData() {
			bits = new u32[32];
			capacity = 32;
			count = 0;
		}

		~ExceptionData() {
			delete[] bits;
		}
	};

	// c++ is so... does this actually get deleted? I need an answer!
	u8 buffer[BUFFER_SIZE] = {};
	u32 diffs[BLOCK_SIZE] = {};
	u32 hist[33] = {};
	ExceptionData data[33];

public:
	class Errors {
	public:
		enum {
			srcLen_negative = -1,
			srcLen_too_large = -2,
			srcLen_too_small = -3,
			srcOff_negative = -4,
			srcOff_too_large = -5,
			dstOff_negative = -6,
			dstOff_too_large = -7,
			dstLen_negative = -8,
			dstLen_too_small = -9,
			dst_overfull = -10,
			stream_corrupt = -11
		};
	};

	DiffPFOR() {}

	~DiffPFOR() {}

	// the minimum dstLen for compressing srcLen words.
	// returns error code if srcLen < 0 or if srcLen too large
	static inline constexpr i32 minCapacity(const i32 srcLen) {
		if (srcLen < 0) {
			return Errors::srcLen_negative;
		}
		if (U32(srcLen) < CUTOFF) {
			return srcLen + 1;
		}
		const i32 minCap = minCapacityImpl(srcLen);
		return minCap < 0 
			? Errors::srcLen_too_large
			: minCap;
	}

	// returns the compressed length of the compressed stream starting at srcOff
	static inline i32 decompressedLength(const List<i32>& src, const i32 srcOff) {
		if (srcOff < 0) {
			return Errors::srcOff_negative;
		}
		if (srcOff > src.length() - 1) {
			return Errors::srcOff_too_large;
		}
		return src[srcOff + 0];
	}

	// returns the decompressed length of the compressed stream starting at srcOff
	static inline i32 compressedLength(const List<i32>& src, const i32 srcOff) {
		if (srcOff < 0) {
			return Errors::srcOff_negative;
		}
		if (srcOff > src.length() - 1) {
			return Errors::srcOff_too_large;
		}
		const i32 decompressedLength = src[srcOff + 0];
		if (decompressedLength < 0) {
			return Errors::stream_corrupt;
		}
		if (decompressedLength < CUTOFF) {
			return decompressedLength + 1;
		}
		if (srcOff > src.length() - 2) {
			return Errors::srcOff_too_large;
		}
		const i32 compressedLength = src[srcOff + 1];
		if (compressedLength < 0) {
			return Errors::stream_corrupt;
		}
		return compressedLength;
	}

	// return number of words produced
	inline i32 compress(const List<i32>& src, const i32 srcOff, const i32 srcLen, List<i32>& dst, const i32 dstOff, const i32 dstLen) {
		const i32 srcCap = src.length();
		if (srcOff < 0) {
			return Errors::srcOff_negative;
		}
		if (srcLen < 0) {
			return Errors::srcLen_negative;
		}
		if (srcOff > srcCap - srcLen) {
			return Errors::srcOff_too_large;
		}
		const i32 dstCap = dst.length();
		if (dstOff < 0) {
			return Errors::dstOff_negative;
		}
		if (dstLen < 0) {
			return Errors::dstLen_negative;
		}
		if (dstOff > dstCap - dstLen) {
			return Errors::dstOff_too_large;
		}
		if (U32(srcLen) < CUTOFF) {
			// Special case: Compressed size is not stored. It is inferred from uncrompressed size (which is stored) instead.
			if (srcLen + 1 > dstLen) {
				return Errors::dstLen_too_small;
			}
			i32* const _dst = dst.tab()->Addr(0);
			if (srcLen == 0) {
				_dst[0] = 0;
				return 1;
			}
			const i32* const _src = src.tab()->Addr(0);
			_dst[dstOff + 0] = srcLen;	// Store the uncompressed input length.
			std::copy(_src + srcOff, _src + srcOff + srcLen, _dst + dstOff + 1);
			return srcLen + 1;
		}
		const i32 minCap = minCapacityImpl(srcLen);
		if (minCap < 0) {
			// No "dstLen" can exist that would satisfy worst-case of "srcLen" being compressed. "srcLen" is too big.
			return Errors::srcLen_too_large;
		}
		if (dstLen < minCap) {
			// "srcLen" is fine, but the provided "dst" capacity at "dstOff" is too low to accommodate the worst case.
			return Errors::dstLen_too_small;
		}
		i32* const _dst = dst.tab()->Addr(0);
		const i32* const _src = src.tab()->Addr(0);
		const i32 compressedLength = compressU(
			reinterpret_cast<const u32* const>(_src),
			U32(srcOff),
			U32(srcLen),
			reinterpret_cast<u32* const>(_dst),
			U32(dstOff + 2)
		) - dstOff;
		_dst[dstOff + 0] = srcLen;			// Store the uncompressed input length.
		_dst[dstOff + 1] = compressedLength;	// Store compressed length.
		return compressedLength;
	}

	// Returns the number of words CONSUMED, not PRODUCED.
	inline i32 decompress(const List<i32>& src, const i32 srcOff, const i32 srcLen, List<i32>& dst, const i32 dstOff, const i32 dstLen) {
		const i32 srcCap = src.length();
		if (srcOff < 0) {
			return Errors::srcOff_negative;
		}
		if (srcLen < 0) {
			return Errors::srcLen_negative;
		}
		if (srcOff > srcCap - srcLen) {
			return Errors::srcOff_too_large;
		}
		const i32 dstCap = dst.length();
		if (dstOff < 0) {
			return Errors::dstOff_negative;
		}
		if (dstLen < 0) {
			return Errors::dstLen_negative;
		}
		if (dstOff > dstCap - dstLen) {
			return Errors::dstOff_too_large;
		}
		if (srcLen == 0) {
			return Errors::srcLen_too_small;
		}
		const i32* const _src = src.tab()->Addr(0);
		const i32 decompressedLen = _src[srcOff + 0];
		if (decompressedLen < 0) {
			// Cannot happen legally.
			return Errors::stream_corrupt;
		}
		if (dstLen < decompressedLen) {
			return Errors::dstLen_too_small;
		}
		if (decompressedLen < CUTOFF) {
			// Special case: Compressed size is not stored. It is always inferred from uncrompressed size (which is stored) instead.
			if (decompressedLen != 0) {
				i32* const _dst = dst.tab()->Addr(0);
				std::copy(_src + srcOff + 1, _src + srcOff + 1 + decompressedLen, _dst + dstOff);
			}
			return decompressedLen + 1;	// Return number consumed.
		}
		const i32 compressedLen = _src[srcOff + 1];
		if (compressedLen <= 0) {
			return Errors::stream_corrupt;
		}
		if (srcLen < compressedLen) {
			return Errors::srcLen_too_small;
		}
		return decompressU(
			reinterpret_cast<const u32* const>(_src),
			U32(srcOff + 2),
			U32(decompressedLen),
			U32(srcOff + compressedLen),
			reinterpret_cast<u32* const>(dst.tab()->Addr(0)),
			U32(dstOff)
		) ? compressedLen : Errors::stream_corrupt;
	}

	// Internal functions
	// ===============================
private:

	inline i32 compressU(const u32* const src, u32 srcOff, u32 srcLen, u32* const dst, u32 dstOff) {
		// Copy leading DIFF words.
		std::copy(src + srcOff, src + srcOff + DIFF, dst + dstOff);
		dstOff += DIFF;
		srcOff += DIFF;
		srcLen -= DIFF;
		const u32 packEnd = srcOff + (srcLen & BLOCK_MULT);	// End of packable input.
		while (srcOff != packEnd) {
			// Compress one page at a time.
			const u32 pageOff = srcOff;	// Memoize page start.
			const u32 pageLen = Util::mathMin(PAGE_SIZE, packEnd - srcOff);
			const u32 headerOff = dstOff++;
			// Reset exception counts.
			for (u32 i = 0; i != 33; ++i) {
				data[i].count = 0;
			}
			u32 bufferPos = 0;
			// Pack all blocks and collect exception data for this page.
			for (const u32 lastBlockPos = srcOff + pageLen - BLOCK_SIZE; srcOff <= lastBlockPos; ) {
				// Reset histogram.
				for (u32 i = 0; i != 33; ++i) {
					hist[i] = 0;
				}
				// Build histogram while differentially coding block words to a local buffer.
				for (u32 i = 0; i != BLOCK_SIZE; ++srcOff, ++i) {
					++hist[Util::maxBitsUsed32(diffs[i] = zig(src[srcOff] - src[srcOff - DIFF]))];
				}
				// Default to max bits used.
				u32 bitWidth = 32;
				while (hist[bitWidth] == 0) {
					--bitWidth;
				}
				const u32 maxWidth = bitWidth;
				u32 exceptions = 0;
				// Find optimal baseline bit-width, based on number and size of exceptions for that bit-width.
				if (bitWidth != 0) {
					u32 maxExceptions = hist[bitWidth];
					if (maxExceptions != BLOCK_SIZE) {
						// There are exceptions to the baseline at all.
						u32 bestCost = bitWidth << BLOCK_LOG;			// Initial cost (no exceptions).
						u32 mainCost = bestCost - BLOCK_SIZE + 8;	// Cost of storing non-exceptional bits. Plus 8 for storing maxWidth, when relevant.
						u32 bitCost = mainCost + Util::mathMin(maxExceptions << EXCEPT_LOG, 256_u32);	// We use at most 256 bits for the locations.
						// The bitCost encompasses the main cost plus the cost of storing the location of each
						// exception, plus the cost of storing all exception high bits.
						// We simply iterate through each width to find the optimal bitCost.
						// Exception bit cost is purely inferred if "highBits" == 1. Meaning, they need not be stored.
						// "highBits" == 1 is thus not included in the full analysis, and instead serves as the initial cost base.
						for (u32 w = bitWidth - 1, highBits = 2; ; ++highBits) {
							if (bestCost > bitCost) {
								bestCost = bitCost;
								bitWidth = w;
								exceptions = maxExceptions;
							}
							if (w == 0 || (maxExceptions += hist[w--]) == BLOCK_SIZE) {
								// Only stop when minimal bit-width baseline of 0 is reached,  
								// or when all values would be considered exceptional (which would be paradoxical).
								break;
							}
							bitCost = (mainCost -= BLOCK_SIZE) + Util::mathMin(maxExceptions << EXCEPT_LOG, 256_u32) + (maxExceptions * highBits);
						}
					}
				}
				// Find and store relative exception locations, and store their high bits.
				buffer[bufferPos++] = U8(bitWidth);
				buffer[bufferPos++] = U8(exceptions);
				if (exceptions != 0) {
					// There are exceptions. This case is fairly common, but not ubiquitous either.
					buffer[bufferPos++] = U8(maxWidth);
					ExceptionData& d = data[maxWidth - bitWidth];
					// Ensure that exception bits can be safely stored.
					const u32 minCount = d.count + exceptions;
					if (minCount > d.capacity) {
						const u32 newSize = ((minCount << 1) + 31) & RUN_MULT;
						u32* b = new u32[newSize];
						std::copy(d.bits, d.bits + d.count, b);
						delete[] d.bits;
						d.bits = b;
						d.capacity = newSize;
					}
					// bitWidth is always 0..31. 32 is not possible, because then we wouldn't have exceptions.
					// Lemma: Shifts are well defined and safe.
					const u32 mask = (1_u32 << bitWidth) - 1;
					if (exceptions <= 32) {
						// Store each exception location in a dedicated byte (<= 256 bits for all locations).
						for (u32 i = 0; i != BLOCK_SIZE; ++i) {
							const u32 val = diffs[i];
							const u32 bits = val >> bitWidth;
							if (bits != 0) {
								// We have an exception.
								diffs[i] = val & mask;			// Shave off the high bits. Now we won't need to mask when packing. Ever.
								d.bits[d.count++] = bits;
								buffer[bufferPos++] = U8(i);	// Store exception location.
							}
						}
					}
					else {
						// Store each exception location in a fixed-size bitset (always 256 bits).
						// Clear bitset.
						const u32 end = bufferPos + 32;
						for (u32 i = bufferPos; i != end; ++i) {
							buffer[i] = 0_u8;
						}
						// Gather exception locations in bitset.
						for (u32 i = 0; i != BLOCK_SIZE; ++i) {
							const u32 val = diffs[i];
							const u32 bits = val >> bitWidth;
							if (bits != 0) {
								// We have an exception.
								diffs[i] = val & mask;			// Shave off the high bits. Now we won't need to mask when packing. Ever.
								d.bits[d.count++] = bits;
								const u32 p = bufferPos + (i >> 3);
								buffer[p] = U8(U32(buffer[p]) | (1_u32 << (i & 7)));	// Store exception location.
							}
						}
						bufferPos = end;
					}
				}
				// Pack low bits.
				for (u32 i = 0; i != BLOCK_SIZE; i += 32, dstOff += bitWidth) {
					pack(diffs, i, dst, dstOff, bitWidth);
				}
			}
			// Store exception data after block data (trailing end of page).
			const u32 metaLen = (bufferPos + 3) >> 2;	// Exception meta-data length in words.
			dst[headerOff] = dstOff - headerOff;		// Store relative offset to exception data to page header.
			dst[dstOff++] = metaLen;					// Store length of exception meta-data to after the packed bits.
			// Make sure no garbage bytes are stored in the meta-data (not strictly necessary. But otherwise, equivalent streams
			// might have different overall signatures, which would mess with hashing, etc...)
			while ((bufferPos & 3) != 0) {
				buffer[bufferPos++] = 0_u8;
			}
			// Store exception meta-data for each block in the page (number of exceptions, max bit-width, exception indices).
			dstOff = flush(buffer, dst, dstOff, metaLen);
			// Construct and store a bitset of the widths that have exceptions.
			u32 bitset = 0;
			for (u32 w = 32; w != 1; ) {
				if (data[w--].count != 0) {
					bitset |= (1_u32 << w);
				}
			}
			dst[dstOff++] = bitset;
			// For each extra width that has exceptions, store the exception count, then pack the exception high bits.
			// Again, 1 is skipped.
			for (u32 w = 2; w != 33; ++w) {
				const ExceptionData& d = data[w];
				if (d.count != 0) {
					dst[dstOff++] = d.count;
					u32 i = 0;
					for (; i < d.count; i += 32, dstOff += w) {
						pack(d.bits, i, dst, dstOff, w);
					}
					// We always store 32 values at a time, which may not result in optimal storage. Shave off redundant words.
					dstOff -= ((i - d.count) * w) >> 5;
				}
			}
			// Page has been processed.
			if (dstOff - headerOff > pageLen) {
				// No reduction has occurred. Just copy the page raw.
				// This places a very low limit on the worst-case storage bounds (input * 65537 / 65536 + constant factor).
				// This would need to happen at some point anyway in order to not waste space.
				// This case is identified by the highest bit of the page header.
				dst[headerOff] = pageLen | 0x80000000;
				std::copy(src + pageOff, src + pageOff + pageLen, dst + headerOff + 1);
				dstOff = headerOff + 1 + pageLen;
				srcOff = pageOff + pageLen;
			}
		}
		// Done with packable blocks. Deal with trailing 0..255 words by variable-byte coding them.
		const u32 remainder = srcLen & 0xFF;
		if (remainder != 0) {
			// Store the remaining diffs with a variable byte length (1, 2, 3 or 4 bytes per word).
			// Each word has a 2-bit overhead describing its byte length. Four words are encoded at a time.
			// This way, 4 widths can be conveniently stored as a byte.
			u32 bufferPos = 0;
			for (u32 i = 0; i != remainder; ) {
				const u32 m = i + Util::mathMin(4_u32, remainder - i);
				const u32 lensOff = bufferPos++;
				u32 lens = 0;
				for (u32 s = 0; i != m; ++i, s += 2) {
					const u32 word = zig(src[srcOff] - src[srcOff++ - DIFF]);
					const u32 off = bufferPos + 1;
					buffer[bufferPos++] = U8(word >> 0);
					if ((word >> 8) != 0) {
						buffer[bufferPos++] = U8(word >> 8);
						if ((word >> 16) != 0) {
							buffer[bufferPos++] = U8(word >> 16);
							if ((word >> 24) != 0) {
								buffer[bufferPos++] = U8(word >> 24);
							}
						}
					}
					lens |= (bufferPos - off) << s;
				}
				buffer[lensOff] = U8(lens);
			}
			const u32 numWords = (bufferPos + 3) >> 2;
			if (numWords < remainder) {
				// Avoid garbage.
				while ((bufferPos & 3) != 0) {
					buffer[bufferPos++] = 0_u8;
				}
				// Store variable bytes.
				dstOff = flush(buffer, dst, dstOff, numWords);
			}
			else {
				// No compression was achieved for remainder.
				std::copy(src + packEnd, src + packEnd + remainder, dst + dstOff);
				dstOff += remainder;
			}
			// There is no need to explicitly specify whether the trailing bytes were compressed or copied. 
			// It can be inferred during decompression.
		}
		return I32(dstOff);
	}

	inline bool decompressU(const u32* const src, u32 srcOff, u32 rawLen, const u32 streamEnd, u32* const dst, u32 dstOff) {
		const u32 dstEnd = dstOff + rawLen;
		// Copy the first DIFF values un-encoded.
		std::copy(src + srcOff, src + srcOff + DIFF, dst + dstOff);
		dstOff += DIFF;
		srcOff += DIFF;
		rawLen -= DIFF;
		for (const u32 packEnd = dstOff + (rawLen & BLOCK_MULT); dstOff != packEnd; ) {
			const u32 pageHeader = src[srcOff];
			if ((pageHeader & 0x80000000) != 0) {
				// The page is stored raw. Just copy it.
				const u32 raw = pageHeader & 0x7FFFFFFF;	// Remove the marker bit to retrieve the page length.
				if (raw > dstEnd - dstOff) {
					return false;
				}
				++srcOff;	// Skip the header, then copy the page data.
				std::copy(src + srcOff, src + srcOff + raw, dst + dstOff);
				srcOff += raw;
				dstOff += raw;
				continue;	// Go to next page.
			}
			// The page was compressed. First, find the offset to the page's exception meta-data. 
			// First word is length of meta-data in words.
			u32 exceptOff = srcOff++ + pageHeader;
			// Load exception meta-data for page into byte buffer.
			exceptOff = fill(buffer, src, exceptOff + 1, src[exceptOff]);
			const u32 bitset = src[exceptOff++];
			// Based on bitset, check if each bit-width has exceptions. If so, unpack the exceptional bits into local storage.
			for (u32 w = 1; w != 32; ) {
				if ((bitset & (1_u32 << w++)) != 0) {
					// Decode stored exception bits for this width.
					const u32 num = src[exceptOff++];				// Number of exceptions with this additional width.
					const u32 min32 = (num + 31) & RUN_MULT;	// Minimal multiple of 32 that contains "num", at most PAGE_SIZE.
					ExceptionData& d = data[w];
					if (d.capacity < min32) {
						// This will amortize quickly over the life-time of a DiffPFOR instance and won't grow out of control.
						delete[] d.bits;
						const u32 newCap = Util::mathMin(PAGE_SIZE, Util::mathMax(d.capacity << 1, min32));
						d.bits = new u32[newCap];
						d.capacity = newCap;
					}
					// Decode 32 exceptional bit values at at time. It is assumed that accessing "src" like this won't segfault.
					const u32 fullUnpack = num & RUN_MULT;
					for (u32 numUnpacked = 0; numUnpacked != fullUnpack; numUnpacked += 32, exceptOff += w) {
						unpack(src, exceptOff, d.bits, numUnpacked, w);
					}
					// Only test bounds for the remaining 0..31 exceptions to unpack.
					const u32 remainder = num - fullUnpack;
					if (remainder != 0) {
						const u32 wordsNeeded = ((remainder * w) + RUN_MASK) >> RUN_LOG;
						if (exceptOff + wordsNeeded > streamEnd) {
							// Can't load 32 words safely. So we copy relevant "src" words to a local buffer and unpack that instead.
							// It does NOT matter whether the the words loaded are all valid block data. Only that we don't access past the stream end.
							std::copy(src + exceptOff, src + exceptOff + wordsNeeded, diffs);
							unpack(diffs, 0, d.bits, fullUnpack, w);
						}
						else {
							unpack(src, exceptOff, d.bits, fullUnpack, w);
						}
						exceptOff += wordsNeeded;
					}
				}
			}
			// Reset exception counts.
			for (u32 i = 0; i != 33; ++i) {
				data[i].count = 0;
			}
			// Decompress each block in the page, now that we have the exception data.
			for (u32 bufferPos = 0, block = 0, blocks = (Util::mathMin(PAGE_SIZE, packEnd - dstOff)) >> BLOCK_LOG; block != blocks; ++block) {
				const u32 bitWidth = U32(buffer[bufferPos++]);
				u32 numExcept = U32(buffer[bufferPos++]);
				if (bitWidth > 32) {
					return false;
				}
				// Restore exception bits for the unpacked values.
				if (numExcept == 0) {
					// Unpack all block values without patching, applying the differentials immediately.
					// This is measurably faster than the alternative. 
					// Surprisingly, attempting to apply this logic on a more granular level in order to skip patching 
					// for individual runs of 32 words at a time usually only manages to decreases through-put overall.
					// Probably because of poor cache-locality.
					for (const u32 end = dstOff + BLOCK_SIZE; dstOff != end; dstOff += 32, srcOff += bitWidth) {
						diffUnpack(src, srcOff, dst, dstOff, bitWidth);
					}
				}
				else {
					// Strictly unpack the block values.
					for (u32 i = 0; i != BLOCK_SIZE; i += 32, srcOff += bitWidth) {
						unpack(src, srcOff, dst, dstOff + i, bitWidth);
					}
					// Patch the unpacked values with missing additional exceptional bits.
					const u32 maxWidth = U32(buffer[bufferPos++]);	// The number of bits used by the largest exceptional value in the block.
					const u32 extra = maxWidth - bitWidth;			// The number of missing bits to append to each value to make them non-exceptional.
					if (maxWidth > 32 || maxWidth <= bitWidth) {
						return false;
					}
					if (extra == 1) {
						// The high bits are always equal to 1 (thus, they can be inferred and need no storage).
						const u32 patch = 1_u32 << bitWidth;
						if (numExcept <= 32) {
							// Exception locations are stored one byte at a time.
							do {
								// Add exceptional high bit to unpacked value.
								dst[dstOff + U32(buffer[bufferPos++])] |= patch;
							} while (--numExcept != 0);
						}
						else {
							// Exception locations are stored in a bitset-256.
							for (u32 off = dstOff, end = bufferPos + 32; bufferPos != end; bufferPos += 4, off += 32) {
								for (u32 subset = read32(buffer, bufferPos); subset != 0; subset &= (subset - 1)) {
									// Add exceptional high bit to unpacked value.
									dst[off + Util::trailingZeros32Unsafe(subset)] |= patch;
								}
							}
						}
					}
					else {
						// We must properly extract the missing bits to be appended to the unpacked values.
						ExceptionData& d = data[extra];
						if (numExcept <= 32) {
							do {
								// Add exceptional high bits to unpacked value.
								dst[dstOff + U32(buffer[bufferPos++])] |= (d.bits[d.count++] << bitWidth);
							} while (--numExcept != 0);
						}
						else {
							for (u32 off = dstOff, end = bufferPos + 32; bufferPos != end; bufferPos += 4, off += 32) {
								for (u32 subset = read32(buffer, bufferPos); subset != 0; subset &= (subset - 1)) {
									// Add exceptional high bits to unpacked value.
									dst[off + Util::trailingZeros32Unsafe(subset)] |= (d.bits[d.count++] << bitWidth);
								}
							}
						}
					}
					// Differentially decode the patched values.
					for (const u32 end = dstOff + BLOCK_SIZE; dstOff != end; ++dstOff) {
						dst[dstOff] = zag(dst[dstOff]) + dst[dstOff - DIFF];
					}
				}
			}
			srcOff = exceptOff;
		}
		// Done with blocks, deal with trailing 0..255 words.
		const u32 remainder = rawLen & 0xFF;
		if (remainder != 0) {
			const u32 compRemainder = streamEnd - srcOff;
			if (compRemainder < remainder) {
				// Load variable byte data into buffer.
				srcOff = fill(buffer, src, srcOff, compRemainder);
				u32 bufferPos = 0;
				// Decode variable bytes (4 at a time).
				while (dstOff != dstEnd) {
					const u32 m = dstOff + Util::mathMin(4_u32, dstEnd - dstOff);
					const u32 lens = buffer[bufferPos++];
					for (u32 s = 0; dstOff != m; ++dstOff, s += 2) {
						const u32 len = (lens >> s) & 3;
						u32 val = U32(buffer[bufferPos++]) << 0;
						if (len > 0) {
							val |= U32(buffer[bufferPos++]) << 8;
							if (len > 1) {
								val |= U32(buffer[bufferPos++]) << 16;
								if (len > 2) {
									val |= U32(buffer[bufferPos++]) << 24;
								}
							}
						}
						// Decode extracted value differentially.
						dst[dstOff] = dst[dstOff - DIFF] + zag(val);
					}
				}
			}
			else {
				std::copy(src + srcOff, src + srcOff + remainder, dst + dstOff);
				srcOff += remainder;
			}
		}
		return srcOff == streamEnd;
	}

	static inline constexpr i32 minCapacityImpl(const i32 srcLen) {
		const u32 srcLenU = U32(srcLen);
		const u32 blockRange = srcLenU & BLOCK_MULT;
		const u32 remainder = srcLenU - blockRange;
		return I32(DIFF + srcLenU + (srcLenU >> 6) + 1024 + remainder);
	}

	// A transform that allows negative values to have a small bit pattern.
	// "Positive" values are doubled, creating evenly spaced gaps into which "negative" values are placed.
	//  0	0
	// -1	1
	//  1	2
	// -2	3
	//  2	4
	// ...
	static inline constexpr u32 zig(const u32 v) {
		return (v << 1) ^ (0_u32 - (v >> 31));
		//	return (v << 1) ^ ~((v >> 31) - 1);	// use this if compiler complains about overflow
	}

	// Transforms a "zigged" value back to its original value.
	static inline constexpr u32 zag(const u32 v) {
		return (v >> 1) ^ (0_u32 - (v & 1));
		//	return (v >> 1) ^ ~((v & 1) - 1);	// use this if compiler complains about overflow
	}

	// Read a 32-bit value from buffer.
	static inline u32 read32(const u8* const src, const u32 off) {
		return U32(src[off + 0])
			| (U32(src[off + 1]) << 8)
			| (U32(src[off + 2]) << 16)
			| (U32(src[off + 3]) << 24);
	}

	// Store buffer in dst.
	static inline u32 flush(const u8* const src, u32* const dst, u32 dstOff, const u32 numWords) {
		const u32 end = dstOff + numWords;
		for (u32 off = 0; dstOff != end; ++dstOff, off += 4) {
			dst[dstOff] = read32(src, off);
		}
		return end;
	}

	// Fill buffer from src.
	static inline u32 fill(u8* const dst, const u32* const src, u32 srcOff, const u32 numWords) {
		const u32 end = srcOff + numWords;
		for (u32 i = 0; srcOff != end; ++srcOff, i += 4) {
			const u32 word = src[srcOff];
			dst[i + 0] = U8(word >> 0);
			dst[i + 1] = U8(word >> 8);
			dst[i + 2] = U8(word >> 16);
			dst[i + 3] = U8(word >> 24);
		}
		return end;
	}

	// Packing procedures
	// ===============================
	// Nothing else follows

	// Stores 32 words in "width" words.
	static inline void pack(const u32* const src, const u32 srcOff, u32* const dst, const u32 dstOff, const u32 width) {
		switch (width) {
		case  0: break;    // nothing
		case  1: pack01(src, srcOff, dst, dstOff); break;
		case  2: pack02(src, srcOff, dst, dstOff); break;
		case  3: pack03(src, srcOff, dst, dstOff); break;
		case  4: pack04(src, srcOff, dst, dstOff); break;
		case  5: pack05(src, srcOff, dst, dstOff); break;
		case  6: pack06(src, srcOff, dst, dstOff); break;
		case  7: pack07(src, srcOff, dst, dstOff); break;
		case  8: pack08(src, srcOff, dst, dstOff); break;
		case  9: pack09(src, srcOff, dst, dstOff); break;
		case 10: pack10(src, srcOff, dst, dstOff); break;
		case 11: pack11(src, srcOff, dst, dstOff); break;
		case 12: pack12(src, srcOff, dst, dstOff); break;
		case 13: pack13(src, srcOff, dst, dstOff); break;
		case 14: pack14(src, srcOff, dst, dstOff); break;
		case 15: pack15(src, srcOff, dst, dstOff); break;
		case 16: pack16(src, srcOff, dst, dstOff); break;
		case 17: pack17(src, srcOff, dst, dstOff); break;
		case 18: pack18(src, srcOff, dst, dstOff); break;
		case 19: pack19(src, srcOff, dst, dstOff); break;
		case 20: pack20(src, srcOff, dst, dstOff); break;
		case 21: pack21(src, srcOff, dst, dstOff); break;
		case 22: pack22(src, srcOff, dst, dstOff); break;
		case 23: pack23(src, srcOff, dst, dstOff); break;
		case 24: pack24(src, srcOff, dst, dstOff); break;
		case 25: pack25(src, srcOff, dst, dstOff); break;
		case 26: pack26(src, srcOff, dst, dstOff); break;
		case 27: pack27(src, srcOff, dst, dstOff); break;
		case 28: pack28(src, srcOff, dst, dstOff); break;
		case 29: pack29(src, srcOff, dst, dstOff); break;
		case 30: pack30(src, srcOff, dst, dstOff); break;
		case 31: pack31(src, srcOff, dst, dstOff); break;
		default: copy32(src, srcOff, dst, dstOff); break;
		}
	}

	static inline void unpack(const u32* const src, const u32 srcOff, u32* const dst, const u32 dstOff, const u32 width) {
		switch (width) {
		case  0: unpack00(dst, dstOff); break;
		case  1: unpack01(src, srcOff, dst, dstOff); break;
		case  2: unpack02(src, srcOff, dst, dstOff); break;
		case  3: unpack03(src, srcOff, dst, dstOff); break;
		case  4: unpack04(src, srcOff, dst, dstOff); break;
		case  5: unpack05(src, srcOff, dst, dstOff); break;
		case  6: unpack06(src, srcOff, dst, dstOff); break;
		case  7: unpack07(src, srcOff, dst, dstOff); break;
		case  8: unpack08(src, srcOff, dst, dstOff); break;
		case  9: unpack09(src, srcOff, dst, dstOff); break;
		case 10: unpack10(src, srcOff, dst, dstOff); break;
		case 11: unpack11(src, srcOff, dst, dstOff); break;
		case 12: unpack12(src, srcOff, dst, dstOff); break;
		case 13: unpack13(src, srcOff, dst, dstOff); break;
		case 14: unpack14(src, srcOff, dst, dstOff); break;
		case 15: unpack15(src, srcOff, dst, dstOff); break;
		case 16: unpack16(src, srcOff, dst, dstOff); break;
		case 17: unpack17(src, srcOff, dst, dstOff); break;
		case 18: unpack18(src, srcOff, dst, dstOff); break;
		case 19: unpack19(src, srcOff, dst, dstOff); break;
		case 20: unpack20(src, srcOff, dst, dstOff); break;
		case 21: unpack21(src, srcOff, dst, dstOff); break;
		case 22: unpack22(src, srcOff, dst, dstOff); break;
		case 23: unpack23(src, srcOff, dst, dstOff); break;
		case 24: unpack24(src, srcOff, dst, dstOff); break;
		case 25: unpack25(src, srcOff, dst, dstOff); break;
		case 26: unpack26(src, srcOff, dst, dstOff); break;
		case 27: unpack27(src, srcOff, dst, dstOff); break;
		case 28: unpack28(src, srcOff, dst, dstOff); break;
		case 29: unpack29(src, srcOff, dst, dstOff); break;
		case 30: unpack30(src, srcOff, dst, dstOff); break;
		case 31: unpack31(src, srcOff, dst, dstOff); break;
		default: copy32(src, srcOff, dst, dstOff); break;
		}
	}

	static inline void diffUnpack(const u32* const src, const u32 srcOff, u32* const dst, const u32 dstOff, const u32 width) {
		switch (width) {
		case  0: diffUnpack00(dst, dstOff); break;
		case  1: diffUnpack01(src, srcOff, dst, dstOff); break;
		case  2: diffUnpack02(src, srcOff, dst, dstOff); break;
		case  3: diffUnpack03(src, srcOff, dst, dstOff); break;
		case  4: diffUnpack04(src, srcOff, dst, dstOff); break;
		case  5: diffUnpack05(src, srcOff, dst, dstOff); break;
		case  6: diffUnpack06(src, srcOff, dst, dstOff); break;
		case  7: diffUnpack07(src, srcOff, dst, dstOff); break;
		case  8: diffUnpack08(src, srcOff, dst, dstOff); break;
		case  9: diffUnpack09(src, srcOff, dst, dstOff); break;
		case 10: diffUnpack10(src, srcOff, dst, dstOff); break;
		case 11: diffUnpack11(src, srcOff, dst, dstOff); break;
		case 12: diffUnpack12(src, srcOff, dst, dstOff); break;
		case 13: diffUnpack13(src, srcOff, dst, dstOff); break;
		case 14: diffUnpack14(src, srcOff, dst, dstOff); break;
		case 15: diffUnpack15(src, srcOff, dst, dstOff); break;
		case 16: diffUnpack16(src, srcOff, dst, dstOff); break;
		case 17: diffUnpack17(src, srcOff, dst, dstOff); break;
		case 18: diffUnpack18(src, srcOff, dst, dstOff); break;
		case 19: diffUnpack19(src, srcOff, dst, dstOff); break;
		case 20: diffUnpack20(src, srcOff, dst, dstOff); break;
		case 21: diffUnpack21(src, srcOff, dst, dstOff); break;
		case 22: diffUnpack22(src, srcOff, dst, dstOff); break;
		case 23: diffUnpack23(src, srcOff, dst, dstOff); break;
		case 24: diffUnpack24(src, srcOff, dst, dstOff); break;
		case 25: diffUnpack25(src, srcOff, dst, dstOff); break;
		case 26: diffUnpack26(src, srcOff, dst, dstOff); break;
		case 27: diffUnpack27(src, srcOff, dst, dstOff); break;
		case 28: diffUnpack28(src, srcOff, dst, dstOff); break;
		case 29: diffUnpack29(src, srcOff, dst, dstOff); break;
		case 30: diffUnpack30(src, srcOff, dst, dstOff); break;
		case 31: diffUnpack31(src, srcOff, dst, dstOff); break;
		default: diffUnpack32(src, srcOff, dst, dstOff); break;
		}
	}

	static inline void copy32(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = sr[c + 0x00];
		ds[t + 0x01] = sr[c + 0x01];
		ds[t + 0x02] = sr[c + 0x02];
		ds[t + 0x03] = sr[c + 0x03];
		ds[t + 0x04] = sr[c + 0x04];
		ds[t + 0x05] = sr[c + 0x05];
		ds[t + 0x06] = sr[c + 0x06];
		ds[t + 0x07] = sr[c + 0x07];
		ds[t + 0x08] = sr[c + 0x08];
		ds[t + 0x09] = sr[c + 0x09];
		ds[t + 0x0A] = sr[c + 0x0A];
		ds[t + 0x0B] = sr[c + 0x0B];
		ds[t + 0x0C] = sr[c + 0x0C];
		ds[t + 0x0D] = sr[c + 0x0D];
		ds[t + 0x0E] = sr[c + 0x0E];
		ds[t + 0x0F] = sr[c + 0x0F];
		ds[t + 0x10] = sr[c + 0x10];
		ds[t + 0x11] = sr[c + 0x11];
		ds[t + 0x12] = sr[c + 0x12];
		ds[t + 0x13] = sr[c + 0x13];
		ds[t + 0x14] = sr[c + 0x14];
		ds[t + 0x15] = sr[c + 0x15];
		ds[t + 0x16] = sr[c + 0x16];
		ds[t + 0x17] = sr[c + 0x17];
		ds[t + 0x18] = sr[c + 0x18];
		ds[t + 0x19] = sr[c + 0x19];
		ds[t + 0x1A] = sr[c + 0x1A];
		ds[t + 0x1B] = sr[c + 0x1B];
		ds[t + 0x1C] = sr[c + 0x1C];
		ds[t + 0x1D] = sr[c + 0x1D];
		ds[t + 0x1E] = sr[c + 0x1E];
		ds[t + 0x1F] = sr[c + 0x1F];
	}

	static inline void pack01(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x01)
			| (sr[c + 0x02] << 0x02) | (sr[c + 0x03] << 0x03)
			| (sr[c + 0x04] << 0x04) | (sr[c + 0x05] << 0x05)
			| (sr[c + 0x06] << 0x06) | (sr[c + 0x07] << 0x07)
			| (sr[c + 0x08] << 0x08) | (sr[c + 0x09] << 0x09)
			| (sr[c + 0x0A] << 0x0A) | (sr[c + 0x0B] << 0x0B)
			| (sr[c + 0x0C] << 0x0C) | (sr[c + 0x0D] << 0x0D)
			| (sr[c + 0x0E] << 0x0E) | (sr[c + 0x0F] << 0x0F)
			| (sr[c + 0x10] << 0x10) | (sr[c + 0x11] << 0x11)
			| (sr[c + 0x12] << 0x12) | (sr[c + 0x13] << 0x13)
			| (sr[c + 0x14] << 0x14) | (sr[c + 0x15] << 0x15)
			| (sr[c + 0x16] << 0x16) | (sr[c + 0x17] << 0x17)
			| (sr[c + 0x18] << 0x18) | (sr[c + 0x19] << 0x19)
			| (sr[c + 0x1A] << 0x1A) | (sr[c + 0x1B] << 0x1B)
			| (sr[c + 0x1C] << 0x1C) | (sr[c + 0x1D] << 0x1D)
			| (sr[c + 0x1E] << 0x1E) | (sr[c + 0x1F] << 0x1F);
	}

	static inline void pack02(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x02)
			| (sr[c + 0x02] << 0x04) | (sr[c + 0x03] << 0x06)
			| (sr[c + 0x04] << 0x08) | (sr[c + 0x05] << 0x0A)
			| (sr[c + 0x06] << 0x0C) | (sr[c + 0x07] << 0x0E)
			| (sr[c + 0x08] << 0x10) | (sr[c + 0x09] << 0x12)
			| (sr[c + 0x0A] << 0x14) | (sr[c + 0x0B] << 0x16)
			| (sr[c + 0x0C] << 0x18) | (sr[c + 0x0D] << 0x1A)
			| (sr[c + 0x0E] << 0x1C) | (sr[c + 0x0F] << 0x1E);
		ds[t + 0x01] = (sr[c + 0x10] >> 0x00) | (sr[c + 0x11] << 0x02)
			| (sr[c + 0x12] << 0x04) | (sr[c + 0x13] << 0x06)
			| (sr[c + 0x14] << 0x08) | (sr[c + 0x15] << 0x0A)
			| (sr[c + 0x16] << 0x0C) | (sr[c + 0x17] << 0x0E)
			| (sr[c + 0x18] << 0x10) | (sr[c + 0x19] << 0x12)
			| (sr[c + 0x1A] << 0x14) | (sr[c + 0x1B] << 0x16)
			| (sr[c + 0x1C] << 0x18) | (sr[c + 0x1D] << 0x1A)
			| (sr[c + 0x1E] << 0x1C) | (sr[c + 0x1F] << 0x1E);
	}

	static inline void pack03(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x03)
			| (sr[c + 0x02] << 0x06) | (sr[c + 0x03] << 0x09)
			| (sr[c + 0x04] << 0x0C) | (sr[c + 0x05] << 0x0F)
			| (sr[c + 0x06] << 0x12) | (sr[c + 0x07] << 0x15)
			| (sr[c + 0x08] << 0x18) | (sr[c + 0x09] << 0x1B)
			| (sr[c + 0x0A] << 0x1E);
		ds[t + 0x01] = (sr[c + 0x0A] >> 0x02) | (sr[c + 0x0B] << 0x01)
			| (sr[c + 0x0C] << 0x04) | (sr[c + 0x0D] << 0x07)
			| (sr[c + 0x0E] << 0x0A) | (sr[c + 0x0F] << 0x0D)
			| (sr[c + 0x10] << 0x10) | (sr[c + 0x11] << 0x13)
			| (sr[c + 0x12] << 0x16) | (sr[c + 0x13] << 0x19)
			| (sr[c + 0x14] << 0x1C) | (sr[c + 0x15] << 0x1F);
		ds[t + 0x02] = (sr[c + 0x15] >> 0x01) | (sr[c + 0x16] << 0x02)
			| (sr[c + 0x17] << 0x05) | (sr[c + 0x18] << 0x08)
			| (sr[c + 0x19] << 0x0B) | (sr[c + 0x1A] << 0x0E)
			| (sr[c + 0x1B] << 0x11) | (sr[c + 0x1C] << 0x14)
			| (sr[c + 0x1D] << 0x17) | (sr[c + 0x1E] << 0x1A)
			| (sr[c + 0x1F] << 0x1D);
	}

	static inline void pack04(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x04)
			| (sr[c + 0x02] << 0x08) | (sr[c + 0x03] << 0x0C)
			| (sr[c + 0x04] << 0x10) | (sr[c + 0x05] << 0x14)
			| (sr[c + 0x06] << 0x18) | (sr[c + 0x07] << 0x1C);
		ds[t + 0x01] = (sr[c + 0x08] >> 0x00) | (sr[c + 0x09] << 0x04)
			| (sr[c + 0x0A] << 0x08) | (sr[c + 0x0B] << 0x0C)
			| (sr[c + 0x0C] << 0x10) | (sr[c + 0x0D] << 0x14)
			| (sr[c + 0x0E] << 0x18) | (sr[c + 0x0F] << 0x1C);
		ds[t + 0x02] = (sr[c + 0x10] >> 0x00) | (sr[c + 0x11] << 0x04)
			| (sr[c + 0x12] << 0x08) | (sr[c + 0x13] << 0x0C)
			| (sr[c + 0x14] << 0x10) | (sr[c + 0x15] << 0x14)
			| (sr[c + 0x16] << 0x18) | (sr[c + 0x17] << 0x1C);
		ds[t + 0x03] = (sr[c + 0x18] >> 0x00) | (sr[c + 0x19] << 0x04)
			| (sr[c + 0x1A] << 0x08) | (sr[c + 0x1B] << 0x0C)
			| (sr[c + 0x1C] << 0x10) | (sr[c + 0x1D] << 0x14)
			| (sr[c + 0x1E] << 0x18) | (sr[c + 0x1F] << 0x1C);
	}

	static inline void pack05(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x05)
			| (sr[c + 0x02] << 0x0A) | (sr[c + 0x03] << 0x0F)
			| (sr[c + 0x04] << 0x14) | (sr[c + 0x05] << 0x19)
			| (sr[c + 0x06] << 0x1E);
		ds[t + 0x01] = (sr[c + 0x06] >> 0x02) | (sr[c + 0x07] << 0x03)
			| (sr[c + 0x08] << 0x08) | (sr[c + 0x09] << 0x0D)
			| (sr[c + 0x0A] << 0x12) | (sr[c + 0x0B] << 0x17)
			| (sr[c + 0x0C] << 0x1C);
		ds[t + 0x02] = (sr[c + 0x0C] >> 0x04) | (sr[c + 0x0D] << 0x01)
			| (sr[c + 0x0E] << 0x06) | (sr[c + 0x0F] << 0x0B)
			| (sr[c + 0x10] << 0x10) | (sr[c + 0x11] << 0x15)
			| (sr[c + 0x12] << 0x1A) | (sr[c + 0x13] << 0x1F);
		ds[t + 0x03] = (sr[c + 0x13] >> 0x01) | (sr[c + 0x14] << 0x04)
			| (sr[c + 0x15] << 0x09) | (sr[c + 0x16] << 0x0E)
			| (sr[c + 0x17] << 0x13) | (sr[c + 0x18] << 0x18)
			| (sr[c + 0x19] << 0x1D);
		ds[t + 0x04] = (sr[c + 0x19] >> 0x03) | (sr[c + 0x1A] << 0x02)
			| (sr[c + 0x1B] << 0x07) | (sr[c + 0x1C] << 0x0C)
			| (sr[c + 0x1D] << 0x11) | (sr[c + 0x1E] << 0x16)
			| (sr[c + 0x1F] << 0x1B);
	}

	static inline void pack06(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x06)
			| (sr[c + 0x02] << 0x0C) | (sr[c + 0x03] << 0x12)
			| (sr[c + 0x04] << 0x18) | (sr[c + 0x05] << 0x1E);
		ds[t + 0x01] = (sr[c + 0x05] >> 0x02) | (sr[c + 0x06] << 0x04)
			| (sr[c + 0x07] << 0x0A) | (sr[c + 0x08] << 0x10)
			| (sr[c + 0x09] << 0x16) | (sr[c + 0x0A] << 0x1C);
		ds[t + 0x02] = (sr[c + 0x0A] >> 0x04) | (sr[c + 0x0B] << 0x02)
			| (sr[c + 0x0C] << 0x08) | (sr[c + 0x0D] << 0x0E)
			| (sr[c + 0x0E] << 0x14) | (sr[c + 0x0F] << 0x1A);
		ds[t + 0x03] = (sr[c + 0x10] >> 0x00) | (sr[c + 0x11] << 0x06)
			| (sr[c + 0x12] << 0x0C) | (sr[c + 0x13] << 0x12)
			| (sr[c + 0x14] << 0x18) | (sr[c + 0x15] << 0x1E);
		ds[t + 0x04] = (sr[c + 0x15] >> 0x02) | (sr[c + 0x16] << 0x04)
			| (sr[c + 0x17] << 0x0A) | (sr[c + 0x18] << 0x10)
			| (sr[c + 0x19] << 0x16) | (sr[c + 0x1A] << 0x1C);
		ds[t + 0x05] = (sr[c + 0x1A] >> 0x04) | (sr[c + 0x1B] << 0x02)
			| (sr[c + 0x1C] << 0x08) | (sr[c + 0x1D] << 0x0E)
			| (sr[c + 0x1E] << 0x14) | (sr[c + 0x1F] << 0x1A);
	}

	static inline void pack07(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x07)
			| (sr[c + 0x02] << 0x0E) | (sr[c + 0x03] << 0x15)
			| (sr[c + 0x04] << 0x1C);
		ds[t + 0x01] = (sr[c + 0x04] >> 0x04) | (sr[c + 0x05] << 0x03)
			| (sr[c + 0x06] << 0x0A) | (sr[c + 0x07] << 0x11)
			| (sr[c + 0x08] << 0x18) | (sr[c + 0x09] << 0x1F);
		ds[t + 0x02] = (sr[c + 0x09] >> 0x01) | (sr[c + 0x0A] << 0x06)
			| (sr[c + 0x0B] << 0x0D) | (sr[c + 0x0C] << 0x14)
			| (sr[c + 0x0D] << 0x1B);
		ds[t + 0x03] = (sr[c + 0x0D] >> 0x05) | (sr[c + 0x0E] << 0x02)
			| (sr[c + 0x0F] << 0x09) | (sr[c + 0x10] << 0x10)
			| (sr[c + 0x11] << 0x17) | (sr[c + 0x12] << 0x1E);
		ds[t + 0x04] = (sr[c + 0x12] >> 0x02) | (sr[c + 0x13] << 0x05)
			| (sr[c + 0x14] << 0x0C) | (sr[c + 0x15] << 0x13)
			| (sr[c + 0x16] << 0x1A);
		ds[t + 0x05] = (sr[c + 0x16] >> 0x06) | (sr[c + 0x17] << 0x01)
			| (sr[c + 0x18] << 0x08) | (sr[c + 0x19] << 0x0F)
			| (sr[c + 0x1A] << 0x16) | (sr[c + 0x1B] << 0x1D);
		ds[t + 0x06] = (sr[c + 0x1B] >> 0x03) | (sr[c + 0x1C] << 0x04)
			| (sr[c + 0x1D] << 0x0B) | (sr[c + 0x1E] << 0x12)
			| (sr[c + 0x1F] << 0x19);
	}

	static inline void pack08(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x08)
			| (sr[c + 0x02] << 0x10) | (sr[c + 0x03] << 0x18);
		ds[t + 0x01] = (sr[c + 0x04] >> 0x00) | (sr[c + 0x05] << 0x08)
			| (sr[c + 0x06] << 0x10) | (sr[c + 0x07] << 0x18);
		ds[t + 0x02] = (sr[c + 0x08] >> 0x00) | (sr[c + 0x09] << 0x08)
			| (sr[c + 0x0A] << 0x10) | (sr[c + 0x0B] << 0x18);
		ds[t + 0x03] = (sr[c + 0x0C] >> 0x00) | (sr[c + 0x0D] << 0x08)
			| (sr[c + 0x0E] << 0x10) | (sr[c + 0x0F] << 0x18);
		ds[t + 0x04] = (sr[c + 0x10] >> 0x00) | (sr[c + 0x11] << 0x08)
			| (sr[c + 0x12] << 0x10) | (sr[c + 0x13] << 0x18);
		ds[t + 0x05] = (sr[c + 0x14] >> 0x00) | (sr[c + 0x15] << 0x08)
			| (sr[c + 0x16] << 0x10) | (sr[c + 0x17] << 0x18);
		ds[t + 0x06] = (sr[c + 0x18] >> 0x00) | (sr[c + 0x19] << 0x08)
			| (sr[c + 0x1A] << 0x10) | (sr[c + 0x1B] << 0x18);
		ds[t + 0x07] = (sr[c + 0x1C] >> 0x00) | (sr[c + 0x1D] << 0x08)
			| (sr[c + 0x1E] << 0x10) | (sr[c + 0x1F] << 0x18);
	}

	static inline void pack09(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x09)
			| (sr[c + 0x02] << 0x12) | (sr[c + 0x03] << 0x1B);
		ds[t + 0x01] = (sr[c + 0x03] >> 0x05) | (sr[c + 0x04] << 0x04)
			| (sr[c + 0x05] << 0x0D) | (sr[c + 0x06] << 0x16)
			| (sr[c + 0x07] << 0x1F);
		ds[t + 0x02] = (sr[c + 0x07] >> 0x01) | (sr[c + 0x08] << 0x08)
			| (sr[c + 0x09] << 0x11) | (sr[c + 0x0A] << 0x1A);
		ds[t + 0x03] = (sr[c + 0x0A] >> 0x06) | (sr[c + 0x0B] << 0x03)
			| (sr[c + 0x0C] << 0x0C) | (sr[c + 0x0D] << 0x15)
			| (sr[c + 0x0E] << 0x1E);
		ds[t + 0x04] = (sr[c + 0x0E] >> 0x02) | (sr[c + 0x0F] << 0x07)
			| (sr[c + 0x10] << 0x10) | (sr[c + 0x11] << 0x19);
		ds[t + 0x05] = (sr[c + 0x11] >> 0x07) | (sr[c + 0x12] << 0x02)
			| (sr[c + 0x13] << 0x0B) | (sr[c + 0x14] << 0x14)
			| (sr[c + 0x15] << 0x1D);
		ds[t + 0x06] = (sr[c + 0x15] >> 0x03) | (sr[c + 0x16] << 0x06)
			| (sr[c + 0x17] << 0x0F) | (sr[c + 0x18] << 0x18);
		ds[t + 0x07] = (sr[c + 0x18] >> 0x08) | (sr[c + 0x19] << 0x01)
			| (sr[c + 0x1A] << 0x0A) | (sr[c + 0x1B] << 0x13)
			| (sr[c + 0x1C] << 0x1C);
		ds[t + 0x08] = (sr[c + 0x1C] >> 0x04) | (sr[c + 0x1D] << 0x05)
			| (sr[c + 0x1E] << 0x0E) | (sr[c + 0x1F] << 0x17);
	}

	static inline void pack10(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x0A)
			| (sr[c + 0x02] << 0x14) | (sr[c + 0x03] << 0x1E);
		ds[t + 0x01] = (sr[c + 0x03] >> 0x02) | (sr[c + 0x04] << 0x08)
			| (sr[c + 0x05] << 0x12) | (sr[c + 0x06] << 0x1C);
		ds[t + 0x02] = (sr[c + 0x06] >> 0x04) | (sr[c + 0x07] << 0x06)
			| (sr[c + 0x08] << 0x10) | (sr[c + 0x09] << 0x1A);
		ds[t + 0x03] = (sr[c + 0x09] >> 0x06) | (sr[c + 0x0A] << 0x04)
			| (sr[c + 0x0B] << 0x0E) | (sr[c + 0x0C] << 0x18);
		ds[t + 0x04] = (sr[c + 0x0C] >> 0x08) | (sr[c + 0x0D] << 0x02)
			| (sr[c + 0x0E] << 0x0C) | (sr[c + 0x0F] << 0x16);
		ds[t + 0x05] = (sr[c + 0x10] >> 0x00) | (sr[c + 0x11] << 0x0A)
			| (sr[c + 0x12] << 0x14) | (sr[c + 0x13] << 0x1E);
		ds[t + 0x06] = (sr[c + 0x13] >> 0x02) | (sr[c + 0x14] << 0x08)
			| (sr[c + 0x15] << 0x12) | (sr[c + 0x16] << 0x1C);
		ds[t + 0x07] = (sr[c + 0x16] >> 0x04) | (sr[c + 0x17] << 0x06)
			| (sr[c + 0x18] << 0x10) | (sr[c + 0x19] << 0x1A);
		ds[t + 0x08] = (sr[c + 0x19] >> 0x06) | (sr[c + 0x1A] << 0x04)
			| (sr[c + 0x1B] << 0x0E) | (sr[c + 0x1C] << 0x18);
		ds[t + 0x09] = (sr[c + 0x1C] >> 0x08) | (sr[c + 0x1D] << 0x02)
			| (sr[c + 0x1E] << 0x0C) | (sr[c + 0x1F] << 0x16);
	}

	static inline void pack11(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x0B) | (sr[c + 0x02] << 0x16);
		ds[t + 0x01] = (sr[c + 0x02] >> 0x0A) | (sr[c + 0x03] << 0x01)
			| (sr[c + 0x04] << 0x0C) | (sr[c + 0x05] << 0x17);
		ds[t + 0x02] = (sr[c + 0x05] >> 0x09) | (sr[c + 0x06] << 0x02)
			| (sr[c + 0x07] << 0x0D) | (sr[c + 0x08] << 0x18);
		ds[t + 0x03] = (sr[c + 0x08] >> 0x08) | (sr[c + 0x09] << 0x03)
			| (sr[c + 0x0A] << 0x0E) | (sr[c + 0x0B] << 0x19);
		ds[t + 0x04] = (sr[c + 0x0B] >> 0x07) | (sr[c + 0x0C] << 0x04)
			| (sr[c + 0x0D] << 0x0F) | (sr[c + 0x0E] << 0x1A);
		ds[t + 0x05] = (sr[c + 0x0E] >> 0x06) | (sr[c + 0x0F] << 0x05)
			| (sr[c + 0x10] << 0x10) | (sr[c + 0x11] << 0x1B);
		ds[t + 0x06] = (sr[c + 0x11] >> 0x05) | (sr[c + 0x12] << 0x06)
			| (sr[c + 0x13] << 0x11) | (sr[c + 0x14] << 0x1C);
		ds[t + 0x07] = (sr[c + 0x14] >> 0x04) | (sr[c + 0x15] << 0x07)
			| (sr[c + 0x16] << 0x12) | (sr[c + 0x17] << 0x1D);
		ds[t + 0x08] = (sr[c + 0x17] >> 0x03) | (sr[c + 0x18] << 0x08)
			| (sr[c + 0x19] << 0x13) | (sr[c + 0x1A] << 0x1E);
		ds[t + 0x09] = (sr[c + 0x1A] >> 0x02) | (sr[c + 0x1B] << 0x09)
			| (sr[c + 0x1C] << 0x14) | (sr[c + 0x1D] << 0x1F);
		ds[t + 0x0A] = (sr[c + 0x1D] >> 0x01) | (sr[c + 0x1E] << 0x0A) | (sr[c + 0x1F] << 0x15);
	}

	static inline void pack12(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x0C) | (sr[c + 0x02] << 0x18);
		ds[t + 0x01] = (sr[c + 0x02] >> 0x08) | (sr[c + 0x03] << 0x04)
			| (sr[c + 0x04] << 0x10) | (sr[c + 0x05] << 0x1C);
		ds[t + 0x02] = (sr[c + 0x05] >> 0x04) | (sr[c + 0x06] << 0x08) | (sr[c + 0x07] << 0x14);
		ds[t + 0x03] = (sr[c + 0x08] >> 0x00) | (sr[c + 0x09] << 0x0C) | (sr[c + 0x0A] << 0x18);
		ds[t + 0x04] = (sr[c + 0x0A] >> 0x08) | (sr[c + 0x0B] << 0x04)
			| (sr[c + 0x0C] << 0x10) | (sr[c + 0x0D] << 0x1C);
		ds[t + 0x05] = (sr[c + 0x0D] >> 0x04) | (sr[c + 0x0E] << 0x08) | (sr[c + 0x0F] << 0x14);
		ds[t + 0x06] = (sr[c + 0x10] >> 0x00) | (sr[c + 0x11] << 0x0C) | (sr[c + 0x12] << 0x18);
		ds[t + 0x07] = (sr[c + 0x12] >> 0x08) | (sr[c + 0x13] << 0x04)
			| (sr[c + 0x14] << 0x10) | (sr[c + 0x15] << 0x1C);
		ds[t + 0x08] = (sr[c + 0x15] >> 0x04) | (sr[c + 0x16] << 0x08) | (sr[c + 0x17] << 0x14);
		ds[t + 0x09] = (sr[c + 0x18] >> 0x00) | (sr[c + 0x19] << 0x0C) | (sr[c + 0x1A] << 0x18);
		ds[t + 0x0A] = (sr[c + 0x1A] >> 0x08) | (sr[c + 0x1B] << 0x04)
			| (sr[c + 0x1C] << 0x10) | (sr[c + 0x1D] << 0x1C);
		ds[t + 0x0B] = (sr[c + 0x1D] >> 0x04) | (sr[c + 0x1E] << 0x08) | (sr[c + 0x1F] << 0x14);
	}

	static inline void pack13(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x0D) | (sr[c + 0x02] << 0x1A);
		ds[t + 0x01] = (sr[c + 0x02] >> 0x06) | (sr[c + 0x03] << 0x07) | (sr[c + 0x04] << 0x14);
		ds[t + 0x02] = (sr[c + 0x04] >> 0x0C) | (sr[c + 0x05] << 0x01)
			| (sr[c + 0x06] << 0x0E) | (sr[c + 0x07] << 0x1B);
		ds[t + 0x03] = (sr[c + 0x07] >> 0x05) | (sr[c + 0x08] << 0x08) | (sr[c + 0x09] << 0x15);
		ds[t + 0x04] = (sr[c + 0x09] >> 0x0B) | (sr[c + 0x0A] << 0x02)
			| (sr[c + 0x0B] << 0x0F) | (sr[c + 0x0C] << 0x1C);
		ds[t + 0x05] = (sr[c + 0x0C] >> 0x04) | (sr[c + 0x0D] << 0x09) | (sr[c + 0x0E] << 0x16);
		ds[t + 0x06] = (sr[c + 0x0E] >> 0x0A) | (sr[c + 0x0F] << 0x03)
			| (sr[c + 0x10] << 0x10) | (sr[c + 0x11] << 0x1D);
		ds[t + 0x07] = (sr[c + 0x11] >> 0x03) | (sr[c + 0x12] << 0x0A) | (sr[c + 0x13] << 0x17);
		ds[t + 0x08] = (sr[c + 0x13] >> 0x09) | (sr[c + 0x14] << 0x04)
			| (sr[c + 0x15] << 0x11) | (sr[c + 0x16] << 0x1E);
		ds[t + 0x09] = (sr[c + 0x16] >> 0x02) | (sr[c + 0x17] << 0x0B) | (sr[c + 0x18] << 0x18);
		ds[t + 0x0A] = (sr[c + 0x18] >> 0x08) | (sr[c + 0x19] << 0x05)
			| (sr[c + 0x1A] << 0x12) | (sr[c + 0x1B] << 0x1F);
		ds[t + 0x0B] = (sr[c + 0x1B] >> 0x01) | (sr[c + 0x1C] << 0x0C) | (sr[c + 0x1D] << 0x19);
		ds[t + 0x0C] = (sr[c + 0x1D] >> 0x07) | (sr[c + 0x1E] << 0x06) | (sr[c + 0x1F] << 0x13);
	}

	static inline void pack14(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x0E) | (sr[c + 0x02] << 0x1C);
		ds[t + 0x01] = (sr[c + 0x02] >> 0x04) | (sr[c + 0x03] << 0x0A) | (sr[c + 0x04] << 0x18);
		ds[t + 0x02] = (sr[c + 0x04] >> 0x08) | (sr[c + 0x05] << 0x06) | (sr[c + 0x06] << 0x14);
		ds[t + 0x03] = (sr[c + 0x06] >> 0x0C) | (sr[c + 0x07] << 0x02)
			| (sr[c + 0x08] << 0x10) | (sr[c + 0x09] << 0x1E);
		ds[t + 0x04] = (sr[c + 0x09] >> 0x02) | (sr[c + 0x0A] << 0x0C) | (sr[c + 0x0B] << 0x1A);
		ds[t + 0x05] = (sr[c + 0x0B] >> 0x06) | (sr[c + 0x0C] << 0x08) | (sr[c + 0x0D] << 0x16);
		ds[t + 0x06] = (sr[c + 0x0D] >> 0x0A) | (sr[c + 0x0E] << 0x04) | (sr[c + 0x0F] << 0x12);
		ds[t + 0x07] = (sr[c + 0x10] >> 0x00) | (sr[c + 0x11] << 0x0E) | (sr[c + 0x12] << 0x1C);
		ds[t + 0x08] = (sr[c + 0x12] >> 0x04) | (sr[c + 0x13] << 0x0A) | (sr[c + 0x14] << 0x18);
		ds[t + 0x09] = (sr[c + 0x14] >> 0x08) | (sr[c + 0x15] << 0x06) | (sr[c + 0x16] << 0x14);
		ds[t + 0x0A] = (sr[c + 0x16] >> 0x0C) | (sr[c + 0x17] << 0x02)
			| (sr[c + 0x18] << 0x10) | (sr[c + 0x19] << 0x1E);
		ds[t + 0x0B] = (sr[c + 0x19] >> 0x02) | (sr[c + 0x1A] << 0x0C) | (sr[c + 0x1B] << 0x1A);
		ds[t + 0x0C] = (sr[c + 0x1B] >> 0x06) | (sr[c + 0x1C] << 0x08) | (sr[c + 0x1D] << 0x16);
		ds[t + 0x0D] = (sr[c + 0x1D] >> 0x0A) | (sr[c + 0x1E] << 0x04) | (sr[c + 0x1F] << 0x12);
	}

	static inline void pack15(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x0F) | (sr[c + 0x02] << 0x1E);
		ds[t + 0x01] = (sr[c + 0x02] >> 0x02) | (sr[c + 0x03] << 0x0D) | (sr[c + 0x04] << 0x1C);
		ds[t + 0x02] = (sr[c + 0x04] >> 0x04) | (sr[c + 0x05] << 0x0B) | (sr[c + 0x06] << 0x1A);
		ds[t + 0x03] = (sr[c + 0x06] >> 0x06) | (sr[c + 0x07] << 0x09) | (sr[c + 0x08] << 0x18);
		ds[t + 0x04] = (sr[c + 0x08] >> 0x08) | (sr[c + 0x09] << 0x07) | (sr[c + 0x0A] << 0x16);
		ds[t + 0x05] = (sr[c + 0x0A] >> 0x0A) | (sr[c + 0x0B] << 0x05) | (sr[c + 0x0C] << 0x14);
		ds[t + 0x06] = (sr[c + 0x0C] >> 0x0C) | (sr[c + 0x0D] << 0x03) | (sr[c + 0x0E] << 0x12);
		ds[t + 0x07] = (sr[c + 0x0E] >> 0x0E) | (sr[c + 0x0F] << 0x01)
			| (sr[c + 0x10] << 0x10) | (sr[c + 0x11] << 0x1F);
		ds[t + 0x08] = (sr[c + 0x11] >> 0x01) | (sr[c + 0x12] << 0x0E) | (sr[c + 0x13] << 0x1D);
		ds[t + 0x09] = (sr[c + 0x13] >> 0x03) | (sr[c + 0x14] << 0x0C) | (sr[c + 0x15] << 0x1B);
		ds[t + 0x0A] = (sr[c + 0x15] >> 0x05) | (sr[c + 0x16] << 0x0A) | (sr[c + 0x17] << 0x19);
		ds[t + 0x0B] = (sr[c + 0x17] >> 0x07) | (sr[c + 0x18] << 0x08) | (sr[c + 0x19] << 0x17);
		ds[t + 0x0C] = (sr[c + 0x19] >> 0x09) | (sr[c + 0x1A] << 0x06) | (sr[c + 0x1B] << 0x15);
		ds[t + 0x0D] = (sr[c + 0x1B] >> 0x0B) | (sr[c + 0x1C] << 0x04) | (sr[c + 0x1D] << 0x13);
		ds[t + 0x0E] = (sr[c + 0x1D] >> 0x0D) | (sr[c + 0x1E] << 0x02) | (sr[c + 0x1F] << 0x11);
	}

	static inline void pack16(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = sr[c + 0x00] | (sr[c + 0x01] << 0x10);
		ds[t + 0x01] = sr[c + 0x02] | (sr[c + 0x03] << 0x10);
		ds[t + 0x02] = sr[c + 0x04] | (sr[c + 0x05] << 0x10);
		ds[t + 0x03] = sr[c + 0x06] | (sr[c + 0x07] << 0x10);
		ds[t + 0x04] = sr[c + 0x08] | (sr[c + 0x09] << 0x10);
		ds[t + 0x05] = sr[c + 0x0A] | (sr[c + 0x0B] << 0x10);
		ds[t + 0x06] = sr[c + 0x0C] | (sr[c + 0x0D] << 0x10);
		ds[t + 0x07] = sr[c + 0x0E] | (sr[c + 0x0F] << 0x10);
		ds[t + 0x08] = sr[c + 0x10] | (sr[c + 0x11] << 0x10);
		ds[t + 0x09] = sr[c + 0x12] | (sr[c + 0x13] << 0x10);
		ds[t + 0x0A] = sr[c + 0x14] | (sr[c + 0x15] << 0x10);
		ds[t + 0x0B] = sr[c + 0x16] | (sr[c + 0x17] << 0x10);
		ds[t + 0x0C] = sr[c + 0x18] | (sr[c + 0x19] << 0x10);
		ds[t + 0x0D] = sr[c + 0x1A] | (sr[c + 0x1B] << 0x10);
		ds[t + 0x0E] = sr[c + 0x1C] | (sr[c + 0x1D] << 0x10);
		ds[t + 0x0F] = sr[c + 0x1E] | (sr[c + 0x1F] << 0x10);
	}

	static inline void pack17(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x11);
		ds[t + 0x01] = (sr[c + 0x01] >> 0x0F) | (sr[c + 0x02] << 0x02) | (sr[c + 0x03] << 0x13);
		ds[t + 0x02] = (sr[c + 0x03] >> 0x0D) | (sr[c + 0x04] << 0x04) | (sr[c + 0x05] << 0x15);
		ds[t + 0x03] = (sr[c + 0x05] >> 0x0B) | (sr[c + 0x06] << 0x06) | (sr[c + 0x07] << 0x17);
		ds[t + 0x04] = (sr[c + 0x07] >> 0x09) | (sr[c + 0x08] << 0x08) | (sr[c + 0x09] << 0x19);
		ds[t + 0x05] = (sr[c + 0x09] >> 0x07) | (sr[c + 0x0A] << 0x0A) | (sr[c + 0x0B] << 0x1B);
		ds[t + 0x06] = (sr[c + 0x0B] >> 0x05) | (sr[c + 0x0C] << 0x0C) | (sr[c + 0x0D] << 0x1D);
		ds[t + 0x07] = (sr[c + 0x0D] >> 0x03) | (sr[c + 0x0E] << 0x0E) | (sr[c + 0x0F] << 0x1F);
		ds[t + 0x08] = (sr[c + 0x0F] >> 0x01) | (sr[c + 0x10] << 0x10);
		ds[t + 0x09] = (sr[c + 0x10] >> 0x10) | (sr[c + 0x11] << 0x01) | (sr[c + 0x12] << 0x12);
		ds[t + 0x0A] = (sr[c + 0x12] >> 0x0E) | (sr[c + 0x13] << 0x03) | (sr[c + 0x14] << 0x14);
		ds[t + 0x0B] = (sr[c + 0x14] >> 0x0C) | (sr[c + 0x15] << 0x05) | (sr[c + 0x16] << 0x16);
		ds[t + 0x0C] = (sr[c + 0x16] >> 0x0A) | (sr[c + 0x17] << 0x07) | (sr[c + 0x18] << 0x18);
		ds[t + 0x0D] = (sr[c + 0x18] >> 0x08) | (sr[c + 0x19] << 0x09) | (sr[c + 0x1A] << 0x1A);
		ds[t + 0x0E] = (sr[c + 0x1A] >> 0x06) | (sr[c + 0x1B] << 0x0B) | (sr[c + 0x1C] << 0x1C);
		ds[t + 0x0F] = (sr[c + 0x1C] >> 0x04) | (sr[c + 0x1D] << 0x0D) | (sr[c + 0x1E] << 0x1E);
		ds[t + 0x10] = (sr[c + 0x1E] >> 0x02) | (sr[c + 0x1F] << 0x0F);
	}

	static inline void pack18(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x12);
		ds[t + 0x01] = (sr[c + 0x01] >> 0x0E) | (sr[c + 0x02] << 0x04) | (sr[c + 0x03] << 0x16);
		ds[t + 0x02] = (sr[c + 0x03] >> 0x0A) | (sr[c + 0x04] << 0x08) | (sr[c + 0x05] << 0x1A);
		ds[t + 0x03] = (sr[c + 0x05] >> 0x06) | (sr[c + 0x06] << 0x0C) | (sr[c + 0x07] << 0x1E);
		ds[t + 0x04] = (sr[c + 0x07] >> 0x02) | (sr[c + 0x08] << 0x10);
		ds[t + 0x05] = (sr[c + 0x08] >> 0x10) | (sr[c + 0x09] << 0x02) | (sr[c + 0x0A] << 0x14);
		ds[t + 0x06] = (sr[c + 0x0A] >> 0x0C) | (sr[c + 0x0B] << 0x06) | (sr[c + 0x0C] << 0x18);
		ds[t + 0x07] = (sr[c + 0x0C] >> 0x08) | (sr[c + 0x0D] << 0x0A) | (sr[c + 0x0E] << 0x1C);
		ds[t + 0x08] = (sr[c + 0x0E] >> 0x04) | (sr[c + 0x0F] << 0x0E);
		ds[t + 0x09] = (sr[c + 0x10] >> 0x00) | (sr[c + 0x11] << 0x12);
		ds[t + 0x0A] = (sr[c + 0x11] >> 0x0E) | (sr[c + 0x12] << 0x04) | (sr[c + 0x13] << 0x16);
		ds[t + 0x0B] = (sr[c + 0x13] >> 0x0A) | (sr[c + 0x14] << 0x08) | (sr[c + 0x15] << 0x1A);
		ds[t + 0x0C] = (sr[c + 0x15] >> 0x06) | (sr[c + 0x16] << 0x0C) | (sr[c + 0x17] << 0x1E);
		ds[t + 0x0D] = (sr[c + 0x17] >> 0x02) | (sr[c + 0x18] << 0x10);
		ds[t + 0x0E] = (sr[c + 0x18] >> 0x10) | (sr[c + 0x19] << 0x02) | (sr[c + 0x1A] << 0x14);
		ds[t + 0x0F] = (sr[c + 0x1A] >> 0x0C) | (sr[c + 0x1B] << 0x06) | (sr[c + 0x1C] << 0x18);
		ds[t + 0x10] = (sr[c + 0x1C] >> 0x08) | (sr[c + 0x1D] << 0x0A) | (sr[c + 0x1E] << 0x1C);
		ds[t + 0x11] = (sr[c + 0x1E] >> 0x04) | (sr[c + 0x1F] << 0x0E);
	}

	static inline void pack19(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x13);
		ds[t + 0x01] = (sr[c + 0x01] >> 0x0D) | (sr[c + 0x02] << 0x06) | (sr[c + 0x03] << 0x19);
		ds[t + 0x02] = (sr[c + 0x03] >> 0x07) | (sr[c + 0x04] << 0x0C) | (sr[c + 0x05] << 0x1F);
		ds[t + 0x03] = (sr[c + 0x05] >> 0x01) | (sr[c + 0x06] << 0x12);
		ds[t + 0x04] = (sr[c + 0x06] >> 0x0E) | (sr[c + 0x07] << 0x05) | (sr[c + 0x08] << 0x18);
		ds[t + 0x05] = (sr[c + 0x08] >> 0x08) | (sr[c + 0x09] << 0x0B) | (sr[c + 0x0A] << 0x1E);
		ds[t + 0x06] = (sr[c + 0x0A] >> 0x02) | (sr[c + 0x0B] << 0x11);
		ds[t + 0x07] = (sr[c + 0x0B] >> 0x0F) | (sr[c + 0x0C] << 0x04) | (sr[c + 0x0D] << 0x17);
		ds[t + 0x08] = (sr[c + 0x0D] >> 0x09) | (sr[c + 0x0E] << 0x0A) | (sr[c + 0x0F] << 0x1D);
		ds[t + 0x09] = (sr[c + 0x0F] >> 0x03) | (sr[c + 0x10] << 0x10);
		ds[t + 0x0A] = (sr[c + 0x10] >> 0x10) | (sr[c + 0x11] << 0x03) | (sr[c + 0x12] << 0x16);
		ds[t + 0x0B] = (sr[c + 0x12] >> 0x0A) | (sr[c + 0x13] << 0x09) | (sr[c + 0x14] << 0x1C);
		ds[t + 0x0C] = (sr[c + 0x14] >> 0x04) | (sr[c + 0x15] << 0x0F);
		ds[t + 0x0D] = (sr[c + 0x15] >> 0x11) | (sr[c + 0x16] << 0x02) | (sr[c + 0x17] << 0x15);
		ds[t + 0x0E] = (sr[c + 0x17] >> 0x0B) | (sr[c + 0x18] << 0x08) | (sr[c + 0x19] << 0x1B);
		ds[t + 0x0F] = (sr[c + 0x19] >> 0x05) | (sr[c + 0x1A] << 0x0E);
		ds[t + 0x10] = (sr[c + 0x1A] >> 0x12) | (sr[c + 0x1B] << 0x01) | (sr[c + 0x1C] << 0x14);
		ds[t + 0x11] = (sr[c + 0x1C] >> 0x0C) | (sr[c + 0x1D] << 0x07) | (sr[c + 0x1E] << 0x1A);
		ds[t + 0x12] = (sr[c + 0x1E] >> 0x06) | (sr[c + 0x1F] << 0x0D);
	}

	static inline void pack20(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x14);
		ds[t + 0x01] = (sr[c + 0x01] >> 0x0C) | (sr[c + 0x02] << 0x08) | (sr[c + 0x03] << 0x1C);
		ds[t + 0x02] = (sr[c + 0x03] >> 0x04) | (sr[c + 0x04] << 0x10);
		ds[t + 0x03] = (sr[c + 0x04] >> 0x10) | (sr[c + 0x05] << 0x04) | (sr[c + 0x06] << 0x18);
		ds[t + 0x04] = (sr[c + 0x06] >> 0x08) | (sr[c + 0x07] << 0x0C);
		ds[t + 0x05] = (sr[c + 0x08] >> 0x00) | (sr[c + 0x09] << 0x14);
		ds[t + 0x06] = (sr[c + 0x09] >> 0x0C) | (sr[c + 0x0A] << 0x08) | (sr[c + 0x0B] << 0x1C);
		ds[t + 0x07] = (sr[c + 0x0B] >> 0x04) | (sr[c + 0x0C] << 0x10);
		ds[t + 0x08] = (sr[c + 0x0C] >> 0x10) | (sr[c + 0x0D] << 0x04) | (sr[c + 0x0E] << 0x18);
		ds[t + 0x09] = (sr[c + 0x0E] >> 0x08) | (sr[c + 0x0F] << 0x0C);
		ds[t + 0x0A] = (sr[c + 0x10] >> 0x00) | (sr[c + 0x11] << 0x14);
		ds[t + 0x0B] = (sr[c + 0x11] >> 0x0C) | (sr[c + 0x12] << 0x08) | (sr[c + 0x13] << 0x1C);
		ds[t + 0x0C] = (sr[c + 0x13] >> 0x04) | (sr[c + 0x14] << 0x10);
		ds[t + 0x0D] = (sr[c + 0x14] >> 0x10) | (sr[c + 0x15] << 0x04) | (sr[c + 0x16] << 0x18);
		ds[t + 0x0E] = (sr[c + 0x16] >> 0x08) | (sr[c + 0x17] << 0x0C);
		ds[t + 0x0F] = (sr[c + 0x18] >> 0x00) | (sr[c + 0x19] << 0x14);
		ds[t + 0x10] = (sr[c + 0x19] >> 0x0C) | (sr[c + 0x1A] << 0x08) | (sr[c + 0x1B] << 0x1C);
		ds[t + 0x11] = (sr[c + 0x1B] >> 0x04) | (sr[c + 0x1C] << 0x10);
		ds[t + 0x12] = (sr[c + 0x1C] >> 0x10) | (sr[c + 0x1D] << 0x04) | (sr[c + 0x1E] << 0x18);
		ds[t + 0x13] = (sr[c + 0x1E] >> 0x08) | (sr[c + 0x1F] << 0x0C);
	}

	static inline void pack21(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x15);
		ds[t + 0x01] = (sr[c + 0x01] >> 0x0B) | (sr[c + 0x02] << 0x0A) | (sr[c + 0x03] << 0x1F);
		ds[t + 0x02] = (sr[c + 0x03] >> 0x01) | (sr[c + 0x04] << 0x14);
		ds[t + 0x03] = (sr[c + 0x04] >> 0x0C) | (sr[c + 0x05] << 0x09) | (sr[c + 0x06] << 0x1E);
		ds[t + 0x04] = (sr[c + 0x06] >> 0x02) | (sr[c + 0x07] << 0x13);
		ds[t + 0x05] = (sr[c + 0x07] >> 0x0D) | (sr[c + 0x08] << 0x08) | (sr[c + 0x09] << 0x1D);
		ds[t + 0x06] = (sr[c + 0x09] >> 0x03) | (sr[c + 0x0A] << 0x12);
		ds[t + 0x07] = (sr[c + 0x0A] >> 0x0E) | (sr[c + 0x0B] << 0x07) | (sr[c + 0x0C] << 0x1C);
		ds[t + 0x08] = (sr[c + 0x0C] >> 0x04) | (sr[c + 0x0D] << 0x11);
		ds[t + 0x09] = (sr[c + 0x0D] >> 0x0F) | (sr[c + 0x0E] << 0x06) | (sr[c + 0x0F] << 0x1B);
		ds[t + 0x0A] = (sr[c + 0x0F] >> 0x05) | (sr[c + 0x10] << 0x10);
		ds[t + 0x0B] = (sr[c + 0x10] >> 0x10) | (sr[c + 0x11] << 0x05) | (sr[c + 0x12] << 0x1A);
		ds[t + 0x0C] = (sr[c + 0x12] >> 0x06) | (sr[c + 0x13] << 0x0F);
		ds[t + 0x0D] = (sr[c + 0x13] >> 0x11) | (sr[c + 0x14] << 0x04) | (sr[c + 0x15] << 0x19);
		ds[t + 0x0E] = (sr[c + 0x15] >> 0x07) | (sr[c + 0x16] << 0x0E);
		ds[t + 0x0F] = (sr[c + 0x16] >> 0x12) | (sr[c + 0x17] << 0x03) | (sr[c + 0x18] << 0x18);
		ds[t + 0x10] = (sr[c + 0x18] >> 0x08) | (sr[c + 0x19] << 0x0D);
		ds[t + 0x11] = (sr[c + 0x19] >> 0x13) | (sr[c + 0x1A] << 0x02) | (sr[c + 0x1B] << 0x17);
		ds[t + 0x12] = (sr[c + 0x1B] >> 0x09) | (sr[c + 0x1C] << 0x0C);
		ds[t + 0x13] = (sr[c + 0x1C] >> 0x14) | (sr[c + 0x1D] << 0x01) | (sr[c + 0x1E] << 0x16);
		ds[t + 0x14] = (sr[c + 0x1E] >> 0x0A) | (sr[c + 0x1F] << 0x0B);
	}

	static inline void pack22(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x16);
		ds[t + 0x01] = (sr[c + 0x01] >> 0x0A) | (sr[c + 0x02] << 0x0C);
		ds[t + 0x02] = (sr[c + 0x02] >> 0x14) | (sr[c + 0x03] << 0x02) | (sr[c + 0x04] << 0x18);
		ds[t + 0x03] = (sr[c + 0x04] >> 0x08) | (sr[c + 0x05] << 0x0E);
		ds[t + 0x04] = (sr[c + 0x05] >> 0x12) | (sr[c + 0x06] << 0x04) | (sr[c + 0x07] << 0x1A);
		ds[t + 0x05] = (sr[c + 0x07] >> 0x06) | (sr[c + 0x08] << 0x10);
		ds[t + 0x06] = (sr[c + 0x08] >> 0x10) | (sr[c + 0x09] << 0x06) | (sr[c + 0x0A] << 0x1C);
		ds[t + 0x07] = (sr[c + 0x0A] >> 0x04) | (sr[c + 0x0B] << 0x12);
		ds[t + 0x08] = (sr[c + 0x0B] >> 0x0E) | (sr[c + 0x0C] << 0x08) | (sr[c + 0x0D] << 0x1E);
		ds[t + 0x09] = (sr[c + 0x0D] >> 0x02) | (sr[c + 0x0E] << 0x14);
		ds[t + 0x0A] = (sr[c + 0x0E] >> 0x0C) | (sr[c + 0x0F] << 0x0A);
		ds[t + 0x0B] = (sr[c + 0x10] >> 0x00) | (sr[c + 0x11] << 0x16);
		ds[t + 0x0C] = (sr[c + 0x11] >> 0x0A) | (sr[c + 0x12] << 0x0C);
		ds[t + 0x0D] = (sr[c + 0x12] >> 0x14) | (sr[c + 0x13] << 0x02) | (sr[c + 0x14] << 0x18);
		ds[t + 0x0E] = (sr[c + 0x14] >> 0x08) | (sr[c + 0x15] << 0x0E);
		ds[t + 0x0F] = (sr[c + 0x15] >> 0x12) | (sr[c + 0x16] << 0x04) | (sr[c + 0x17] << 0x1A);
		ds[t + 0x10] = (sr[c + 0x17] >> 0x06) | (sr[c + 0x18] << 0x10);
		ds[t + 0x11] = (sr[c + 0x18] >> 0x10) | (sr[c + 0x19] << 0x06) | (sr[c + 0x1A] << 0x1C);
		ds[t + 0x12] = (sr[c + 0x1A] >> 0x04) | (sr[c + 0x1B] << 0x12);
		ds[t + 0x13] = (sr[c + 0x1B] >> 0x0E) | (sr[c + 0x1C] << 0x08) | (sr[c + 0x1D] << 0x1E);
		ds[t + 0x14] = (sr[c + 0x1D] >> 0x02) | (sr[c + 0x1E] << 0x14);
		ds[t + 0x15] = (sr[c + 0x1E] >> 0x0C) | (sr[c + 0x1F] << 0x0A);
	}

	static inline void pack23(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x17);
		ds[t + 0x01] = (sr[c + 0x01] >> 0x09) | (sr[c + 0x02] << 0x0E);
		ds[t + 0x02] = (sr[c + 0x02] >> 0x12) | (sr[c + 0x03] << 0x05) | (sr[c + 0x04] << 0x1C);
		ds[t + 0x03] = (sr[c + 0x04] >> 0x04) | (sr[c + 0x05] << 0x13);
		ds[t + 0x04] = (sr[c + 0x05] >> 0x0D) | (sr[c + 0x06] << 0x0A);
		ds[t + 0x05] = (sr[c + 0x06] >> 0x16) | (sr[c + 0x07] << 0x01) | (sr[c + 0x08] << 0x18);
		ds[t + 0x06] = (sr[c + 0x08] >> 0x08) | (sr[c + 0x09] << 0x0F);
		ds[t + 0x07] = (sr[c + 0x09] >> 0x11) | (sr[c + 0x0A] << 0x06) | (sr[c + 0x0B] << 0x1D);
		ds[t + 0x08] = (sr[c + 0x0B] >> 0x03) | (sr[c + 0x0C] << 0x14);
		ds[t + 0x09] = (sr[c + 0x0C] >> 0x0C) | (sr[c + 0x0D] << 0x0B);
		ds[t + 0x0A] = (sr[c + 0x0D] >> 0x15) | (sr[c + 0x0E] << 0x02) | (sr[c + 0x0F] << 0x19);
		ds[t + 0x0B] = (sr[c + 0x0F] >> 0x07) | (sr[c + 0x10] << 0x10);
		ds[t + 0x0C] = (sr[c + 0x10] >> 0x10) | (sr[c + 0x11] << 0x07) | (sr[c + 0x12] << 0x1E);
		ds[t + 0x0D] = (sr[c + 0x12] >> 0x02) | (sr[c + 0x13] << 0x15);
		ds[t + 0x0E] = (sr[c + 0x13] >> 0x0B) | (sr[c + 0x14] << 0x0C);
		ds[t + 0x0F] = (sr[c + 0x14] >> 0x14) | (sr[c + 0x15] << 0x03) | (sr[c + 0x16] << 0x1A);
		ds[t + 0x10] = (sr[c + 0x16] >> 0x06) | (sr[c + 0x17] << 0x11);
		ds[t + 0x11] = (sr[c + 0x17] >> 0x0F) | (sr[c + 0x18] << 0x08) | (sr[c + 0x19] << 0x1F);
		ds[t + 0x12] = (sr[c + 0x19] >> 0x01) | (sr[c + 0x1A] << 0x16);
		ds[t + 0x13] = (sr[c + 0x1A] >> 0x0A) | (sr[c + 0x1B] << 0x0D);
		ds[t + 0x14] = (sr[c + 0x1B] >> 0x13) | (sr[c + 0x1C] << 0x04) | (sr[c + 0x1D] << 0x1B);
		ds[t + 0x15] = (sr[c + 0x1D] >> 0x05) | (sr[c + 0x1E] << 0x12);
		ds[t + 0x16] = (sr[c + 0x1E] >> 0x0E) | (sr[c + 0x1F] << 0x09);
	}

	static inline void pack24(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x18);
		ds[t + 0x01] = (sr[c + 0x01] >> 0x08) | (sr[c + 0x02] << 0x10);
		ds[t + 0x02] = (sr[c + 0x02] >> 0x10) | (sr[c + 0x03] << 0x08);
		ds[t + 0x03] = (sr[c + 0x04] >> 0x00) | (sr[c + 0x05] << 0x18);
		ds[t + 0x04] = (sr[c + 0x05] >> 0x08) | (sr[c + 0x06] << 0x10);
		ds[t + 0x05] = (sr[c + 0x06] >> 0x10) | (sr[c + 0x07] << 0x08);
		ds[t + 0x06] = (sr[c + 0x08] >> 0x00) | (sr[c + 0x09] << 0x18);
		ds[t + 0x07] = (sr[c + 0x09] >> 0x08) | (sr[c + 0x0A] << 0x10);
		ds[t + 0x08] = (sr[c + 0x0A] >> 0x10) | (sr[c + 0x0B] << 0x08);
		ds[t + 0x09] = (sr[c + 0x0C] >> 0x00) | (sr[c + 0x0D] << 0x18);
		ds[t + 0x0A] = (sr[c + 0x0D] >> 0x08) | (sr[c + 0x0E] << 0x10);
		ds[t + 0x0B] = (sr[c + 0x0E] >> 0x10) | (sr[c + 0x0F] << 0x08);
		ds[t + 0x0C] = (sr[c + 0x10] >> 0x00) | (sr[c + 0x11] << 0x18);
		ds[t + 0x0D] = (sr[c + 0x11] >> 0x08) | (sr[c + 0x12] << 0x10);
		ds[t + 0x0E] = (sr[c + 0x12] >> 0x10) | (sr[c + 0x13] << 0x08);
		ds[t + 0x0F] = (sr[c + 0x14] >> 0x00) | (sr[c + 0x15] << 0x18);
		ds[t + 0x10] = (sr[c + 0x15] >> 0x08) | (sr[c + 0x16] << 0x10);
		ds[t + 0x11] = (sr[c + 0x16] >> 0x10) | (sr[c + 0x17] << 0x08);
		ds[t + 0x12] = (sr[c + 0x18] >> 0x00) | (sr[c + 0x19] << 0x18);
		ds[t + 0x13] = (sr[c + 0x19] >> 0x08) | (sr[c + 0x1A] << 0x10);
		ds[t + 0x14] = (sr[c + 0x1A] >> 0x10) | (sr[c + 0x1B] << 0x08);
		ds[t + 0x15] = (sr[c + 0x1C] >> 0x00) | (sr[c + 0x1D] << 0x18);
		ds[t + 0x16] = (sr[c + 0x1D] >> 0x08) | (sr[c + 0x1E] << 0x10);
		ds[t + 0x17] = (sr[c + 0x1E] >> 0x10) | (sr[c + 0x1F] << 0x08);
	}

	static inline void pack25(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x19);
		ds[t + 0x01] = (sr[c + 0x01] >> 0x07) | (sr[c + 0x02] << 0x12);
		ds[t + 0x02] = (sr[c + 0x02] >> 0x0E) | (sr[c + 0x03] << 0x0B);
		ds[t + 0x03] = (sr[c + 0x03] >> 0x15) | (sr[c + 0x04] << 0x04) | (sr[c + 0x05] << 0x1D);
		ds[t + 0x04] = (sr[c + 0x05] >> 0x03) | (sr[c + 0x06] << 0x16);
		ds[t + 0x05] = (sr[c + 0x06] >> 0x0A) | (sr[c + 0x07] << 0x0F);
		ds[t + 0x06] = (sr[c + 0x07] >> 0x11) | (sr[c + 0x08] << 0x08);
		ds[t + 0x07] = (sr[c + 0x08] >> 0x18) | (sr[c + 0x09] << 0x01) | (sr[c + 0x0A] << 0x1A);
		ds[t + 0x08] = (sr[c + 0x0A] >> 0x06) | (sr[c + 0x0B] << 0x13);
		ds[t + 0x09] = (sr[c + 0x0B] >> 0x0D) | (sr[c + 0x0C] << 0x0C);
		ds[t + 0x0A] = (sr[c + 0x0C] >> 0x14) | (sr[c + 0x0D] << 0x05) | (sr[c + 0x0E] << 0x1E);
		ds[t + 0x0B] = (sr[c + 0x0E] >> 0x02) | (sr[c + 0x0F] << 0x17);
		ds[t + 0x0C] = (sr[c + 0x0F] >> 0x09) | (sr[c + 0x10] << 0x10);
		ds[t + 0x0D] = (sr[c + 0x10] >> 0x10) | (sr[c + 0x11] << 0x09);
		ds[t + 0x0E] = (sr[c + 0x11] >> 0x17) | (sr[c + 0x12] << 0x02) | (sr[c + 0x13] << 0x1B);
		ds[t + 0x0F] = (sr[c + 0x13] >> 0x05) | (sr[c + 0x14] << 0x14);
		ds[t + 0x10] = (sr[c + 0x14] >> 0x0C) | (sr[c + 0x15] << 0x0D);
		ds[t + 0x11] = (sr[c + 0x15] >> 0x13) | (sr[c + 0x16] << 0x06) | (sr[c + 0x17] << 0x1F);
		ds[t + 0x12] = (sr[c + 0x17] >> 0x01) | (sr[c + 0x18] << 0x18);
		ds[t + 0x13] = (sr[c + 0x18] >> 0x08) | (sr[c + 0x19] << 0x11);
		ds[t + 0x14] = (sr[c + 0x19] >> 0x0F) | (sr[c + 0x1A] << 0x0A);
		ds[t + 0x15] = (sr[c + 0x1A] >> 0x16) | (sr[c + 0x1B] << 0x03) | (sr[c + 0x1C] << 0x1C);
		ds[t + 0x16] = (sr[c + 0x1C] >> 0x04) | (sr[c + 0x1D] << 0x15);
		ds[t + 0x17] = (sr[c + 0x1D] >> 0x0B) | (sr[c + 0x1E] << 0x0E);
		ds[t + 0x18] = (sr[c + 0x1E] >> 0x12) | (sr[c + 0x1F] << 0x07);
	}

	static inline void pack26(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x1A);
		ds[t + 0x01] = (sr[c + 0x01] >> 0x06) | (sr[c + 0x02] << 0x14);
		ds[t + 0x02] = (sr[c + 0x02] >> 0x0C) | (sr[c + 0x03] << 0x0E);
		ds[t + 0x03] = (sr[c + 0x03] >> 0x12) | (sr[c + 0x04] << 0x08);
		ds[t + 0x04] = (sr[c + 0x04] >> 0x18) | (sr[c + 0x05] << 0x02) | (sr[c + 0x06] << 0x1C);
		ds[t + 0x05] = (sr[c + 0x06] >> 0x04) | (sr[c + 0x07] << 0x16);
		ds[t + 0x06] = (sr[c + 0x07] >> 0x0A) | (sr[c + 0x08] << 0x10);
		ds[t + 0x07] = (sr[c + 0x08] >> 0x10) | (sr[c + 0x09] << 0x0A);
		ds[t + 0x08] = (sr[c + 0x09] >> 0x16) | (sr[c + 0x0A] << 0x04) | (sr[c + 0x0B] << 0x1E);
		ds[t + 0x09] = (sr[c + 0x0B] >> 0x02) | (sr[c + 0x0C] << 0x18);
		ds[t + 0x0A] = (sr[c + 0x0C] >> 0x08) | (sr[c + 0x0D] << 0x12);
		ds[t + 0x0B] = (sr[c + 0x0D] >> 0x0E) | (sr[c + 0x0E] << 0x0C);
		ds[t + 0x0C] = (sr[c + 0x0E] >> 0x14) | (sr[c + 0x0F] << 0x06);
		ds[t + 0x0D] = (sr[c + 0x10] >> 0x00) | (sr[c + 0x11] << 0x1A);
		ds[t + 0x0E] = (sr[c + 0x11] >> 0x06) | (sr[c + 0x12] << 0x14);
		ds[t + 0x0F] = (sr[c + 0x12] >> 0x0C) | (sr[c + 0x13] << 0x0E);
		ds[t + 0x10] = (sr[c + 0x13] >> 0x12) | (sr[c + 0x14] << 0x08);
		ds[t + 0x11] = (sr[c + 0x14] >> 0x18) | (sr[c + 0x15] << 0x02) | (sr[c + 0x16] << 0x1C);
		ds[t + 0x12] = (sr[c + 0x16] >> 0x04) | (sr[c + 0x17] << 0x16);
		ds[t + 0x13] = (sr[c + 0x17] >> 0x0A) | (sr[c + 0x18] << 0x10);
		ds[t + 0x14] = (sr[c + 0x18] >> 0x10) | (sr[c + 0x19] << 0x0A);
		ds[t + 0x15] = (sr[c + 0x19] >> 0x16) | (sr[c + 0x1A] << 0x04) | (sr[c + 0x1B] << 0x1E);
		ds[t + 0x16] = (sr[c + 0x1B] >> 0x02) | (sr[c + 0x1C] << 0x18);
		ds[t + 0x17] = (sr[c + 0x1C] >> 0x08) | (sr[c + 0x1D] << 0x12);
		ds[t + 0x18] = (sr[c + 0x1D] >> 0x0E) | (sr[c + 0x1E] << 0x0C);
		ds[t + 0x19] = (sr[c + 0x1E] >> 0x14) | (sr[c + 0x1F] << 0x06);
	}

	static inline void pack27(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x1B);
		ds[t + 0x01] = (sr[c + 0x01] >> 0x05) | (sr[c + 0x02] << 0x16);
		ds[t + 0x02] = (sr[c + 0x02] >> 0x0A) | (sr[c + 0x03] << 0x11);
		ds[t + 0x03] = (sr[c + 0x03] >> 0x0F) | (sr[c + 0x04] << 0x0C);
		ds[t + 0x04] = (sr[c + 0x04] >> 0x14) | (sr[c + 0x05] << 0x07);
		ds[t + 0x05] = (sr[c + 0x05] >> 0x19) | (sr[c + 0x06] << 0x02) | (sr[c + 0x07] << 0x1D);
		ds[t + 0x06] = (sr[c + 0x07] >> 0x03) | (sr[c + 0x08] << 0x18);
		ds[t + 0x07] = (sr[c + 0x08] >> 0x08) | (sr[c + 0x09] << 0x13);
		ds[t + 0x08] = (sr[c + 0x09] >> 0x0D) | (sr[c + 0x0A] << 0x0E);
		ds[t + 0x09] = (sr[c + 0x0A] >> 0x12) | (sr[c + 0x0B] << 0x09);
		ds[t + 0x0A] = (sr[c + 0x0B] >> 0x17) | (sr[c + 0x0C] << 0x04) | (sr[c + 0x0D] << 0x1F);
		ds[t + 0x0B] = (sr[c + 0x0D] >> 0x01) | (sr[c + 0x0E] << 0x1A);
		ds[t + 0x0C] = (sr[c + 0x0E] >> 0x06) | (sr[c + 0x0F] << 0x15);
		ds[t + 0x0D] = (sr[c + 0x0F] >> 0x0B) | (sr[c + 0x10] << 0x10);
		ds[t + 0x0E] = (sr[c + 0x10] >> 0x10) | (sr[c + 0x11] << 0x0B);
		ds[t + 0x0F] = (sr[c + 0x11] >> 0x15) | (sr[c + 0x12] << 0x06);
		ds[t + 0x10] = (sr[c + 0x12] >> 0x1A) | (sr[c + 0x13] << 0x01) | (sr[c + 0x14] << 0x1C);
		ds[t + 0x11] = (sr[c + 0x14] >> 0x04) | (sr[c + 0x15] << 0x17);
		ds[t + 0x12] = (sr[c + 0x15] >> 0x09) | (sr[c + 0x16] << 0x12);
		ds[t + 0x13] = (sr[c + 0x16] >> 0x0E) | (sr[c + 0x17] << 0x0D);
		ds[t + 0x14] = (sr[c + 0x17] >> 0x13) | (sr[c + 0x18] << 0x08);
		ds[t + 0x15] = (sr[c + 0x18] >> 0x18) | (sr[c + 0x19] << 0x03) | (sr[c + 0x1A] << 0x1E);
		ds[t + 0x16] = (sr[c + 0x1A] >> 0x02) | (sr[c + 0x1B] << 0x19);
		ds[t + 0x17] = (sr[c + 0x1B] >> 0x07) | (sr[c + 0x1C] << 0x14);
		ds[t + 0x18] = (sr[c + 0x1C] >> 0x0C) | (sr[c + 0x1D] << 0x0F);
		ds[t + 0x19] = (sr[c + 0x1D] >> 0x11) | (sr[c + 0x1E] << 0x0A);
		ds[t + 0x1A] = (sr[c + 0x1E] >> 0x16) | (sr[c + 0x1F] << 0x05);
	}

	static inline void pack28(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x1C);
		ds[t + 0x01] = (sr[c + 0x01] >> 0x04) | (sr[c + 0x02] << 0x18);
		ds[t + 0x02] = (sr[c + 0x02] >> 0x08) | (sr[c + 0x03] << 0x14);
		ds[t + 0x03] = (sr[c + 0x03] >> 0x0C) | (sr[c + 0x04] << 0x10);
		ds[t + 0x04] = (sr[c + 0x04] >> 0x10) | (sr[c + 0x05] << 0x0C);
		ds[t + 0x05] = (sr[c + 0x05] >> 0x14) | (sr[c + 0x06] << 0x08);
		ds[t + 0x06] = (sr[c + 0x06] >> 0x18) | (sr[c + 0x07] << 0x04);
		ds[t + 0x07] = (sr[c + 0x08] >> 0x00) | (sr[c + 0x09] << 0x1C);
		ds[t + 0x08] = (sr[c + 0x09] >> 0x04) | (sr[c + 0x0A] << 0x18);
		ds[t + 0x09] = (sr[c + 0x0A] >> 0x08) | (sr[c + 0x0B] << 0x14);
		ds[t + 0x0A] = (sr[c + 0x0B] >> 0x0C) | (sr[c + 0x0C] << 0x10);
		ds[t + 0x0B] = (sr[c + 0x0C] >> 0x10) | (sr[c + 0x0D] << 0x0C);
		ds[t + 0x0C] = (sr[c + 0x0D] >> 0x14) | (sr[c + 0x0E] << 0x08);
		ds[t + 0x0D] = (sr[c + 0x0E] >> 0x18) | (sr[c + 0x0F] << 0x04);
		ds[t + 0x0E] = (sr[c + 0x10] >> 0x00) | (sr[c + 0x11] << 0x1C);
		ds[t + 0x0F] = (sr[c + 0x11] >> 0x04) | (sr[c + 0x12] << 0x18);
		ds[t + 0x10] = (sr[c + 0x12] >> 0x08) | (sr[c + 0x13] << 0x14);
		ds[t + 0x11] = (sr[c + 0x13] >> 0x0C) | (sr[c + 0x14] << 0x10);
		ds[t + 0x12] = (sr[c + 0x14] >> 0x10) | (sr[c + 0x15] << 0x0C);
		ds[t + 0x13] = (sr[c + 0x15] >> 0x14) | (sr[c + 0x16] << 0x08);
		ds[t + 0x14] = (sr[c + 0x16] >> 0x18) | (sr[c + 0x17] << 0x04);
		ds[t + 0x15] = (sr[c + 0x18] >> 0x00) | (sr[c + 0x19] << 0x1C);
		ds[t + 0x16] = (sr[c + 0x19] >> 0x04) | (sr[c + 0x1A] << 0x18);
		ds[t + 0x17] = (sr[c + 0x1A] >> 0x08) | (sr[c + 0x1B] << 0x14);
		ds[t + 0x18] = (sr[c + 0x1B] >> 0x0C) | (sr[c + 0x1C] << 0x10);
		ds[t + 0x19] = (sr[c + 0x1C] >> 0x10) | (sr[c + 0x1D] << 0x0C);
		ds[t + 0x1A] = (sr[c + 0x1D] >> 0x14) | (sr[c + 0x1E] << 0x08);
		ds[t + 0x1B] = (sr[c + 0x1E] >> 0x18) | (sr[c + 0x1F] << 0x04);
	}

	static inline void pack29(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x1D);
		ds[t + 0x01] = (sr[c + 0x01] >> 0x03) | (sr[c + 0x02] << 0x1A);
		ds[t + 0x02] = (sr[c + 0x02] >> 0x06) | (sr[c + 0x03] << 0x17);
		ds[t + 0x03] = (sr[c + 0x03] >> 0x09) | (sr[c + 0x04] << 0x14);
		ds[t + 0x04] = (sr[c + 0x04] >> 0x0C) | (sr[c + 0x05] << 0x11);
		ds[t + 0x05] = (sr[c + 0x05] >> 0x0F) | (sr[c + 0x06] << 0x0E);
		ds[t + 0x06] = (sr[c + 0x06] >> 0x12) | (sr[c + 0x07] << 0x0B);
		ds[t + 0x07] = (sr[c + 0x07] >> 0x15) | (sr[c + 0x08] << 0x08);
		ds[t + 0x08] = (sr[c + 0x08] >> 0x18) | (sr[c + 0x09] << 0x05);
		ds[t + 0x09] = (sr[c + 0x09] >> 0x1B) | (sr[c + 0x0A] << 0x02) | ((sr[c + 0x0B]) << 0x1F);
		ds[t + 0x0A] = (sr[c + 0x0B] >> 0x01) | (sr[c + 0x0C] << 0x1C);
		ds[t + 0x0B] = (sr[c + 0x0C] >> 0x04) | (sr[c + 0x0D] << 0x19);
		ds[t + 0x0C] = (sr[c + 0x0D] >> 0x07) | (sr[c + 0x0E] << 0x16);
		ds[t + 0x0D] = (sr[c + 0x0E] >> 0x0A) | (sr[c + 0x0F] << 0x13);
		ds[t + 0x0E] = (sr[c + 0x0F] >> 0x0D) | (sr[c + 0x10] << 0x10);
		ds[t + 0x0F] = (sr[c + 0x10] >> 0x10) | (sr[c + 0x11] << 0x0D);
		ds[t + 0x10] = (sr[c + 0x11] >> 0x13) | (sr[c + 0x12] << 0x0A);
		ds[t + 0x11] = (sr[c + 0x12] >> 0x16) | (sr[c + 0x13] << 0x07);
		ds[t + 0x12] = (sr[c + 0x13] >> 0x19) | (sr[c + 0x14] << 0x04);
		ds[t + 0x13] = (sr[c + 0x14] >> 0x1C) | (sr[c + 0x15] << 0x01) | ((sr[c + 0x16]) << 0x1E);
		ds[t + 0x14] = (sr[c + 0x16] >> 0x02) | (sr[c + 0x17] << 0x1B);
		ds[t + 0x15] = (sr[c + 0x17] >> 0x05) | (sr[c + 0x18] << 0x18);
		ds[t + 0x16] = (sr[c + 0x18] >> 0x08) | (sr[c + 0x19] << 0x15);
		ds[t + 0x17] = (sr[c + 0x19] >> 0x0B) | (sr[c + 0x1A] << 0x12);
		ds[t + 0x18] = (sr[c + 0x1A] >> 0x0E) | (sr[c + 0x1B] << 0x0F);
		ds[t + 0x19] = (sr[c + 0x1B] >> 0x11) | (sr[c + 0x1C] << 0x0C);
		ds[t + 0x1A] = (sr[c + 0x1C] >> 0x14) | (sr[c + 0x1D] << 0x09);
		ds[t + 0x1B] = (sr[c + 0x1D] >> 0x17) | (sr[c + 0x1E] << 0x06);
		ds[t + 0x1C] = (sr[c + 0x1E] >> 0x1A) | (sr[c + 0x1F] << 0x03);
	}

	static inline void pack30(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x1E);
		ds[t + 0x01] = (sr[c + 0x01] >> 0x02) | (sr[c + 0x02] << 0x1C);
		ds[t + 0x02] = (sr[c + 0x02] >> 0x04) | (sr[c + 0x03] << 0x1A);
		ds[t + 0x03] = (sr[c + 0x03] >> 0x06) | (sr[c + 0x04] << 0x18);
		ds[t + 0x04] = (sr[c + 0x04] >> 0x08) | (sr[c + 0x05] << 0x16);
		ds[t + 0x05] = (sr[c + 0x05] >> 0x0A) | (sr[c + 0x06] << 0x14);
		ds[t + 0x06] = (sr[c + 0x06] >> 0x0C) | (sr[c + 0x07] << 0x12);
		ds[t + 0x07] = (sr[c + 0x07] >> 0x0E) | (sr[c + 0x08] << 0x10);
		ds[t + 0x08] = (sr[c + 0x08] >> 0x10) | (sr[c + 0x09] << 0x0E);
		ds[t + 0x09] = (sr[c + 0x09] >> 0x12) | (sr[c + 0x0A] << 0x0C);
		ds[t + 0x0A] = (sr[c + 0x0A] >> 0x14) | (sr[c + 0x0B] << 0x0A);
		ds[t + 0x0B] = (sr[c + 0x0B] >> 0x16) | (sr[c + 0x0C] << 0x08);
		ds[t + 0x0C] = (sr[c + 0x0C] >> 0x18) | (sr[c + 0x0D] << 0x06);
		ds[t + 0x0D] = (sr[c + 0x0D] >> 0x1A) | (sr[c + 0x0E] << 0x04);
		ds[t + 0x0E] = (sr[c + 0x0E] >> 0x1C) | (sr[c + 0x0F] << 0x02);
		ds[t + 0x0F] = (sr[c + 0x10] >> 0x00) | (sr[c + 0x11] << 0x1E);
		ds[t + 0x10] = (sr[c + 0x11] >> 0x02) | (sr[c + 0x12] << 0x1C);
		ds[t + 0x11] = (sr[c + 0x12] >> 0x04) | (sr[c + 0x13] << 0x1A);
		ds[t + 0x12] = (sr[c + 0x13] >> 0x06) | (sr[c + 0x14] << 0x18);
		ds[t + 0x13] = (sr[c + 0x14] >> 0x08) | (sr[c + 0x15] << 0x16);
		ds[t + 0x14] = (sr[c + 0x15] >> 0x0A) | (sr[c + 0x16] << 0x14);
		ds[t + 0x15] = (sr[c + 0x16] >> 0x0C) | (sr[c + 0x17] << 0x12);
		ds[t + 0x16] = (sr[c + 0x17] >> 0x0E) | (sr[c + 0x18] << 0x10);
		ds[t + 0x17] = (sr[c + 0x18] >> 0x10) | (sr[c + 0x19] << 0x0E);
		ds[t + 0x18] = (sr[c + 0x19] >> 0x12) | (sr[c + 0x1A] << 0x0C);
		ds[t + 0x19] = (sr[c + 0x1A] >> 0x14) | (sr[c + 0x1B] << 0x0A);
		ds[t + 0x1A] = (sr[c + 0x1B] >> 0x16) | (sr[c + 0x1C] << 0x08);
		ds[t + 0x1B] = (sr[c + 0x1C] >> 0x18) | (sr[c + 0x1D] << 0x06);
		ds[t + 0x1C] = (sr[c + 0x1D] >> 0x1A) | (sr[c + 0x1E] << 0x04);
		ds[t + 0x1D] = (sr[c + 0x1E] >> 0x1C) | (sr[c + 0x1F] << 0x02);
	}

	static inline void pack31(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) | (sr[c + 0x01] << 0x1F);
		ds[t + 0x01] = (sr[c + 0x01] >> 0x01) | (sr[c + 0x02] << 0x1E);
		ds[t + 0x02] = (sr[c + 0x02] >> 0x02) | (sr[c + 0x03] << 0x1D);
		ds[t + 0x03] = (sr[c + 0x03] >> 0x03) | (sr[c + 0x04] << 0x1C);
		ds[t + 0x04] = (sr[c + 0x04] >> 0x04) | (sr[c + 0x05] << 0x1B);
		ds[t + 0x05] = (sr[c + 0x05] >> 0x05) | (sr[c + 0x06] << 0x1A);
		ds[t + 0x06] = (sr[c + 0x06] >> 0x06) | (sr[c + 0x07] << 0x19);
		ds[t + 0x07] = (sr[c + 0x07] >> 0x07) | (sr[c + 0x08] << 0x18);
		ds[t + 0x08] = (sr[c + 0x08] >> 0x08) | (sr[c + 0x09] << 0x17);
		ds[t + 0x09] = (sr[c + 0x09] >> 0x09) | (sr[c + 0x0A] << 0x16);
		ds[t + 0x0A] = (sr[c + 0x0A] >> 0x0A) | (sr[c + 0x0B] << 0x15);
		ds[t + 0x0B] = (sr[c + 0x0B] >> 0x0B) | (sr[c + 0x0C] << 0x14);
		ds[t + 0x0C] = (sr[c + 0x0C] >> 0x0C) | (sr[c + 0x0D] << 0x13);
		ds[t + 0x0D] = (sr[c + 0x0D] >> 0x0D) | (sr[c + 0x0E] << 0x12);
		ds[t + 0x0E] = (sr[c + 0x0E] >> 0x0E) | (sr[c + 0x0F] << 0x11);
		ds[t + 0x0F] = (sr[c + 0x0F] >> 0x0F) | (sr[c + 0x10] << 0x10);
		ds[t + 0x10] = (sr[c + 0x10] >> 0x10) | (sr[c + 0x11] << 0x0F);
		ds[t + 0x11] = (sr[c + 0x11] >> 0x11) | (sr[c + 0x12] << 0x0E);
		ds[t + 0x12] = (sr[c + 0x12] >> 0x12) | (sr[c + 0x13] << 0x0D);
		ds[t + 0x13] = (sr[c + 0x13] >> 0x13) | (sr[c + 0x14] << 0x0C);
		ds[t + 0x14] = (sr[c + 0x14] >> 0x14) | (sr[c + 0x15] << 0x0B);
		ds[t + 0x15] = (sr[c + 0x15] >> 0x15) | (sr[c + 0x16] << 0x0A);
		ds[t + 0x16] = (sr[c + 0x16] >> 0x16) | (sr[c + 0x17] << 0x09);
		ds[t + 0x17] = (sr[c + 0x17] >> 0x17) | (sr[c + 0x18] << 0x08);
		ds[t + 0x18] = (sr[c + 0x18] >> 0x18) | (sr[c + 0x19] << 0x07);
		ds[t + 0x19] = (sr[c + 0x19] >> 0x19) | (sr[c + 0x1A] << 0x06);
		ds[t + 0x1A] = (sr[c + 0x1A] >> 0x1A) | (sr[c + 0x1B] << 0x05);
		ds[t + 0x1B] = (sr[c + 0x1B] >> 0x1B) | (sr[c + 0x1C] << 0x04);
		ds[t + 0x1C] = (sr[c + 0x1C] >> 0x1C) | (sr[c + 0x1D] << 0x03);
		ds[t + 0x1D] = (sr[c + 0x1D] >> 0x1D) | (sr[c + 0x1E] << 0x02);
		ds[t + 0x1E] = (sr[c + 0x1E] >> 0x1E) | (sr[c + 0x1F] << 0x01);
	}

	static inline void unpack00(u32* const ds, const u32 t) {
		ds[t + 0x00] = 0;
		ds[t + 0x01] = 0;
		ds[t + 0x02] = 0;
		ds[t + 0x03] = 0;
		ds[t + 0x04] = 0;
		ds[t + 0x05] = 0;
		ds[t + 0x06] = 0;
		ds[t + 0x07] = 0;
		ds[t + 0x08] = 0;
		ds[t + 0x09] = 0;
		ds[t + 0x0A] = 0;
		ds[t + 0x0B] = 0;
		ds[t + 0x0C] = 0;
		ds[t + 0x0D] = 0;
		ds[t + 0x0E] = 0;
		ds[t + 0x0F] = 0;
		ds[t + 0x10] = 0;
		ds[t + 0x11] = 0;
		ds[t + 0x12] = 0;
		ds[t + 0x13] = 0;
		ds[t + 0x14] = 0;
		ds[t + 0x15] = 0;
		ds[t + 0x16] = 0;
		ds[t + 0x17] = 0;
		ds[t + 0x18] = 0;
		ds[t + 0x19] = 0;
		ds[t + 0x1A] = 0;
		ds[t + 0x1B] = 0;
		ds[t + 0x1C] = 0;
		ds[t + 0x1D] = 0;
		ds[t + 0x1E] = 0;
		ds[t + 0x1F] = 0;
	}

	static inline void unpack01(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x00000001;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x01) & 0x00000001;
		ds[t + 0x02] = (sr[c + 0x00] >> 0x02) & 0x00000001;
		ds[t + 0x03] = (sr[c + 0x00] >> 0x03) & 0x00000001;
		ds[t + 0x04] = (sr[c + 0x00] >> 0x04) & 0x00000001;
		ds[t + 0x05] = (sr[c + 0x00] >> 0x05) & 0x00000001;
		ds[t + 0x06] = (sr[c + 0x00] >> 0x06) & 0x00000001;
		ds[t + 0x07] = (sr[c + 0x00] >> 0x07) & 0x00000001;
		ds[t + 0x08] = (sr[c + 0x00] >> 0x08) & 0x00000001;
		ds[t + 0x09] = (sr[c + 0x00] >> 0x09) & 0x00000001;
		ds[t + 0x0A] = (sr[c + 0x00] >> 0x0A) & 0x00000001;
		ds[t + 0x0B] = (sr[c + 0x00] >> 0x0B) & 0x00000001;
		ds[t + 0x0C] = (sr[c + 0x00] >> 0x0C) & 0x00000001;
		ds[t + 0x0D] = (sr[c + 0x00] >> 0x0D) & 0x00000001;
		ds[t + 0x0E] = (sr[c + 0x00] >> 0x0E) & 0x00000001;
		ds[t + 0x0F] = (sr[c + 0x00] >> 0x0F) & 0x00000001;
		ds[t + 0x10] = (sr[c + 0x00] >> 0x10) & 0x00000001;
		ds[t + 0x11] = (sr[c + 0x00] >> 0x11) & 0x00000001;
		ds[t + 0x12] = (sr[c + 0x00] >> 0x12) & 0x00000001;
		ds[t + 0x13] = (sr[c + 0x00] >> 0x13) & 0x00000001;
		ds[t + 0x14] = (sr[c + 0x00] >> 0x14) & 0x00000001;
		ds[t + 0x15] = (sr[c + 0x00] >> 0x15) & 0x00000001;
		ds[t + 0x16] = (sr[c + 0x00] >> 0x16) & 0x00000001;
		ds[t + 0x17] = (sr[c + 0x00] >> 0x17) & 0x00000001;
		ds[t + 0x18] = (sr[c + 0x00] >> 0x18) & 0x00000001;
		ds[t + 0x19] = (sr[c + 0x00] >> 0x19) & 0x00000001;
		ds[t + 0x1A] = (sr[c + 0x00] >> 0x1A) & 0x00000001;
		ds[t + 0x1B] = (sr[c + 0x00] >> 0x1B) & 0x00000001;
		ds[t + 0x1C] = (sr[c + 0x00] >> 0x1C) & 0x00000001;
		ds[t + 0x1D] = (sr[c + 0x00] >> 0x1D) & 0x00000001;
		ds[t + 0x1E] = (sr[c + 0x00] >> 0x1E) & 0x00000001;
		ds[t + 0x1F] = (sr[c + 0x00] >> 0x1F);
	}

	static inline void unpack02(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x00000003;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x02) & 0x00000003;
		ds[t + 0x02] = (sr[c + 0x00] >> 0x04) & 0x00000003;
		ds[t + 0x03] = (sr[c + 0x00] >> 0x06) & 0x00000003;
		ds[t + 0x04] = (sr[c + 0x00] >> 0x08) & 0x00000003;
		ds[t + 0x05] = (sr[c + 0x00] >> 0x0A) & 0x00000003;
		ds[t + 0x06] = (sr[c + 0x00] >> 0x0C) & 0x00000003;
		ds[t + 0x07] = (sr[c + 0x00] >> 0x0E) & 0x00000003;
		ds[t + 0x08] = (sr[c + 0x00] >> 0x10) & 0x00000003;
		ds[t + 0x09] = (sr[c + 0x00] >> 0x12) & 0x00000003;
		ds[t + 0x0A] = (sr[c + 0x00] >> 0x14) & 0x00000003;
		ds[t + 0x0B] = (sr[c + 0x00] >> 0x16) & 0x00000003;
		ds[t + 0x0C] = (sr[c + 0x00] >> 0x18) & 0x00000003;
		ds[t + 0x0D] = (sr[c + 0x00] >> 0x1A) & 0x00000003;
		ds[t + 0x0E] = (sr[c + 0x00] >> 0x1C) & 0x00000003;
		ds[t + 0x0F] = (sr[c + 0x00] >> 0x1E);
		ds[t + 0x10] = (sr[c + 0x01] >> 0x00) & 0x00000003;
		ds[t + 0x11] = (sr[c + 0x01] >> 0x02) & 0x00000003;
		ds[t + 0x12] = (sr[c + 0x01] >> 0x04) & 0x00000003;
		ds[t + 0x13] = (sr[c + 0x01] >> 0x06) & 0x00000003;
		ds[t + 0x14] = (sr[c + 0x01] >> 0x08) & 0x00000003;
		ds[t + 0x15] = (sr[c + 0x01] >> 0x0A) & 0x00000003;
		ds[t + 0x16] = (sr[c + 0x01] >> 0x0C) & 0x00000003;
		ds[t + 0x17] = (sr[c + 0x01] >> 0x0E) & 0x00000003;
		ds[t + 0x18] = (sr[c + 0x01] >> 0x10) & 0x00000003;
		ds[t + 0x19] = (sr[c + 0x01] >> 0x12) & 0x00000003;
		ds[t + 0x1A] = (sr[c + 0x01] >> 0x14) & 0x00000003;
		ds[t + 0x1B] = (sr[c + 0x01] >> 0x16) & 0x00000003;
		ds[t + 0x1C] = (sr[c + 0x01] >> 0x18) & 0x00000003;
		ds[t + 0x1D] = (sr[c + 0x01] >> 0x1A) & 0x00000003;
		ds[t + 0x1E] = (sr[c + 0x01] >> 0x1C) & 0x00000003;
		ds[t + 0x1F] = (sr[c + 0x01] >> 0x1E);
	}

	static inline void unpack03(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x00000007;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x03) & 0x00000007;
		ds[t + 0x02] = (sr[c + 0x00] >> 0x06) & 0x00000007;
		ds[t + 0x03] = (sr[c + 0x00] >> 0x09) & 0x00000007;
		ds[t + 0x04] = (sr[c + 0x00] >> 0x0C) & 0x00000007;
		ds[t + 0x05] = (sr[c + 0x00] >> 0x0F) & 0x00000007;
		ds[t + 0x06] = (sr[c + 0x00] >> 0x12) & 0x00000007;
		ds[t + 0x07] = (sr[c + 0x00] >> 0x15) & 0x00000007;
		ds[t + 0x08] = (sr[c + 0x00] >> 0x18) & 0x00000007;
		ds[t + 0x09] = (sr[c + 0x00] >> 0x1B) & 0x00000007;
		ds[t + 0x0A] = (sr[c + 0x00] >> 0x1E) | ((sr[c + 0x01] & 0x00000001) << 0x02);
		ds[t + 0x0B] = (sr[c + 0x01] >> 0x01) & 0x00000007;
		ds[t + 0x0C] = (sr[c + 0x01] >> 0x04) & 0x00000007;
		ds[t + 0x0D] = (sr[c + 0x01] >> 0x07) & 0x00000007;
		ds[t + 0x0E] = (sr[c + 0x01] >> 0x0A) & 0x00000007;
		ds[t + 0x0F] = (sr[c + 0x01] >> 0x0D) & 0x00000007;
		ds[t + 0x10] = (sr[c + 0x01] >> 0x10) & 0x00000007;
		ds[t + 0x11] = (sr[c + 0x01] >> 0x13) & 0x00000007;
		ds[t + 0x12] = (sr[c + 0x01] >> 0x16) & 0x00000007;
		ds[t + 0x13] = (sr[c + 0x01] >> 0x19) & 0x00000007;
		ds[t + 0x14] = (sr[c + 0x01] >> 0x1C) & 0x00000007;
		ds[t + 0x15] = (sr[c + 0x01] >> 0x1F) | ((sr[c + 0x02] & 0x00000003) << 0x01);
		ds[t + 0x16] = (sr[c + 0x02] >> 0x02) & 0x00000007;
		ds[t + 0x17] = (sr[c + 0x02] >> 0x05) & 0x00000007;
		ds[t + 0x18] = (sr[c + 0x02] >> 0x08) & 0x00000007;
		ds[t + 0x19] = (sr[c + 0x02] >> 0x0B) & 0x00000007;
		ds[t + 0x1A] = (sr[c + 0x02] >> 0x0E) & 0x00000007;
		ds[t + 0x1B] = (sr[c + 0x02] >> 0x11) & 0x00000007;
		ds[t + 0x1C] = (sr[c + 0x02] >> 0x14) & 0x00000007;
		ds[t + 0x1D] = (sr[c + 0x02] >> 0x17) & 0x00000007;
		ds[t + 0x1E] = (sr[c + 0x02] >> 0x1A) & 0x00000007;
		ds[t + 0x1F] = (sr[c + 0x02] >> 0x1D);
	}

	static inline void unpack04(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x0000000F;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x04) & 0x0000000F;
		ds[t + 0x02] = (sr[c + 0x00] >> 0x08) & 0x0000000F;
		ds[t + 0x03] = (sr[c + 0x00] >> 0x0C) & 0x0000000F;
		ds[t + 0x04] = (sr[c + 0x00] >> 0x10) & 0x0000000F;
		ds[t + 0x05] = (sr[c + 0x00] >> 0x14) & 0x0000000F;
		ds[t + 0x06] = (sr[c + 0x00] >> 0x18) & 0x0000000F;
		ds[t + 0x07] = (sr[c + 0x00] >> 0x1C);
		ds[t + 0x08] = (sr[c + 0x01] >> 0x00) & 0x0000000F;
		ds[t + 0x09] = (sr[c + 0x01] >> 0x04) & 0x0000000F;
		ds[t + 0x0A] = (sr[c + 0x01] >> 0x08) & 0x0000000F;
		ds[t + 0x0B] = (sr[c + 0x01] >> 0x0C) & 0x0000000F;
		ds[t + 0x0C] = (sr[c + 0x01] >> 0x10) & 0x0000000F;
		ds[t + 0x0D] = (sr[c + 0x01] >> 0x14) & 0x0000000F;
		ds[t + 0x0E] = (sr[c + 0x01] >> 0x18) & 0x0000000F;
		ds[t + 0x0F] = (sr[c + 0x01] >> 0x1C);
		ds[t + 0x10] = (sr[c + 0x02] >> 0x00) & 0x0000000F;
		ds[t + 0x11] = (sr[c + 0x02] >> 0x04) & 0x0000000F;
		ds[t + 0x12] = (sr[c + 0x02] >> 0x08) & 0x0000000F;
		ds[t + 0x13] = (sr[c + 0x02] >> 0x0C) & 0x0000000F;
		ds[t + 0x14] = (sr[c + 0x02] >> 0x10) & 0x0000000F;
		ds[t + 0x15] = (sr[c + 0x02] >> 0x14) & 0x0000000F;
		ds[t + 0x16] = (sr[c + 0x02] >> 0x18) & 0x0000000F;
		ds[t + 0x17] = (sr[c + 0x02] >> 0x1C);
		ds[t + 0x18] = (sr[c + 0x03] >> 0x00) & 0x0000000F;
		ds[t + 0x19] = (sr[c + 0x03] >> 0x04) & 0x0000000F;
		ds[t + 0x1A] = (sr[c + 0x03] >> 0x08) & 0x0000000F;
		ds[t + 0x1B] = (sr[c + 0x03] >> 0x0C) & 0x0000000F;
		ds[t + 0x1C] = (sr[c + 0x03] >> 0x10) & 0x0000000F;
		ds[t + 0x1D] = (sr[c + 0x03] >> 0x14) & 0x0000000F;
		ds[t + 0x1E] = (sr[c + 0x03] >> 0x18) & 0x0000000F;
		ds[t + 0x1F] = (sr[c + 0x03] >> 0x1C);
	}

	static inline void unpack05(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x0000001F;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x05) & 0x0000001F;
		ds[t + 0x02] = (sr[c + 0x00] >> 0x0A) & 0x0000001F;
		ds[t + 0x03] = (sr[c + 0x00] >> 0x0F) & 0x0000001F;
		ds[t + 0x04] = (sr[c + 0x00] >> 0x14) & 0x0000001F;
		ds[t + 0x05] = (sr[c + 0x00] >> 0x19) & 0x0000001F;
		ds[t + 0x06] = (sr[c + 0x00] >> 0x1E) | ((sr[c + 0x01] & 0x00000007) << 0x02);
		ds[t + 0x07] = (sr[c + 0x01] >> 0x03) & 0x0000001F;
		ds[t + 0x08] = (sr[c + 0x01] >> 0x08) & 0x0000001F;
		ds[t + 0x09] = (sr[c + 0x01] >> 0x0D) & 0x0000001F;
		ds[t + 0x0A] = (sr[c + 0x01] >> 0x12) & 0x0000001F;
		ds[t + 0x0B] = (sr[c + 0x01] >> 0x17) & 0x0000001F;
		ds[t + 0x0C] = (sr[c + 0x01] >> 0x1C) | ((sr[c + 0x02] & 0x00000001) << 0x04);
		ds[t + 0x0D] = (sr[c + 0x02] >> 0x01) & 0x0000001F;
		ds[t + 0x0E] = (sr[c + 0x02] >> 0x06) & 0x0000001F;
		ds[t + 0x0F] = (sr[c + 0x02] >> 0x0B) & 0x0000001F;
		ds[t + 0x10] = (sr[c + 0x02] >> 0x10) & 0x0000001F;
		ds[t + 0x11] = (sr[c + 0x02] >> 0x15) & 0x0000001F;
		ds[t + 0x12] = (sr[c + 0x02] >> 0x1A) & 0x0000001F;
		ds[t + 0x13] = (sr[c + 0x02] >> 0x1F) | ((sr[c + 0x03] & 0x0000000F) << 0x01);
		ds[t + 0x14] = (sr[c + 0x03] >> 0x04) & 0x0000001F;
		ds[t + 0x15] = (sr[c + 0x03] >> 0x09) & 0x0000001F;
		ds[t + 0x16] = (sr[c + 0x03] >> 0x0E) & 0x0000001F;
		ds[t + 0x17] = (sr[c + 0x03] >> 0x13) & 0x0000001F;
		ds[t + 0x18] = (sr[c + 0x03] >> 0x18) & 0x0000001F;
		ds[t + 0x19] = (sr[c + 0x03] >> 0x1D) | ((sr[c + 0x04] & 0x00000003) << 0x03);
		ds[t + 0x1A] = (sr[c + 0x04] >> 0x02) & 0x0000001F;
		ds[t + 0x1B] = (sr[c + 0x04] >> 0x07) & 0x0000001F;
		ds[t + 0x1C] = (sr[c + 0x04] >> 0x0C) & 0x0000001F;
		ds[t + 0x1D] = (sr[c + 0x04] >> 0x11) & 0x0000001F;
		ds[t + 0x1E] = (sr[c + 0x04] >> 0x16) & 0x0000001F;
		ds[t + 0x1F] = (sr[c + 0x04] >> 0x1B);
	}

	static inline void unpack06(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x0000003F;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x06) & 0x0000003F;
		ds[t + 0x02] = (sr[c + 0x00] >> 0x0C) & 0x0000003F;
		ds[t + 0x03] = (sr[c + 0x00] >> 0x12) & 0x0000003F;
		ds[t + 0x04] = (sr[c + 0x00] >> 0x18) & 0x0000003F;
		ds[t + 0x05] = (sr[c + 0x00] >> 0x1E) | ((sr[c + 0x01] & 0x0000000F) << 0x02);
		ds[t + 0x06] = (sr[c + 0x01] >> 0x04) & 0x0000003F;
		ds[t + 0x07] = (sr[c + 0x01] >> 0x0A) & 0x0000003F;
		ds[t + 0x08] = (sr[c + 0x01] >> 0x10) & 0x0000003F;
		ds[t + 0x09] = (sr[c + 0x01] >> 0x16) & 0x0000003F;
		ds[t + 0x0A] = (sr[c + 0x01] >> 0x1C) | ((sr[c + 0x02] & 0x00000003) << 0x04);
		ds[t + 0x0B] = (sr[c + 0x02] >> 0x02) & 0x0000003F;
		ds[t + 0x0C] = (sr[c + 0x02] >> 0x08) & 0x0000003F;
		ds[t + 0x0D] = (sr[c + 0x02] >> 0x0E) & 0x0000003F;
		ds[t + 0x0E] = (sr[c + 0x02] >> 0x14) & 0x0000003F;
		ds[t + 0x0F] = (sr[c + 0x02] >> 0x1A);
		ds[t + 0x10] = (sr[c + 0x03] >> 0x00) & 0x0000003F;
		ds[t + 0x11] = (sr[c + 0x03] >> 0x06) & 0x0000003F;
		ds[t + 0x12] = (sr[c + 0x03] >> 0x0C) & 0x0000003F;
		ds[t + 0x13] = (sr[c + 0x03] >> 0x12) & 0x0000003F;
		ds[t + 0x14] = (sr[c + 0x03] >> 0x18) & 0x0000003F;
		ds[t + 0x15] = (sr[c + 0x03] >> 0x1E) | ((sr[c + 0x04] & 0x0000000F) << 0x02);
		ds[t + 0x16] = (sr[c + 0x04] >> 0x04) & 0x0000003F;
		ds[t + 0x17] = (sr[c + 0x04] >> 0x0A) & 0x0000003F;
		ds[t + 0x18] = (sr[c + 0x04] >> 0x10) & 0x0000003F;
		ds[t + 0x19] = (sr[c + 0x04] >> 0x16) & 0x0000003F;
		ds[t + 0x1A] = (sr[c + 0x04] >> 0x1C) | ((sr[c + 0x05] & 0x00000003) << 0x04);
		ds[t + 0x1B] = (sr[c + 0x05] >> 0x02) & 0x0000003F;
		ds[t + 0x1C] = (sr[c + 0x05] >> 0x08) & 0x0000003F;
		ds[t + 0x1D] = (sr[c + 0x05] >> 0x0E) & 0x0000003F;
		ds[t + 0x1E] = (sr[c + 0x05] >> 0x14) & 0x0000003F;
		ds[t + 0x1F] = (sr[c + 0x05] >> 0x1A);
	}

	static inline void unpack07(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x0000007F;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x07) & 0x0000007F;
		ds[t + 0x02] = (sr[c + 0x00] >> 0x0E) & 0x0000007F;
		ds[t + 0x03] = (sr[c + 0x00] >> 0x15) & 0x0000007F;
		ds[t + 0x04] = (sr[c + 0x00] >> 0x1C) | ((sr[c + 0x01] & 0x00000007) << 0x04);
		ds[t + 0x05] = (sr[c + 0x01] >> 0x03) & 0x0000007F;
		ds[t + 0x06] = (sr[c + 0x01] >> 0x0A) & 0x0000007F;
		ds[t + 0x07] = (sr[c + 0x01] >> 0x11) & 0x0000007F;
		ds[t + 0x08] = (sr[c + 0x01] >> 0x18) & 0x0000007F;
		ds[t + 0x09] = (sr[c + 0x01] >> 0x1F) | ((sr[c + 0x02] & 0x0000003F) << 0x01);
		ds[t + 0x0A] = (sr[c + 0x02] >> 0x06) & 0x0000007F;
		ds[t + 0x0B] = (sr[c + 0x02] >> 0x0D) & 0x0000007F;
		ds[t + 0x0C] = (sr[c + 0x02] >> 0x14) & 0x0000007F;
		ds[t + 0x0D] = (sr[c + 0x02] >> 0x1B) | ((sr[c + 0x03] & 0x00000003) << 0x05);
		ds[t + 0x0E] = (sr[c + 0x03] >> 0x02) & 0x0000007F;
		ds[t + 0x0F] = (sr[c + 0x03] >> 0x09) & 0x0000007F;
		ds[t + 0x10] = (sr[c + 0x03] >> 0x10) & 0x0000007F;
		ds[t + 0x11] = (sr[c + 0x03] >> 0x17) & 0x0000007F;
		ds[t + 0x12] = (sr[c + 0x03] >> 0x1E) | ((sr[c + 0x04] & 0x0000001F) << 0x02);
		ds[t + 0x13] = (sr[c + 0x04] >> 0x05) & 0x0000007F;
		ds[t + 0x14] = (sr[c + 0x04] >> 0x0C) & 0x0000007F;
		ds[t + 0x15] = (sr[c + 0x04] >> 0x13) & 0x0000007F;
		ds[t + 0x16] = (sr[c + 0x04] >> 0x1A) | ((sr[c + 0x05] & 0x00000001) << 0x06);
		ds[t + 0x17] = (sr[c + 0x05] >> 0x01) & 0x0000007F;
		ds[t + 0x18] = (sr[c + 0x05] >> 0x08) & 0x0000007F;
		ds[t + 0x19] = (sr[c + 0x05] >> 0x0F) & 0x0000007F;
		ds[t + 0x1A] = (sr[c + 0x05] >> 0x16) & 0x0000007F;
		ds[t + 0x1B] = (sr[c + 0x05] >> 0x1D) | ((sr[c + 0x06] & 0x0000000F) << 0x03);
		ds[t + 0x1C] = (sr[c + 0x06] >> 0x04) & 0x0000007F;
		ds[t + 0x1D] = (sr[c + 0x06] >> 0x0B) & 0x0000007F;
		ds[t + 0x1E] = (sr[c + 0x06] >> 0x12) & 0x0000007F;
		ds[t + 0x1F] = (sr[c + 0x06] >> 0x19);
	}

	static inline void unpack08(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x000000FF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x08) & 0x000000FF;
		ds[t + 0x02] = (sr[c + 0x00] >> 0x10) & 0x000000FF;
		ds[t + 0x03] = (sr[c + 0x00] >> 0x18);
		ds[t + 0x04] = (sr[c + 0x01] >> 0x00) & 0x000000FF;
		ds[t + 0x05] = (sr[c + 0x01] >> 0x08) & 0x000000FF;
		ds[t + 0x06] = (sr[c + 0x01] >> 0x10) & 0x000000FF;
		ds[t + 0x07] = (sr[c + 0x01] >> 0x18);
		ds[t + 0x08] = (sr[c + 0x02] >> 0x00) & 0x000000FF;
		ds[t + 0x09] = (sr[c + 0x02] >> 0x08) & 0x000000FF;
		ds[t + 0x0A] = (sr[c + 0x02] >> 0x10) & 0x000000FF;
		ds[t + 0x0B] = (sr[c + 0x02] >> 0x18);
		ds[t + 0x0C] = (sr[c + 0x03] >> 0x00) & 0x000000FF;
		ds[t + 0x0D] = (sr[c + 0x03] >> 0x08) & 0x000000FF;
		ds[t + 0x0E] = (sr[c + 0x03] >> 0x10) & 0x000000FF;
		ds[t + 0x0F] = (sr[c + 0x03] >> 0x18);
		ds[t + 0x10] = (sr[c + 0x04] >> 0x00) & 0x000000FF;
		ds[t + 0x11] = (sr[c + 0x04] >> 0x08) & 0x000000FF;
		ds[t + 0x12] = (sr[c + 0x04] >> 0x10) & 0x000000FF;
		ds[t + 0x13] = (sr[c + 0x04] >> 0x18);
		ds[t + 0x14] = (sr[c + 0x05] >> 0x00) & 0x000000FF;
		ds[t + 0x15] = (sr[c + 0x05] >> 0x08) & 0x000000FF;
		ds[t + 0x16] = (sr[c + 0x05] >> 0x10) & 0x000000FF;
		ds[t + 0x17] = (sr[c + 0x05] >> 0x18);
		ds[t + 0x18] = (sr[c + 0x06] >> 0x00) & 0x000000FF;
		ds[t + 0x19] = (sr[c + 0x06] >> 0x08) & 0x000000FF;
		ds[t + 0x1A] = (sr[c + 0x06] >> 0x10) & 0x000000FF;
		ds[t + 0x1B] = (sr[c + 0x06] >> 0x18);
		ds[t + 0x1C] = (sr[c + 0x07] >> 0x00) & 0x000000FF;
		ds[t + 0x1D] = (sr[c + 0x07] >> 0x08) & 0x000000FF;
		ds[t + 0x1E] = (sr[c + 0x07] >> 0x10) & 0x000000FF;
		ds[t + 0x1F] = (sr[c + 0x07] >> 0x18);
	}

	static inline void unpack09(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x000001FF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x09) & 0x000001FF;
		ds[t + 0x02] = (sr[c + 0x00] >> 0x12) & 0x000001FF;
		ds[t + 0x03] = (sr[c + 0x00] >> 0x1B) | ((sr[c + 0x01] & 0x0000000F) << 0x05);
		ds[t + 0x04] = (sr[c + 0x01] >> 0x04) & 0x000001FF;
		ds[t + 0x05] = (sr[c + 0x01] >> 0x0D) & 0x000001FF;
		ds[t + 0x06] = (sr[c + 0x01] >> 0x16) & 0x000001FF;
		ds[t + 0x07] = (sr[c + 0x01] >> 0x1F) | ((sr[c + 0x02] & 0x000000FF) << 0x01);
		ds[t + 0x08] = (sr[c + 0x02] >> 0x08) & 0x000001FF;
		ds[t + 0x09] = (sr[c + 0x02] >> 0x11) & 0x000001FF;
		ds[t + 0x0A] = (sr[c + 0x02] >> 0x1A) | ((sr[c + 0x03] & 0x00000007) << 0x06);
		ds[t + 0x0B] = (sr[c + 0x03] >> 0x03) & 0x000001FF;
		ds[t + 0x0C] = (sr[c + 0x03] >> 0x0C) & 0x000001FF;
		ds[t + 0x0D] = (sr[c + 0x03] >> 0x15) & 0x000001FF;
		ds[t + 0x0E] = (sr[c + 0x03] >> 0x1E) | ((sr[c + 0x04] & 0x0000007F) << 0x02);
		ds[t + 0x0F] = (sr[c + 0x04] >> 0x07) & 0x000001FF;
		ds[t + 0x10] = (sr[c + 0x04] >> 0x10) & 0x000001FF;
		ds[t + 0x11] = (sr[c + 0x04] >> 0x19) | ((sr[c + 0x05] & 0x00000003) << 0x07);
		ds[t + 0x12] = (sr[c + 0x05] >> 0x02) & 0x000001FF;
		ds[t + 0x13] = (sr[c + 0x05] >> 0x0B) & 0x000001FF;
		ds[t + 0x14] = (sr[c + 0x05] >> 0x14) & 0x000001FF;
		ds[t + 0x15] = (sr[c + 0x05] >> 0x1D) | ((sr[c + 0x06] & 0x0000003F) << 0x03);
		ds[t + 0x16] = (sr[c + 0x06] >> 0x06) & 0x000001FF;
		ds[t + 0x17] = (sr[c + 0x06] >> 0x0F) & 0x000001FF;
		ds[t + 0x18] = (sr[c + 0x06] >> 0x18) | ((sr[c + 0x07] & 0x00000001) << 0x08);
		ds[t + 0x19] = (sr[c + 0x07] >> 0x01) & 0x000001FF;
		ds[t + 0x1A] = (sr[c + 0x07] >> 0x0A) & 0x000001FF;
		ds[t + 0x1B] = (sr[c + 0x07] >> 0x13) & 0x000001FF;
		ds[t + 0x1C] = (sr[c + 0x07] >> 0x1C) | ((sr[c + 0x08] & 0x0000001F) << 0x04);
		ds[t + 0x1D] = (sr[c + 0x08] >> 0x05) & 0x000001FF;
		ds[t + 0x1E] = (sr[c + 0x08] >> 0x0E) & 0x000001FF;
		ds[t + 0x1F] = (sr[c + 0x08] >> 0x17);
	}

	static inline void unpack10(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x000003FF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x0A) & 0x000003FF;
		ds[t + 0x02] = (sr[c + 0x00] >> 0x14) & 0x000003FF;
		ds[t + 0x03] = (sr[c + 0x00] >> 0x1E) | ((sr[c + 0x01] & 0x000000FF) << 0x02);
		ds[t + 0x04] = (sr[c + 0x01] >> 0x08) & 0x000003FF;
		ds[t + 0x05] = (sr[c + 0x01] >> 0x12) & 0x000003FF;
		ds[t + 0x06] = (sr[c + 0x01] >> 0x1C) | ((sr[c + 0x02] & 0x0000003F) << 0x04);
		ds[t + 0x07] = (sr[c + 0x02] >> 0x06) & 0x000003FF;
		ds[t + 0x08] = (sr[c + 0x02] >> 0x10) & 0x000003FF;
		ds[t + 0x09] = (sr[c + 0x02] >> 0x1A) | ((sr[c + 0x03] & 0x0000000F) << 0x06);
		ds[t + 0x0A] = (sr[c + 0x03] >> 0x04) & 0x000003FF;
		ds[t + 0x0B] = (sr[c + 0x03] >> 0x0E) & 0x000003FF;
		ds[t + 0x0C] = (sr[c + 0x03] >> 0x18) | ((sr[c + 0x04] & 0x00000003) << 0x08);
		ds[t + 0x0D] = (sr[c + 0x04] >> 0x02) & 0x000003FF;
		ds[t + 0x0E] = (sr[c + 0x04] >> 0x0C) & 0x000003FF;
		ds[t + 0x0F] = (sr[c + 0x04] >> 0x16);
		ds[t + 0x10] = (sr[c + 0x05] >> 0x00) & 0x000003FF;
		ds[t + 0x11] = (sr[c + 0x05] >> 0x0A) & 0x000003FF;
		ds[t + 0x12] = (sr[c + 0x05] >> 0x14) & 0x000003FF;
		ds[t + 0x13] = (sr[c + 0x05] >> 0x1E) | ((sr[c + 0x06] & 0x000000FF) << 0x02);
		ds[t + 0x14] = (sr[c + 0x06] >> 0x08) & 0x000003FF;
		ds[t + 0x15] = (sr[c + 0x06] >> 0x12) & 0x000003FF;
		ds[t + 0x16] = (sr[c + 0x06] >> 0x1C) | ((sr[c + 0x07] & 0x0000003F) << 0x04);
		ds[t + 0x17] = (sr[c + 0x07] >> 0x06) & 0x000003FF;
		ds[t + 0x18] = (sr[c + 0x07] >> 0x10) & 0x000003FF;
		ds[t + 0x19] = (sr[c + 0x07] >> 0x1A) | ((sr[c + 0x08] & 0x0000000F) << 0x06);
		ds[t + 0x1A] = (sr[c + 0x08] >> 0x04) & 0x000003FF;
		ds[t + 0x1B] = (sr[c + 0x08] >> 0x0E) & 0x000003FF;
		ds[t + 0x1C] = (sr[c + 0x08] >> 0x18) | ((sr[c + 0x09] & 0x00000003) << 0x08);
		ds[t + 0x1D] = (sr[c + 0x09] >> 0x02) & 0x000003FF;
		ds[t + 0x1E] = (sr[c + 0x09] >> 0x0C) & 0x000003FF;
		ds[t + 0x1F] = (sr[c + 0x09] >> 0x16);
	}

	static inline void unpack11(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x000007FF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x0B) & 0x000007FF;
		ds[t + 0x02] = (sr[c + 0x00] >> 0x16) | ((sr[c + 0x01] & 0x00000001) << 0x0A);
		ds[t + 0x03] = (sr[c + 0x01] >> 0x01) & 0x000007FF;
		ds[t + 0x04] = (sr[c + 0x01] >> 0x0C) & 0x000007FF;
		ds[t + 0x05] = (sr[c + 0x01] >> 0x17) | ((sr[c + 0x02] & 0x00000003) << 0x09);
		ds[t + 0x06] = (sr[c + 0x02] >> 0x02) & 0x000007FF;
		ds[t + 0x07] = (sr[c + 0x02] >> 0x0D) & 0x000007FF;
		ds[t + 0x08] = (sr[c + 0x02] >> 0x18) | ((sr[c + 0x03] & 0x00000007) << 0x08);
		ds[t + 0x09] = (sr[c + 0x03] >> 0x03) & 0x000007FF;
		ds[t + 0x0A] = (sr[c + 0x03] >> 0x0E) & 0x000007FF;
		ds[t + 0x0B] = (sr[c + 0x03] >> 0x19) | ((sr[c + 0x04] & 0x0000000F) << 0x07);
		ds[t + 0x0C] = (sr[c + 0x04] >> 0x04) & 0x000007FF;
		ds[t + 0x0D] = (sr[c + 0x04] >> 0x0F) & 0x000007FF;
		ds[t + 0x0E] = (sr[c + 0x04] >> 0x1A) | ((sr[c + 0x05] & 0x0000001F) << 0x06);
		ds[t + 0x0F] = (sr[c + 0x05] >> 0x05) & 0x000007FF;
		ds[t + 0x10] = (sr[c + 0x05] >> 0x10) & 0x000007FF;
		ds[t + 0x11] = (sr[c + 0x05] >> 0x1B) | ((sr[c + 0x06] & 0x0000003F) << 0x05);
		ds[t + 0x12] = (sr[c + 0x06] >> 0x06) & 0x000007FF;
		ds[t + 0x13] = (sr[c + 0x06] >> 0x11) & 0x000007FF;
		ds[t + 0x14] = (sr[c + 0x06] >> 0x1C) | ((sr[c + 0x07] & 0x0000007F) << 0x04);
		ds[t + 0x15] = (sr[c + 0x07] >> 0x07) & 0x000007FF;
		ds[t + 0x16] = (sr[c + 0x07] >> 0x12) & 0x000007FF;
		ds[t + 0x17] = (sr[c + 0x07] >> 0x1D) | ((sr[c + 0x08] & 0x000000FF) << 0x03);
		ds[t + 0x18] = (sr[c + 0x08] >> 0x08) & 0x000007FF;
		ds[t + 0x19] = (sr[c + 0x08] >> 0x13) & 0x000007FF;
		ds[t + 0x1A] = (sr[c + 0x08] >> 0x1E) | ((sr[c + 0x09] & 0x000001FF) << 0x02);
		ds[t + 0x1B] = (sr[c + 0x09] >> 0x09) & 0x000007FF;
		ds[t + 0x1C] = (sr[c + 0x09] >> 0x14) & 0x000007FF;
		ds[t + 0x1D] = (sr[c + 0x09] >> 0x1F) | ((sr[c + 0x0A] & 0x000003FF) << 0x01);
		ds[t + 0x1E] = (sr[c + 0x0A] >> 0x0A) & 0x000007FF;
		ds[t + 0x1F] = (sr[c + 0x0A] >> 0x15);
	}

	static inline void unpack12(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x00000FFF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x0C) & 0x00000FFF;
		ds[t + 0x02] = (sr[c + 0x00] >> 0x18) | ((sr[c + 0x01] & 0x0000000F) << 0x08);
		ds[t + 0x03] = (sr[c + 0x01] >> 0x04) & 0x00000FFF;
		ds[t + 0x04] = (sr[c + 0x01] >> 0x10) & 0x00000FFF;
		ds[t + 0x05] = (sr[c + 0x01] >> 0x1C) | ((sr[c + 0x02] & 0x000000FF) << 0x04);
		ds[t + 0x06] = (sr[c + 0x02] >> 0x08) & 0x00000FFF;
		ds[t + 0x07] = (sr[c + 0x02] >> 0x14);
		ds[t + 0x08] = (sr[c + 0x03] >> 0x00) & 0x00000FFF;
		ds[t + 0x09] = (sr[c + 0x03] >> 0x0C) & 0x00000FFF;
		ds[t + 0x0A] = (sr[c + 0x03] >> 0x18) | ((sr[c + 0x04] & 0x0000000F) << 0x08);
		ds[t + 0x0B] = (sr[c + 0x04] >> 0x04) & 0x00000FFF;
		ds[t + 0x0C] = (sr[c + 0x04] >> 0x10) & 0x00000FFF;
		ds[t + 0x0D] = (sr[c + 0x04] >> 0x1C) | ((sr[c + 0x05] & 0x000000FF) << 0x04);
		ds[t + 0x0E] = (sr[c + 0x05] >> 0x08) & 0x00000FFF;
		ds[t + 0x0F] = (sr[c + 0x05] >> 0x14);
		ds[t + 0x10] = (sr[c + 0x06] >> 0x00) & 0x00000FFF;
		ds[t + 0x11] = (sr[c + 0x06] >> 0x0C) & 0x00000FFF;
		ds[t + 0x12] = (sr[c + 0x06] >> 0x18) | ((sr[c + 0x07] & 0x0000000F) << 0x08);
		ds[t + 0x13] = (sr[c + 0x07] >> 0x04) & 0x00000FFF;
		ds[t + 0x14] = (sr[c + 0x07] >> 0x10) & 0x00000FFF;
		ds[t + 0x15] = (sr[c + 0x07] >> 0x1C) | ((sr[c + 0x08] & 0x000000FF) << 0x04);
		ds[t + 0x16] = (sr[c + 0x08] >> 0x08) & 0x00000FFF;
		ds[t + 0x17] = (sr[c + 0x08] >> 0x14);
		ds[t + 0x18] = (sr[c + 0x09] >> 0x00) & 0x00000FFF;
		ds[t + 0x19] = (sr[c + 0x09] >> 0x0C) & 0x00000FFF;
		ds[t + 0x1A] = (sr[c + 0x09] >> 0x18) | ((sr[c + 0x0A] & 0x0000000F) << 0x08);
		ds[t + 0x1B] = (sr[c + 0x0A] >> 0x04) & 0x00000FFF;
		ds[t + 0x1C] = (sr[c + 0x0A] >> 0x10) & 0x00000FFF;
		ds[t + 0x1D] = (sr[c + 0x0A] >> 0x1C) | ((sr[c + 0x0B] & 0x000000FF) << 0x04);
		ds[t + 0x1E] = (sr[c + 0x0B] >> 0x08) & 0x00000FFF;
		ds[t + 0x1F] = (sr[c + 0x0B] >> 0x14);
	}

	static inline void unpack13(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x00001FFF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x0D) & 0x00001FFF;
		ds[t + 0x02] = (sr[c + 0x00] >> 0x1A) | ((sr[c + 0x01] & 0x0000007F) << 0x06);
		ds[t + 0x03] = (sr[c + 0x01] >> 0x07) & 0x00001FFF;
		ds[t + 0x04] = (sr[c + 0x01] >> 0x14) | ((sr[c + 0x02] & 0x00000001) << 0x0C);
		ds[t + 0x05] = (sr[c + 0x02] >> 0x01) & 0x00001FFF;
		ds[t + 0x06] = (sr[c + 0x02] >> 0x0E) & 0x00001FFF;
		ds[t + 0x07] = (sr[c + 0x02] >> 0x1B) | ((sr[c + 0x03] & 0x000000FF) << 0x05);
		ds[t + 0x08] = (sr[c + 0x03] >> 0x08) & 0x00001FFF;
		ds[t + 0x09] = (sr[c + 0x03] >> 0x15) | ((sr[c + 0x04] & 0x00000003) << 0x0B);
		ds[t + 0x0A] = (sr[c + 0x04] >> 0x02) & 0x00001FFF;
		ds[t + 0x0B] = (sr[c + 0x04] >> 0x0F) & 0x00001FFF;
		ds[t + 0x0C] = (sr[c + 0x04] >> 0x1C) | ((sr[c + 0x05] & 0x000001FF) << 0x04);
		ds[t + 0x0D] = (sr[c + 0x05] >> 0x09) & 0x00001FFF;
		ds[t + 0x0E] = (sr[c + 0x05] >> 0x16) | ((sr[c + 0x06] & 0x00000007) << 0x0A);
		ds[t + 0x0F] = (sr[c + 0x06] >> 0x03) & 0x00001FFF;
		ds[t + 0x10] = (sr[c + 0x06] >> 0x10) & 0x00001FFF;
		ds[t + 0x11] = (sr[c + 0x06] >> 0x1D) | ((sr[c + 0x07] & 0x000003FF) << 0x03);
		ds[t + 0x12] = (sr[c + 0x07] >> 0x0A) & 0x00001FFF;
		ds[t + 0x13] = (sr[c + 0x07] >> 0x17) | ((sr[c + 0x08] & 0x0000000F) << 0x09);
		ds[t + 0x14] = (sr[c + 0x08] >> 0x04) & 0x00001FFF;
		ds[t + 0x15] = (sr[c + 0x08] >> 0x11) & 0x00001FFF;
		ds[t + 0x16] = (sr[c + 0x08] >> 0x1E) | ((sr[c + 0x09] & 0x000007FF) << 0x02);
		ds[t + 0x17] = (sr[c + 0x09] >> 0x0B) & 0x00001FFF;
		ds[t + 0x18] = (sr[c + 0x09] >> 0x18) | ((sr[c + 0x0A] & 0x0000001F) << 0x08);
		ds[t + 0x19] = (sr[c + 0x0A] >> 0x05) & 0x00001FFF;
		ds[t + 0x1A] = (sr[c + 0x0A] >> 0x12) & 0x00001FFF;
		ds[t + 0x1B] = (sr[c + 0x0A] >> 0x1F) | ((sr[c + 0x0B] & 0x00000FFF) << 0x01);
		ds[t + 0x1C] = (sr[c + 0x0B] >> 0x0C) & 0x00001FFF;
		ds[t + 0x1D] = (sr[c + 0x0B] >> 0x19) | ((sr[c + 0x0C] & 0x0000003F) << 0x07);
		ds[t + 0x1E] = (sr[c + 0x0C] >> 0x06) & 0x00001FFF;
		ds[t + 0x1F] = (sr[c + 0x0C] >> 0x13);
	}

	static inline void unpack14(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x00003FFF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x0E) & 0x00003FFF;
		ds[t + 0x02] = (sr[c + 0x00] >> 0x1C) | ((sr[c + 0x01] & 0x000003FF) << 0x04);
		ds[t + 0x03] = (sr[c + 0x01] >> 0x0A) & 0x00003FFF;
		ds[t + 0x04] = (sr[c + 0x01] >> 0x18) | ((sr[c + 0x02] & 0x0000003F) << 0x08);
		ds[t + 0x05] = (sr[c + 0x02] >> 0x06) & 0x00003FFF;
		ds[t + 0x06] = (sr[c + 0x02] >> 0x14) | ((sr[c + 0x03] & 0x00000003) << 0x0C);
		ds[t + 0x07] = (sr[c + 0x03] >> 0x02) & 0x00003FFF;
		ds[t + 0x08] = (sr[c + 0x03] >> 0x10) & 0x00003FFF;
		ds[t + 0x09] = (sr[c + 0x03] >> 0x1E) | ((sr[c + 0x04] & 0x00000FFF) << 0x02);
		ds[t + 0x0A] = (sr[c + 0x04] >> 0x0C) & 0x00003FFF;
		ds[t + 0x0B] = (sr[c + 0x04] >> 0x1A) | ((sr[c + 0x05] & 0x000000FF) << 0x06);
		ds[t + 0x0C] = (sr[c + 0x05] >> 0x08) & 0x00003FFF;
		ds[t + 0x0D] = (sr[c + 0x05] >> 0x16) | ((sr[c + 0x06] & 0x0000000F) << 0x0A);
		ds[t + 0x0E] = (sr[c + 0x06] >> 0x04) & 0x00003FFF;
		ds[t + 0x0F] = (sr[c + 0x06] >> 0x12);
		ds[t + 0x10] = (sr[c + 0x07] >> 0x00) & 0x00003FFF;
		ds[t + 0x11] = (sr[c + 0x07] >> 0x0E) & 0x00003FFF;
		ds[t + 0x12] = (sr[c + 0x07] >> 0x1C) | ((sr[c + 0x08] & 0x000003FF) << 0x04);
		ds[t + 0x13] = (sr[c + 0x08] >> 0x0A) & 0x00003FFF;
		ds[t + 0x14] = (sr[c + 0x08] >> 0x18) | ((sr[c + 0x09] & 0x0000003F) << 0x08);
		ds[t + 0x15] = (sr[c + 0x09] >> 0x06) & 0x00003FFF;
		ds[t + 0x16] = (sr[c + 0x09] >> 0x14) | ((sr[c + 0x0A] & 0x00000003) << 0x0C);
		ds[t + 0x17] = (sr[c + 0x0A] >> 0x02) & 0x00003FFF;
		ds[t + 0x18] = (sr[c + 0x0A] >> 0x10) & 0x00003FFF;
		ds[t + 0x19] = (sr[c + 0x0A] >> 0x1E) | ((sr[c + 0x0B] & 0x00000FFF) << 0x02);
		ds[t + 0x1A] = (sr[c + 0x0B] >> 0x0C) & 0x00003FFF;
		ds[t + 0x1B] = (sr[c + 0x0B] >> 0x1A) | ((sr[c + 0x0C] & 0x000000FF) << 0x06);
		ds[t + 0x1C] = (sr[c + 0x0C] >> 0x08) & 0x00003FFF;
		ds[t + 0x1D] = (sr[c + 0x0C] >> 0x16) | ((sr[c + 0x0D] & 0x0000000F) << 0x0A);
		ds[t + 0x1E] = (sr[c + 0x0D] >> 0x04) & 0x00003FFF;
		ds[t + 0x1F] = (sr[c + 0x0D] >> 0x12);
	}

	static inline void unpack15(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x00007FFF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x0F) & 0x00007FFF;
		ds[t + 0x02] = (sr[c + 0x00] >> 0x1E) | ((sr[c + 0x01] & 0x00001FFF) << 0x02);
		ds[t + 0x03] = (sr[c + 0x01] >> 0x0D) & 0x00007FFF;
		ds[t + 0x04] = (sr[c + 0x01] >> 0x1C) | ((sr[c + 0x02] & 0x000007FF) << 0x04);
		ds[t + 0x05] = (sr[c + 0x02] >> 0x0B) & 0x00007FFF;
		ds[t + 0x06] = (sr[c + 0x02] >> 0x1A) | ((sr[c + 0x03] & 0x000001FF) << 0x06);
		ds[t + 0x07] = (sr[c + 0x03] >> 0x09) & 0x00007FFF;
		ds[t + 0x08] = (sr[c + 0x03] >> 0x18) | ((sr[c + 0x04] & 0x0000007F) << 0x08);
		ds[t + 0x09] = (sr[c + 0x04] >> 0x07) & 0x00007FFF;
		ds[t + 0x0A] = (sr[c + 0x04] >> 0x16) | ((sr[c + 0x05] & 0x0000001F) << 0x0A);
		ds[t + 0x0B] = (sr[c + 0x05] >> 0x05) & 0x00007FFF;
		ds[t + 0x0C] = (sr[c + 0x05] >> 0x14) | ((sr[c + 0x06] & 0x00000007) << 0x0C);
		ds[t + 0x0D] = (sr[c + 0x06] >> 0x03) & 0x00007FFF;
		ds[t + 0x0E] = (sr[c + 0x06] >> 0x12) | ((sr[c + 0x07] & 0x00000001) << 0x0E);
		ds[t + 0x0F] = (sr[c + 0x07] >> 0x01) & 0x00007FFF;
		ds[t + 0x10] = (sr[c + 0x07] >> 0x10) & 0x00007FFF;
		ds[t + 0x11] = (sr[c + 0x07] >> 0x1F) | ((sr[c + 0x08] & 0x00003FFF) << 0x01);
		ds[t + 0x12] = (sr[c + 0x08] >> 0x0E) & 0x00007FFF;
		ds[t + 0x13] = (sr[c + 0x08] >> 0x1D) | ((sr[c + 0x09] & 0x00000FFF) << 0x03);
		ds[t + 0x14] = (sr[c + 0x09] >> 0x0C) & 0x00007FFF;
		ds[t + 0x15] = (sr[c + 0x09] >> 0x1B) | ((sr[c + 0x0A] & 0x000003FF) << 0x05);
		ds[t + 0x16] = (sr[c + 0x0A] >> 0x0A) & 0x00007FFF;
		ds[t + 0x17] = (sr[c + 0x0A] >> 0x19) | ((sr[c + 0x0B] & 0x000000FF) << 0x07);
		ds[t + 0x18] = (sr[c + 0x0B] >> 0x08) & 0x00007FFF;
		ds[t + 0x19] = (sr[c + 0x0B] >> 0x17) | ((sr[c + 0x0C] & 0x0000003F) << 0x09);
		ds[t + 0x1A] = (sr[c + 0x0C] >> 0x06) & 0x00007FFF;
		ds[t + 0x1B] = (sr[c + 0x0C] >> 0x15) | ((sr[c + 0x0D] & 0x0000000F) << 0x0B);
		ds[t + 0x1C] = (sr[c + 0x0D] >> 0x04) & 0x00007FFF;
		ds[t + 0x1D] = (sr[c + 0x0D] >> 0x13) | ((sr[c + 0x0E] & 0x00000003) << 0x0D);
		ds[t + 0x1E] = (sr[c + 0x0E] >> 0x02) & 0x00007FFF;
		ds[t + 0x1F] = (sr[c + 0x0E] >> 0x11);
	}

	static inline void unpack16(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = sr[c + 0x00] & 0x0000FFFF;
		ds[t + 0x01] = sr[c + 0x00] >> 0x10;
		ds[t + 0x02] = sr[c + 0x01] & 0x0000FFFF;
		ds[t + 0x03] = sr[c + 0x01] >> 0x10;
		ds[t + 0x04] = sr[c + 0x02] & 0x0000FFFF;
		ds[t + 0x05] = sr[c + 0x02] >> 0x10;
		ds[t + 0x06] = sr[c + 0x03] & 0x0000FFFF;
		ds[t + 0x07] = sr[c + 0x03] >> 0x10;
		ds[t + 0x08] = sr[c + 0x04] & 0x0000FFFF;
		ds[t + 0x09] = sr[c + 0x04] >> 0x10;
		ds[t + 0x0A] = sr[c + 0x05] & 0x0000FFFF;
		ds[t + 0x0B] = sr[c + 0x05] >> 0x10;
		ds[t + 0x0C] = sr[c + 0x06] & 0x0000FFFF;
		ds[t + 0x0D] = sr[c + 0x06] >> 0x10;
		ds[t + 0x0E] = sr[c + 0x07] & 0x0000FFFF;
		ds[t + 0x0F] = sr[c + 0x07] >> 0x10;
		ds[t + 0x10] = sr[c + 0x08] & 0x0000FFFF;
		ds[t + 0x11] = sr[c + 0x08] >> 0x10;
		ds[t + 0x12] = sr[c + 0x09] & 0x0000FFFF;
		ds[t + 0x13] = sr[c + 0x09] >> 0x10;
		ds[t + 0x14] = sr[c + 0x0A] & 0x0000FFFF;
		ds[t + 0x15] = sr[c + 0x0A] >> 0x10;
		ds[t + 0x16] = sr[c + 0x0B] & 0x0000FFFF;
		ds[t + 0x17] = sr[c + 0x0B] >> 0x10;
		ds[t + 0x18] = sr[c + 0x0C] & 0x0000FFFF;
		ds[t + 0x19] = sr[c + 0x0C] >> 0x10;
		ds[t + 0x1A] = sr[c + 0x0D] & 0x0000FFFF;
		ds[t + 0x1B] = sr[c + 0x0D] >> 0x10;
		ds[t + 0x1C] = sr[c + 0x0E] & 0x0000FFFF;
		ds[t + 0x1D] = sr[c + 0x0E] >> 0x10;
		ds[t + 0x1E] = sr[c + 0x0F] & 0x0000FFFF;
		ds[t + 0x1F] = sr[c + 0x0F] >> 0x10;
	}

	static inline void unpack17(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x0001FFFF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x11) | ((sr[c + 0x01] & 0x00000003) << 0x0F);
		ds[t + 0x02] = (sr[c + 0x01] >> 0x02) & 0x0001FFFF;
		ds[t + 0x03] = (sr[c + 0x01] >> 0x13) | ((sr[c + 0x02] & 0x0000000F) << 0x0D);
		ds[t + 0x04] = (sr[c + 0x02] >> 0x04) & 0x0001FFFF;
		ds[t + 0x05] = (sr[c + 0x02] >> 0x15) | ((sr[c + 0x03] & 0x0000003F) << 0x0B);
		ds[t + 0x06] = (sr[c + 0x03] >> 0x06) & 0x0001FFFF;
		ds[t + 0x07] = (sr[c + 0x03] >> 0x17) | ((sr[c + 0x04] & 0x000000FF) << 0x09);
		ds[t + 0x08] = (sr[c + 0x04] >> 0x08) & 0x0001FFFF;
		ds[t + 0x09] = (sr[c + 0x04] >> 0x19) | ((sr[c + 0x05] & 0x000003FF) << 0x07);
		ds[t + 0x0A] = (sr[c + 0x05] >> 0x0A) & 0x0001FFFF;
		ds[t + 0x0B] = (sr[c + 0x05] >> 0x1B) | ((sr[c + 0x06] & 0x00000FFF) << 0x05);
		ds[t + 0x0C] = (sr[c + 0x06] >> 0x0C) & 0x0001FFFF;
		ds[t + 0x0D] = (sr[c + 0x06] >> 0x1D) | ((sr[c + 0x07] & 0x00003FFF) << 0x03);
		ds[t + 0x0E] = (sr[c + 0x07] >> 0x0E) & 0x0001FFFF;
		ds[t + 0x0F] = (sr[c + 0x07] >> 0x1F) | ((sr[c + 0x08] & 0x0000FFFF) << 0x01);
		ds[t + 0x10] = (sr[c + 0x08] >> 0x10) | ((sr[c + 0x09] & 0x00000001) << 0x10);
		ds[t + 0x11] = (sr[c + 0x09] >> 0x01) & 0x0001FFFF;
		ds[t + 0x12] = (sr[c + 0x09] >> 0x12) | ((sr[c + 0x0A] & 0x00000007) << 0x0E);
		ds[t + 0x13] = (sr[c + 0x0A] >> 0x03) & 0x0001FFFF;
		ds[t + 0x14] = (sr[c + 0x0A] >> 0x14) | ((sr[c + 0x0B] & 0x0000001F) << 0x0C);
		ds[t + 0x15] = (sr[c + 0x0B] >> 0x05) & 0x0001FFFF;
		ds[t + 0x16] = (sr[c + 0x0B] >> 0x16) | ((sr[c + 0x0C] & 0x0000007F) << 0x0A);
		ds[t + 0x17] = (sr[c + 0x0C] >> 0x07) & 0x0001FFFF;
		ds[t + 0x18] = (sr[c + 0x0C] >> 0x18) | ((sr[c + 0x0D] & 0x000001FF) << 0x08);
		ds[t + 0x19] = (sr[c + 0x0D] >> 0x09) & 0x0001FFFF;
		ds[t + 0x1A] = (sr[c + 0x0D] >> 0x1A) | ((sr[c + 0x0E] & 0x000007FF) << 0x06);
		ds[t + 0x1B] = (sr[c + 0x0E] >> 0x0B) & 0x0001FFFF;
		ds[t + 0x1C] = (sr[c + 0x0E] >> 0x1C) | ((sr[c + 0x0F] & 0x00001FFF) << 0x04);
		ds[t + 0x1D] = (sr[c + 0x0F] >> 0x0D) & 0x0001FFFF;
		ds[t + 0x1E] = (sr[c + 0x0F] >> 0x1E) | ((sr[c + 0x10] & 0x00007FFF) << 0x02);
		ds[t + 0x1F] = (sr[c + 0x10] >> 0x0F);
	}

	static inline void unpack18(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x0003FFFF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x12) | ((sr[c + 0x01] & 0x0000000F) << 0x0E);
		ds[t + 0x02] = (sr[c + 0x01] >> 0x04) & 0x0003FFFF;
		ds[t + 0x03] = (sr[c + 0x01] >> 0x16) | ((sr[c + 0x02] & 0x000000FF) << 0x0A);
		ds[t + 0x04] = (sr[c + 0x02] >> 0x08) & 0x0003FFFF;
		ds[t + 0x05] = (sr[c + 0x02] >> 0x1A) | ((sr[c + 0x03] & 0x00000FFF) << 0x06);
		ds[t + 0x06] = (sr[c + 0x03] >> 0x0C) & 0x0003FFFF;
		ds[t + 0x07] = (sr[c + 0x03] >> 0x1E) | ((sr[c + 0x04] & 0x0000FFFF) << 0x02);
		ds[t + 0x08] = (sr[c + 0x04] >> 0x10) | ((sr[c + 0x05] & 0x00000003) << 0x10);
		ds[t + 0x09] = (sr[c + 0x05] >> 0x02) & 0x0003FFFF;
		ds[t + 0x0A] = (sr[c + 0x05] >> 0x14) | ((sr[c + 0x06] & 0x0000003F) << 0x0C);
		ds[t + 0x0B] = (sr[c + 0x06] >> 0x06) & 0x0003FFFF;
		ds[t + 0x0C] = (sr[c + 0x06] >> 0x18) | ((sr[c + 0x07] & 0x000003FF) << 0x08);
		ds[t + 0x0D] = (sr[c + 0x07] >> 0x0A) & 0x0003FFFF;
		ds[t + 0x0E] = (sr[c + 0x07] >> 0x1C) | ((sr[c + 0x08] & 0x00003FFF) << 0x04);
		ds[t + 0x0F] = (sr[c + 0x08] >> 0x0E);
		ds[t + 0x10] = (sr[c + 0x09] >> 0x00) & 0x0003FFFF;
		ds[t + 0x11] = (sr[c + 0x09] >> 0x12) | ((sr[c + 0x0A] & 0x0000000F) << 0x0E);
		ds[t + 0x12] = (sr[c + 0x0A] >> 0x04) & 0x0003FFFF;
		ds[t + 0x13] = (sr[c + 0x0A] >> 0x16) | ((sr[c + 0x0B] & 0x000000FF) << 0x0A);
		ds[t + 0x14] = (sr[c + 0x0B] >> 0x08) & 0x0003FFFF;
		ds[t + 0x15] = (sr[c + 0x0B] >> 0x1A) | ((sr[c + 0x0C] & 0x00000FFF) << 0x06);
		ds[t + 0x16] = (sr[c + 0x0C] >> 0x0C) & 0x0003FFFF;
		ds[t + 0x17] = (sr[c + 0x0C] >> 0x1E) | ((sr[c + 0x0D] & 0x0000FFFF) << 0x02);
		ds[t + 0x18] = (sr[c + 0x0D] >> 0x10) | ((sr[c + 0x0E] & 0x00000003) << 0x10);
		ds[t + 0x19] = (sr[c + 0x0E] >> 0x02) & 0x0003FFFF;
		ds[t + 0x1A] = (sr[c + 0x0E] >> 0x14) | ((sr[c + 0x0F] & 0x0000003F) << 0x0C);
		ds[t + 0x1B] = (sr[c + 0x0F] >> 0x06) & 0x0003FFFF;
		ds[t + 0x1C] = (sr[c + 0x0F] >> 0x18) | ((sr[c + 0x10] & 0x000003FF) << 0x08);
		ds[t + 0x1D] = (sr[c + 0x10] >> 0x0A) & 0x0003FFFF;
		ds[t + 0x1E] = (sr[c + 0x10] >> 0x1C) | ((sr[c + 0x11] & 0x00003FFF) << 0x04);
		ds[t + 0x1F] = (sr[c + 0x11] >> 0x0E);
	}

	static inline void unpack19(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x0007FFFF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x13) | ((sr[c + 0x01] & 0x0000003F) << 0x0D);
		ds[t + 0x02] = (sr[c + 0x01] >> 0x06) & 0x0007FFFF;
		ds[t + 0x03] = (sr[c + 0x01] >> 0x19) | ((sr[c + 0x02] & 0x00000FFF) << 0x07);
		ds[t + 0x04] = (sr[c + 0x02] >> 0x0C) & 0x0007FFFF;
		ds[t + 0x05] = (sr[c + 0x02] >> 0x1F) | ((sr[c + 0x03] & 0x0003FFFF) << 0x01);
		ds[t + 0x06] = (sr[c + 0x03] >> 0x12) | ((sr[c + 0x04] & 0x0000001F) << 0x0E);
		ds[t + 0x07] = (sr[c + 0x04] >> 0x05) & 0x0007FFFF;
		ds[t + 0x08] = (sr[c + 0x04] >> 0x18) | ((sr[c + 0x05] & 0x000007FF) << 0x08);
		ds[t + 0x09] = (sr[c + 0x05] >> 0x0B) & 0x0007FFFF;
		ds[t + 0x0A] = (sr[c + 0x05] >> 0x1E) | ((sr[c + 0x06] & 0x0001FFFF) << 0x02);
		ds[t + 0x0B] = (sr[c + 0x06] >> 0x11) | ((sr[c + 0x07] & 0x0000000F) << 0x0F);
		ds[t + 0x0C] = (sr[c + 0x07] >> 0x04) & 0x0007FFFF;
		ds[t + 0x0D] = (sr[c + 0x07] >> 0x17) | ((sr[c + 0x08] & 0x000003FF) << 0x09);
		ds[t + 0x0E] = (sr[c + 0x08] >> 0x0A) & 0x0007FFFF;
		ds[t + 0x0F] = (sr[c + 0x08] >> 0x1D) | ((sr[c + 0x09] & 0x0000FFFF) << 0x03);
		ds[t + 0x10] = (sr[c + 0x09] >> 0x10) | ((sr[c + 0x0A] & 0x00000007) << 0x10);
		ds[t + 0x11] = (sr[c + 0x0A] >> 0x03) & 0x0007FFFF;
		ds[t + 0x12] = (sr[c + 0x0A] >> 0x16) | ((sr[c + 0x0B] & 0x000001FF) << 0x0A);
		ds[t + 0x13] = (sr[c + 0x0B] >> 0x09) & 0x0007FFFF;
		ds[t + 0x14] = (sr[c + 0x0B] >> 0x1C) | ((sr[c + 0x0C] & 0x00007FFF) << 0x04);
		ds[t + 0x15] = (sr[c + 0x0C] >> 0x0F) | ((sr[c + 0x0D] & 0x00000003) << 0x11);
		ds[t + 0x16] = (sr[c + 0x0D] >> 0x02) & 0x0007FFFF;
		ds[t + 0x17] = (sr[c + 0x0D] >> 0x15) | ((sr[c + 0x0E] & 0x000000FF) << 0x0B);
		ds[t + 0x18] = (sr[c + 0x0E] >> 0x08) & 0x0007FFFF;
		ds[t + 0x19] = (sr[c + 0x0E] >> 0x1B) | ((sr[c + 0x0F] & 0x00003FFF) << 0x05);
		ds[t + 0x1A] = (sr[c + 0x0F] >> 0x0E) | ((sr[c + 0x10] & 0x00000001) << 0x12);
		ds[t + 0x1B] = (sr[c + 0x10] >> 0x01) & 0x0007FFFF;
		ds[t + 0x1C] = (sr[c + 0x10] >> 0x14) | ((sr[c + 0x11] & 0x0000007F) << 0x0C);
		ds[t + 0x1D] = (sr[c + 0x11] >> 0x07) & 0x0007FFFF;
		ds[t + 0x1E] = (sr[c + 0x11] >> 0x1A) | ((sr[c + 0x12] & 0x00001FFF) << 0x06);
		ds[t + 0x1F] = (sr[c + 0x12] >> 0x0D);
	}

	static inline void unpack20(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x000FFFFF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x14) | ((sr[c + 0x01] & 0x000000FF) << 0x0C);
		ds[t + 0x02] = (sr[c + 0x01] >> 0x08) & 0x000FFFFF;
		ds[t + 0x03] = (sr[c + 0x01] >> 0x1C) | ((sr[c + 0x02] & 0x0000FFFF) << 0x04);
		ds[t + 0x04] = (sr[c + 0x02] >> 0x10) | ((sr[c + 0x03] & 0x0000000F) << 0x10);
		ds[t + 0x05] = (sr[c + 0x03] >> 0x04) & 0x000FFFFF;
		ds[t + 0x06] = (sr[c + 0x03] >> 0x18) | ((sr[c + 0x04] & 0x00000FFF) << 0x08);
		ds[t + 0x07] = (sr[c + 0x04] >> 0x0C);
		ds[t + 0x08] = (sr[c + 0x05] >> 0x00) & 0x000FFFFF;
		ds[t + 0x09] = (sr[c + 0x05] >> 0x14) | ((sr[c + 0x06] & 0x000000FF) << 0x0C);
		ds[t + 0x0A] = (sr[c + 0x06] >> 0x08) & 0x000FFFFF;
		ds[t + 0x0B] = (sr[c + 0x06] >> 0x1C) | ((sr[c + 0x07] & 0x0000FFFF) << 0x04);
		ds[t + 0x0C] = (sr[c + 0x07] >> 0x10) | ((sr[c + 0x08] & 0x0000000F) << 0x10);
		ds[t + 0x0D] = (sr[c + 0x08] >> 0x04) & 0x000FFFFF;
		ds[t + 0x0E] = (sr[c + 0x08] >> 0x18) | ((sr[c + 0x09] & 0x00000FFF) << 0x08);
		ds[t + 0x0F] = (sr[c + 0x09] >> 0x0C);
		ds[t + 0x10] = (sr[c + 0x0A] >> 0x00) & 0x000FFFFF;
		ds[t + 0x11] = (sr[c + 0x0A] >> 0x14) | ((sr[c + 0x0B] & 0x000000FF) << 0x0C);
		ds[t + 0x12] = (sr[c + 0x0B] >> 0x08) & 0x000FFFFF;
		ds[t + 0x13] = (sr[c + 0x0B] >> 0x1C) | ((sr[c + 0x0C] & 0x0000FFFF) << 0x04);
		ds[t + 0x14] = (sr[c + 0x0C] >> 0x10) | ((sr[c + 0x0D] & 0x0000000F) << 0x10);
		ds[t + 0x15] = (sr[c + 0x0D] >> 0x04) & 0x000FFFFF;
		ds[t + 0x16] = (sr[c + 0x0D] >> 0x18) | ((sr[c + 0x0E] & 0x00000FFF) << 0x08);
		ds[t + 0x17] = (sr[c + 0x0E] >> 0x0C);
		ds[t + 0x18] = (sr[c + 0x0F] >> 0x00) & 0x000FFFFF;
		ds[t + 0x19] = (sr[c + 0x0F] >> 0x14) | ((sr[c + 0x10] & 0x000000FF) << 0x0C);
		ds[t + 0x1A] = (sr[c + 0x10] >> 0x08) & 0x000FFFFF;
		ds[t + 0x1B] = (sr[c + 0x10] >> 0x1C) | ((sr[c + 0x11] & 0x0000FFFF) << 0x04);
		ds[t + 0x1C] = (sr[c + 0x11] >> 0x10) | ((sr[c + 0x12] & 0x0000000F) << 0x10);
		ds[t + 0x1D] = (sr[c + 0x12] >> 0x04) & 0x000FFFFF;
		ds[t + 0x1E] = (sr[c + 0x12] >> 0x18) | ((sr[c + 0x13] & 0x00000FFF) << 0x08);
		ds[t + 0x1F] = (sr[c + 0x13] >> 0x0C);
	}

	static inline void unpack21(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x001FFFFF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x15) | ((sr[c + 0x01] & 0x000003FF) << 0x0B);
		ds[t + 0x02] = (sr[c + 0x01] >> 0x0A) & 0x001FFFFF;
		ds[t + 0x03] = (sr[c + 0x01] >> 0x1F) | ((sr[c + 0x02] & 0x000FFFFF) << 0x01);
		ds[t + 0x04] = (sr[c + 0x02] >> 0x14) | ((sr[c + 0x03] & 0x000001FF) << 0x0C);
		ds[t + 0x05] = (sr[c + 0x03] >> 0x09) & 0x001FFFFF;
		ds[t + 0x06] = (sr[c + 0x03] >> 0x1E) | ((sr[c + 0x04] & 0x0007FFFF) << 0x02);
		ds[t + 0x07] = (sr[c + 0x04] >> 0x13) | ((sr[c + 0x05] & 0x000000FF) << 0x0D);
		ds[t + 0x08] = (sr[c + 0x05] >> 0x08) & 0x001FFFFF;
		ds[t + 0x09] = (sr[c + 0x05] >> 0x1D) | ((sr[c + 0x06] & 0x0003FFFF) << 0x03);
		ds[t + 0x0A] = (sr[c + 0x06] >> 0x12) | ((sr[c + 0x07] & 0x0000007F) << 0x0E);
		ds[t + 0x0B] = (sr[c + 0x07] >> 0x07) & 0x001FFFFF;
		ds[t + 0x0C] = (sr[c + 0x07] >> 0x1C) | ((sr[c + 0x08] & 0x0001FFFF) << 0x04);
		ds[t + 0x0D] = (sr[c + 0x08] >> 0x11) | ((sr[c + 0x09] & 0x0000003F) << 0x0F);
		ds[t + 0x0E] = (sr[c + 0x09] >> 0x06) & 0x001FFFFF;
		ds[t + 0x0F] = (sr[c + 0x09] >> 0x1B) | ((sr[c + 0x0A] & 0x0000FFFF) << 0x05);
		ds[t + 0x10] = (sr[c + 0x0A] >> 0x10) | ((sr[c + 0x0B] & 0x0000001F) << 0x10);
		ds[t + 0x11] = (sr[c + 0x0B] >> 0x05) & 0x001FFFFF;
		ds[t + 0x12] = (sr[c + 0x0B] >> 0x1A) | ((sr[c + 0x0C] & 0x00007FFF) << 0x06);
		ds[t + 0x13] = (sr[c + 0x0C] >> 0x0F) | ((sr[c + 0x0D] & 0x0000000F) << 0x11);
		ds[t + 0x14] = (sr[c + 0x0D] >> 0x04) & 0x001FFFFF;
		ds[t + 0x15] = (sr[c + 0x0D] >> 0x19) | ((sr[c + 0x0E] & 0x00003FFF) << 0x07);
		ds[t + 0x16] = (sr[c + 0x0E] >> 0x0E) | ((sr[c + 0x0F] & 0x00000007) << 0x12);
		ds[t + 0x17] = (sr[c + 0x0F] >> 0x03) & 0x001FFFFF;
		ds[t + 0x18] = (sr[c + 0x0F] >> 0x18) | ((sr[c + 0x10] & 0x00001FFF) << 0x08);
		ds[t + 0x19] = (sr[c + 0x10] >> 0x0D) | ((sr[c + 0x11] & 0x00000003) << 0x13);
		ds[t + 0x1A] = (sr[c + 0x11] >> 0x02) & 0x001FFFFF;
		ds[t + 0x1B] = (sr[c + 0x11] >> 0x17) | ((sr[c + 0x12] & 0x00000FFF) << 0x09);
		ds[t + 0x1C] = (sr[c + 0x12] >> 0x0C) | ((sr[c + 0x13] & 0x00000001) << 0x14);
		ds[t + 0x1D] = (sr[c + 0x13] >> 0x01) & 0x001FFFFF;
		ds[t + 0x1E] = (sr[c + 0x13] >> 0x16) | ((sr[c + 0x14] & 0x000007FF) << 0x0A);
		ds[t + 0x1F] = (sr[c + 0x14] >> 0x0B);
	}

	static inline void unpack22(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x003FFFFF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x16) | ((sr[c + 0x01] & 0x00000FFF) << 0x0A);
		ds[t + 0x02] = (sr[c + 0x01] >> 0x0C) | ((sr[c + 0x02] & 0x00000003) << 0x14);
		ds[t + 0x03] = (sr[c + 0x02] >> 0x02) & 0x003FFFFF;
		ds[t + 0x04] = (sr[c + 0x02] >> 0x18) | ((sr[c + 0x03] & 0x00003FFF) << 0x08);
		ds[t + 0x05] = (sr[c + 0x03] >> 0x0E) | ((sr[c + 0x04] & 0x0000000F) << 0x12);
		ds[t + 0x06] = (sr[c + 0x04] >> 0x04) & 0x003FFFFF;
		ds[t + 0x07] = (sr[c + 0x04] >> 0x1A) | ((sr[c + 0x05] & 0x0000FFFF) << 0x06);
		ds[t + 0x08] = (sr[c + 0x05] >> 0x10) | ((sr[c + 0x06] & 0x0000003F) << 0x10);
		ds[t + 0x09] = (sr[c + 0x06] >> 0x06) & 0x003FFFFF;
		ds[t + 0x0A] = (sr[c + 0x06] >> 0x1C) | ((sr[c + 0x07] & 0x0003FFFF) << 0x04);
		ds[t + 0x0B] = (sr[c + 0x07] >> 0x12) | ((sr[c + 0x08] & 0x000000FF) << 0x0E);
		ds[t + 0x0C] = (sr[c + 0x08] >> 0x08) & 0x003FFFFF;
		ds[t + 0x0D] = (sr[c + 0x08] >> 0x1E) | ((sr[c + 0x09] & 0x000FFFFF) << 0x02);
		ds[t + 0x0E] = (sr[c + 0x09] >> 0x14) | ((sr[c + 0x0A] & 0x000003FF) << 0x0C);
		ds[t + 0x0F] = (sr[c + 0x0A] >> 0x0A);
		ds[t + 0x10] = (sr[c + 0x0B] >> 0x00) & 0x003FFFFF;
		ds[t + 0x11] = (sr[c + 0x0B] >> 0x16) | ((sr[c + 0x0C] & 0x00000FFF) << 0x0A);
		ds[t + 0x12] = (sr[c + 0x0C] >> 0x0C) | ((sr[c + 0x0D] & 0x00000003) << 0x14);
		ds[t + 0x13] = (sr[c + 0x0D] >> 0x02) & 0x003FFFFF;
		ds[t + 0x14] = (sr[c + 0x0D] >> 0x18) | ((sr[c + 0x0E] & 0x00003FFF) << 0x08);
		ds[t + 0x15] = (sr[c + 0x0E] >> 0x0E) | ((sr[c + 0x0F] & 0x0000000F) << 0x12);
		ds[t + 0x16] = (sr[c + 0x0F] >> 0x04) & 0x003FFFFF;
		ds[t + 0x17] = (sr[c + 0x0F] >> 0x1A) | ((sr[c + 0x10] & 0x0000FFFF) << 0x06);
		ds[t + 0x18] = (sr[c + 0x10] >> 0x10) | ((sr[c + 0x11] & 0x0000003F) << 0x10);
		ds[t + 0x19] = (sr[c + 0x11] >> 0x06) & 0x003FFFFF;
		ds[t + 0x1A] = (sr[c + 0x11] >> 0x1C) | ((sr[c + 0x12] & 0x0003FFFF) << 0x04);
		ds[t + 0x1B] = (sr[c + 0x12] >> 0x12) | ((sr[c + 0x13] & 0x000000FF) << 0x0E);
		ds[t + 0x1C] = (sr[c + 0x13] >> 0x08) & 0x003FFFFF;
		ds[t + 0x1D] = (sr[c + 0x13] >> 0x1E) | ((sr[c + 0x14] & 0x000FFFFF) << 0x02);
		ds[t + 0x1E] = (sr[c + 0x14] >> 0x14) | ((sr[c + 0x15] & 0x000003FF) << 0x0C);
		ds[t + 0x1F] = (sr[c + 0x15] >> 0x0A);
	}

	static inline void unpack23(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x007FFFFF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x17) | ((sr[c + 0x01] & 0x00003FFF) << 0x09);
		ds[t + 0x02] = (sr[c + 0x01] >> 0x0E) | ((sr[c + 0x02] & 0x0000001F) << 0x12);
		ds[t + 0x03] = (sr[c + 0x02] >> 0x05) & 0x007FFFFF;
		ds[t + 0x04] = (sr[c + 0x02] >> 0x1C) | ((sr[c + 0x03] & 0x0007FFFF) << 0x04);
		ds[t + 0x05] = (sr[c + 0x03] >> 0x13) | ((sr[c + 0x04] & 0x000003FF) << 0x0D);
		ds[t + 0x06] = (sr[c + 0x04] >> 0x0A) | ((sr[c + 0x05] & 0x00000001) << 0x16);
		ds[t + 0x07] = (sr[c + 0x05] >> 0x01) & 0x007FFFFF;
		ds[t + 0x08] = (sr[c + 0x05] >> 0x18) | ((sr[c + 0x06] & 0x00007FFF) << 0x08);
		ds[t + 0x09] = (sr[c + 0x06] >> 0x0F) | ((sr[c + 0x07] & 0x0000003F) << 0x11);
		ds[t + 0x0A] = (sr[c + 0x07] >> 0x06) & 0x007FFFFF;
		ds[t + 0x0B] = (sr[c + 0x07] >> 0x1D) | ((sr[c + 0x08] & 0x000FFFFF) << 0x03);
		ds[t + 0x0C] = (sr[c + 0x08] >> 0x14) | ((sr[c + 0x09] & 0x000007FF) << 0x0C);
		ds[t + 0x0D] = (sr[c + 0x09] >> 0x0B) | ((sr[c + 0x0A] & 0x00000003) << 0x15);
		ds[t + 0x0E] = (sr[c + 0x0A] >> 0x02) & 0x007FFFFF;
		ds[t + 0x0F] = (sr[c + 0x0A] >> 0x19) | ((sr[c + 0x0B] & 0x0000FFFF) << 0x07);
		ds[t + 0x10] = (sr[c + 0x0B] >> 0x10) | ((sr[c + 0x0C] & 0x0000007F) << 0x10);
		ds[t + 0x11] = (sr[c + 0x0C] >> 0x07) & 0x007FFFFF;
		ds[t + 0x12] = (sr[c + 0x0C] >> 0x1E) | ((sr[c + 0x0D] & 0x001FFFFF) << 0x02);
		ds[t + 0x13] = (sr[c + 0x0D] >> 0x15) | ((sr[c + 0x0E] & 0x00000FFF) << 0x0B);
		ds[t + 0x14] = (sr[c + 0x0E] >> 0x0C) | ((sr[c + 0x0F] & 0x00000007) << 0x14);
		ds[t + 0x15] = (sr[c + 0x0F] >> 0x03) & 0x007FFFFF;
		ds[t + 0x16] = (sr[c + 0x0F] >> 0x1A) | ((sr[c + 0x10] & 0x0001FFFF) << 0x06);
		ds[t + 0x17] = (sr[c + 0x10] >> 0x11) | ((sr[c + 0x11] & 0x000000FF) << 0x0F);
		ds[t + 0x18] = (sr[c + 0x11] >> 0x08) & 0x007FFFFF;
		ds[t + 0x19] = (sr[c + 0x11] >> 0x1F) | ((sr[c + 0x12] & 0x003FFFFF) << 0x01);
		ds[t + 0x1A] = (sr[c + 0x12] >> 0x16) | ((sr[c + 0x13] & 0x00001FFF) << 0x0A);
		ds[t + 0x1B] = (sr[c + 0x13] >> 0x0D) | ((sr[c + 0x14] & 0x0000000F) << 0x13);
		ds[t + 0x1C] = (sr[c + 0x14] >> 0x04) & 0x007FFFFF;
		ds[t + 0x1D] = (sr[c + 0x14] >> 0x1B) | ((sr[c + 0x15] & 0x0003FFFF) << 0x05);
		ds[t + 0x1E] = (sr[c + 0x15] >> 0x12) | ((sr[c + 0x16] & 0x000001FF) << 0x0E);
		ds[t + 0x1F] = (sr[c + 0x16] >> 0x09);
	}

	static inline void unpack24(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x00FFFFFF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x18) | ((sr[c + 0x01] & 0x0000FFFF) << 0x08);
		ds[t + 0x02] = (sr[c + 0x01] >> 0x10) | ((sr[c + 0x02] & 0x000000FF) << 0x10);
		ds[t + 0x03] = (sr[c + 0x02] >> 0x08);
		ds[t + 0x04] = (sr[c + 0x03] >> 0x00) & 0x00FFFFFF;
		ds[t + 0x05] = (sr[c + 0x03] >> 0x18) | ((sr[c + 0x04] & 0x0000FFFF) << 0x08);
		ds[t + 0x06] = (sr[c + 0x04] >> 0x10) | ((sr[c + 0x05] & 0x000000FF) << 0x10);
		ds[t + 0x07] = (sr[c + 0x05] >> 0x08);
		ds[t + 0x08] = (sr[c + 0x06] >> 0x00) & 0x00FFFFFF;
		ds[t + 0x09] = (sr[c + 0x06] >> 0x18) | ((sr[c + 0x07] & 0x0000FFFF) << 0x08);
		ds[t + 0x0A] = (sr[c + 0x07] >> 0x10) | ((sr[c + 0x08] & 0x000000FF) << 0x10);
		ds[t + 0x0B] = (sr[c + 0x08] >> 0x08);
		ds[t + 0x0C] = (sr[c + 0x09] >> 0x00) & 0x00FFFFFF;
		ds[t + 0x0D] = (sr[c + 0x09] >> 0x18) | ((sr[c + 0x0A] & 0x0000FFFF) << 0x08);
		ds[t + 0x0E] = (sr[c + 0x0A] >> 0x10) | ((sr[c + 0x0B] & 0x000000FF) << 0x10);
		ds[t + 0x0F] = (sr[c + 0x0B] >> 0x08);
		ds[t + 0x10] = (sr[c + 0x0C] >> 0x00) & 0x00FFFFFF;
		ds[t + 0x11] = (sr[c + 0x0C] >> 0x18) | ((sr[c + 0x0D] & 0x0000FFFF) << 0x08);
		ds[t + 0x12] = (sr[c + 0x0D] >> 0x10) | ((sr[c + 0x0E] & 0x000000FF) << 0x10);
		ds[t + 0x13] = (sr[c + 0x0E] >> 0x08);
		ds[t + 0x14] = (sr[c + 0x0F] >> 0x00) & 0x00FFFFFF;
		ds[t + 0x15] = (sr[c + 0x0F] >> 0x18) | ((sr[c + 0x10] & 0x0000FFFF) << 0x08);
		ds[t + 0x16] = (sr[c + 0x10] >> 0x10) | ((sr[c + 0x11] & 0x000000FF) << 0x10);
		ds[t + 0x17] = (sr[c + 0x11] >> 0x08);
		ds[t + 0x18] = (sr[c + 0x12] >> 0x00) & 0x00FFFFFF;
		ds[t + 0x19] = (sr[c + 0x12] >> 0x18) | ((sr[c + 0x13] & 0x0000FFFF) << 0x08);
		ds[t + 0x1A] = (sr[c + 0x13] >> 0x10) | ((sr[c + 0x14] & 0x000000FF) << 0x10);
		ds[t + 0x1B] = (sr[c + 0x14] >> 0x08);
		ds[t + 0x1C] = (sr[c + 0x15] >> 0x00) & 0x00FFFFFF;
		ds[t + 0x1D] = (sr[c + 0x15] >> 0x18) | ((sr[c + 0x16] & 0x0000FFFF) << 0x08);
		ds[t + 0x1E] = (sr[c + 0x16] >> 0x10) | ((sr[c + 0x17] & 0x000000FF) << 0x10);
		ds[t + 0x1F] = (sr[c + 0x17] >> 0x08);
	}

	static inline void unpack25(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x01FFFFFF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x19) | ((sr[c + 0x01] & 0x0003FFFF) << 0x07);
		ds[t + 0x02] = (sr[c + 0x01] >> 0x12) | ((sr[c + 0x02] & 0x000007FF) << 0x0E);
		ds[t + 0x03] = (sr[c + 0x02] >> 0x0B) | ((sr[c + 0x03] & 0x0000000F) << 0x15);
		ds[t + 0x04] = (sr[c + 0x03] >> 0x04) & 0x01FFFFFF;
		ds[t + 0x05] = (sr[c + 0x03] >> 0x1D) | ((sr[c + 0x04] & 0x003FFFFF) << 0x03);
		ds[t + 0x06] = (sr[c + 0x04] >> 0x16) | ((sr[c + 0x05] & 0x00007FFF) << 0x0A);
		ds[t + 0x07] = (sr[c + 0x05] >> 0x0F) | ((sr[c + 0x06] & 0x000000FF) << 0x11);
		ds[t + 0x08] = (sr[c + 0x06] >> 0x08) | ((sr[c + 0x07] & 0x00000001) << 0x18);
		ds[t + 0x09] = (sr[c + 0x07] >> 0x01) & 0x01FFFFFF;
		ds[t + 0x0A] = (sr[c + 0x07] >> 0x1A) | ((sr[c + 0x08] & 0x0007FFFF) << 0x06);
		ds[t + 0x0B] = (sr[c + 0x08] >> 0x13) | ((sr[c + 0x09] & 0x00000FFF) << 0x0D);
		ds[t + 0x0C] = (sr[c + 0x09] >> 0x0C) | ((sr[c + 0x0A] & 0x0000001F) << 0x14);
		ds[t + 0x0D] = (sr[c + 0x0A] >> 0x05) & 0x01FFFFFF;
		ds[t + 0x0E] = (sr[c + 0x0A] >> 0x1E) | ((sr[c + 0x0B] & 0x007FFFFF) << 0x02);
		ds[t + 0x0F] = (sr[c + 0x0B] >> 0x17) | ((sr[c + 0x0C] & 0x0000FFFF) << 0x09);
		ds[t + 0x10] = (sr[c + 0x0C] >> 0x10) | ((sr[c + 0x0D] & 0x000001FF) << 0x10);
		ds[t + 0x11] = (sr[c + 0x0D] >> 0x09) | ((sr[c + 0x0E] & 0x00000003) << 0x17);
		ds[t + 0x12] = (sr[c + 0x0E] >> 0x02) & 0x01FFFFFF;
		ds[t + 0x13] = (sr[c + 0x0E] >> 0x1B) | ((sr[c + 0x0F] & 0x000FFFFF) << 0x05);
		ds[t + 0x14] = (sr[c + 0x0F] >> 0x14) | ((sr[c + 0x10] & 0x00001FFF) << 0x0C);
		ds[t + 0x15] = (sr[c + 0x10] >> 0x0D) | ((sr[c + 0x11] & 0x0000003F) << 0x13);
		ds[t + 0x16] = (sr[c + 0x11] >> 0x06) & 0x01FFFFFF;
		ds[t + 0x17] = (sr[c + 0x11] >> 0x1F) | ((sr[c + 0x12] & 0x00FFFFFF) << 0x01);
		ds[t + 0x18] = (sr[c + 0x12] >> 0x18) | ((sr[c + 0x13] & 0x0001FFFF) << 0x08);
		ds[t + 0x19] = (sr[c + 0x13] >> 0x11) | ((sr[c + 0x14] & 0x000003FF) << 0x0F);
		ds[t + 0x1A] = (sr[c + 0x14] >> 0x0A) | ((sr[c + 0x15] & 0x00000007) << 0x16);
		ds[t + 0x1B] = (sr[c + 0x15] >> 0x03) & 0x01FFFFFF;
		ds[t + 0x1C] = (sr[c + 0x15] >> 0x1C) | ((sr[c + 0x16] & 0x001FFFFF) << 0x04);
		ds[t + 0x1D] = (sr[c + 0x16] >> 0x15) | ((sr[c + 0x17] & 0x00003FFF) << 0x0B);
		ds[t + 0x1E] = (sr[c + 0x17] >> 0x0E) | ((sr[c + 0x18] & 0x0000007F) << 0x12);
		ds[t + 0x1F] = (sr[c + 0x18] >> 0x07);
	}

	static inline void unpack26(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x03FFFFFF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x1A) | ((sr[c + 0x01] & 0x000FFFFF) << 0x06);
		ds[t + 0x02] = (sr[c + 0x01] >> 0x14) | ((sr[c + 0x02] & 0x00003FFF) << 0x0C);
		ds[t + 0x03] = (sr[c + 0x02] >> 0x0E) | ((sr[c + 0x03] & 0x000000FF) << 0x12);
		ds[t + 0x04] = (sr[c + 0x03] >> 0x08) | ((sr[c + 0x04] & 0x00000003) << 0x18);
		ds[t + 0x05] = (sr[c + 0x04] >> 0x02) & 0x03FFFFFF;
		ds[t + 0x06] = (sr[c + 0x04] >> 0x1C) | ((sr[c + 0x05] & 0x003FFFFF) << 0x04);
		ds[t + 0x07] = (sr[c + 0x05] >> 0x16) | ((sr[c + 0x06] & 0x0000FFFF) << 0x0A);
		ds[t + 0x08] = (sr[c + 0x06] >> 0x10) | ((sr[c + 0x07] & 0x000003FF) << 0x10);
		ds[t + 0x09] = (sr[c + 0x07] >> 0x0A) | ((sr[c + 0x08] & 0x0000000F) << 0x16);
		ds[t + 0x0A] = (sr[c + 0x08] >> 0x04) & 0x03FFFFFF;
		ds[t + 0x0B] = (sr[c + 0x08] >> 0x1E) | ((sr[c + 0x09] & 0x00FFFFFF) << 0x02);
		ds[t + 0x0C] = (sr[c + 0x09] >> 0x18) | ((sr[c + 0x0A] & 0x0003FFFF) << 0x08);
		ds[t + 0x0D] = (sr[c + 0x0A] >> 0x12) | ((sr[c + 0x0B] & 0x00000FFF) << 0x0E);
		ds[t + 0x0E] = (sr[c + 0x0B] >> 0x0C) | ((sr[c + 0x0C] & 0x0000003F) << 0x14);
		ds[t + 0x0F] = (sr[c + 0x0C] >> 0x06);
		ds[t + 0x10] = (sr[c + 0x0D] >> 0x00) & 0x03FFFFFF;
		ds[t + 0x11] = (sr[c + 0x0D] >> 0x1A) | ((sr[c + 0x0E] & 0x000FFFFF) << 0x06);
		ds[t + 0x12] = (sr[c + 0x0E] >> 0x14) | ((sr[c + 0x0F] & 0x00003FFF) << 0x0C);
		ds[t + 0x13] = (sr[c + 0x0F] >> 0x0E) | ((sr[c + 0x10] & 0x000000FF) << 0x12);
		ds[t + 0x14] = (sr[c + 0x10] >> 0x08) | ((sr[c + 0x11] & 0x00000003) << 0x18);
		ds[t + 0x15] = (sr[c + 0x11] >> 0x02) & 0x03FFFFFF;
		ds[t + 0x16] = (sr[c + 0x11] >> 0x1C) | ((sr[c + 0x12] & 0x003FFFFF) << 0x04);
		ds[t + 0x17] = (sr[c + 0x12] >> 0x16) | ((sr[c + 0x13] & 0x0000FFFF) << 0x0A);
		ds[t + 0x18] = (sr[c + 0x13] >> 0x10) | ((sr[c + 0x14] & 0x000003FF) << 0x10);
		ds[t + 0x19] = (sr[c + 0x14] >> 0x0A) | ((sr[c + 0x15] & 0x0000000F) << 0x16);
		ds[t + 0x1A] = (sr[c + 0x15] >> 0x04) & 0x03FFFFFF;
		ds[t + 0x1B] = (sr[c + 0x15] >> 0x1E) | ((sr[c + 0x16] & 0x00FFFFFF) << 0x02);
		ds[t + 0x1C] = (sr[c + 0x16] >> 0x18) | ((sr[c + 0x17] & 0x0003FFFF) << 0x08);
		ds[t + 0x1D] = (sr[c + 0x17] >> 0x12) | ((sr[c + 0x18] & 0x00000FFF) << 0x0E);
		ds[t + 0x1E] = (sr[c + 0x18] >> 0x0C) | ((sr[c + 0x19] & 0x0000003F) << 0x14);
		ds[t + 0x1F] = (sr[c + 0x19] >> 0x06);
	}

	static inline void unpack27(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x07FFFFFF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x1B) | ((sr[c + 0x01] & 0x003FFFFF) << 0x05);
		ds[t + 0x02] = (sr[c + 0x01] >> 0x16) | ((sr[c + 0x02] & 0x0001FFFF) << 0x0A);
		ds[t + 0x03] = (sr[c + 0x02] >> 0x11) | ((sr[c + 0x03] & 0x00000FFF) << 0x0F);
		ds[t + 0x04] = (sr[c + 0x03] >> 0x0C) | ((sr[c + 0x04] & 0x0000007F) << 0x14);
		ds[t + 0x05] = (sr[c + 0x04] >> 0x07) | ((sr[c + 0x05] & 0x00000003) << 0x19);
		ds[t + 0x06] = (sr[c + 0x05] >> 0x02) & 0x07FFFFFF;
		ds[t + 0x07] = (sr[c + 0x05] >> 0x1D) | ((sr[c + 0x06] & 0x00FFFFFF) << 0x03);
		ds[t + 0x08] = (sr[c + 0x06] >> 0x18) | ((sr[c + 0x07] & 0x0007FFFF) << 0x08);
		ds[t + 0x09] = (sr[c + 0x07] >> 0x13) | ((sr[c + 0x08] & 0x00003FFF) << 0x0D);
		ds[t + 0x0A] = (sr[c + 0x08] >> 0x0E) | ((sr[c + 0x09] & 0x000001FF) << 0x12);
		ds[t + 0x0B] = (sr[c + 0x09] >> 0x09) | ((sr[c + 0x0A] & 0x0000000F) << 0x17);
		ds[t + 0x0C] = (sr[c + 0x0A] >> 0x04) & 0x07FFFFFF;
		ds[t + 0x0D] = (sr[c + 0x0A] >> 0x1F) | ((sr[c + 0x0B] & 0x03FFFFFF) << 0x01);
		ds[t + 0x0E] = (sr[c + 0x0B] >> 0x1A) | ((sr[c + 0x0C] & 0x001FFFFF) << 0x06);
		ds[t + 0x0F] = (sr[c + 0x0C] >> 0x15) | ((sr[c + 0x0D] & 0x0000FFFF) << 0x0B);
		ds[t + 0x10] = (sr[c + 0x0D] >> 0x10) | ((sr[c + 0x0E] & 0x000007FF) << 0x10);
		ds[t + 0x11] = (sr[c + 0x0E] >> 0x0B) | ((sr[c + 0x0F] & 0x0000003F) << 0x15);
		ds[t + 0x12] = (sr[c + 0x0F] >> 0x06) | ((sr[c + 0x10] & 0x00000001) << 0x1A);
		ds[t + 0x13] = (sr[c + 0x10] >> 0x01) & 0x07FFFFFF;
		ds[t + 0x14] = (sr[c + 0x10] >> 0x1C) | ((sr[c + 0x11] & 0x007FFFFF) << 0x04);
		ds[t + 0x15] = (sr[c + 0x11] >> 0x17) | ((sr[c + 0x12] & 0x0003FFFF) << 0x09);
		ds[t + 0x16] = (sr[c + 0x12] >> 0x12) | ((sr[c + 0x13] & 0x00001FFF) << 0x0E);
		ds[t + 0x17] = (sr[c + 0x13] >> 0x0D) | ((sr[c + 0x14] & 0x000000FF) << 0x13);
		ds[t + 0x18] = (sr[c + 0x14] >> 0x08) | ((sr[c + 0x15] & 0x00000007) << 0x18);
		ds[t + 0x19] = (sr[c + 0x15] >> 0x03) & 0x07FFFFFF;
		ds[t + 0x1A] = (sr[c + 0x15] >> 0x1E) | ((sr[c + 0x16] & 0x01FFFFFF) << 0x02);
		ds[t + 0x1B] = (sr[c + 0x16] >> 0x19) | ((sr[c + 0x17] & 0x000FFFFF) << 0x07);
		ds[t + 0x1C] = (sr[c + 0x17] >> 0x14) | ((sr[c + 0x18] & 0x00007FFF) << 0x0C);
		ds[t + 0x1D] = (sr[c + 0x18] >> 0x0F) | ((sr[c + 0x19] & 0x000003FF) << 0x11);
		ds[t + 0x1E] = (sr[c + 0x19] >> 0x0A) | ((sr[c + 0x1A] & 0x0000001F) << 0x16);
		ds[t + 0x1F] = (sr[c + 0x1A] >> 0x05);
	}

	static inline void unpack28(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x0FFFFFFF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x1C) | ((sr[c + 0x01] & 0x00FFFFFF) << 0x04);
		ds[t + 0x02] = (sr[c + 0x01] >> 0x18) | ((sr[c + 0x02] & 0x000FFFFF) << 0x08);
		ds[t + 0x03] = (sr[c + 0x02] >> 0x14) | ((sr[c + 0x03] & 0x0000FFFF) << 0x0C);
		ds[t + 0x04] = (sr[c + 0x03] >> 0x10) | ((sr[c + 0x04] & 0x00000FFF) << 0x10);
		ds[t + 0x05] = (sr[c + 0x04] >> 0x0C) | ((sr[c + 0x05] & 0x000000FF) << 0x14);
		ds[t + 0x06] = (sr[c + 0x05] >> 0x08) | ((sr[c + 0x06] & 0x0000000F) << 0x18);
		ds[t + 0x07] = (sr[c + 0x06] >> 0x04);
		ds[t + 0x08] = (sr[c + 0x07] >> 0x00) & 0x0FFFFFFF;
		ds[t + 0x09] = (sr[c + 0x07] >> 0x1C) | ((sr[c + 0x08] & 0x00FFFFFF) << 0x04);
		ds[t + 0x0A] = (sr[c + 0x08] >> 0x18) | ((sr[c + 0x09] & 0x000FFFFF) << 0x08);
		ds[t + 0x0B] = (sr[c + 0x09] >> 0x14) | ((sr[c + 0x0A] & 0x0000FFFF) << 0x0C);
		ds[t + 0x0C] = (sr[c + 0x0A] >> 0x10) | ((sr[c + 0x0B] & 0x00000FFF) << 0x10);
		ds[t + 0x0D] = (sr[c + 0x0B] >> 0x0C) | ((sr[c + 0x0C] & 0x000000FF) << 0x14);
		ds[t + 0x0E] = (sr[c + 0x0C] >> 0x08) | ((sr[c + 0x0D] & 0x0000000F) << 0x18);
		ds[t + 0x0F] = (sr[c + 0x0D] >> 0x04);
		ds[t + 0x10] = (sr[c + 0x0E] >> 0x00) & 0x0FFFFFFF;
		ds[t + 0x11] = (sr[c + 0x0E] >> 0x1C) | ((sr[c + 0x0F] & 0x00FFFFFF) << 0x04);
		ds[t + 0x12] = (sr[c + 0x0F] >> 0x18) | ((sr[c + 0x10] & 0x000FFFFF) << 0x08);
		ds[t + 0x13] = (sr[c + 0x10] >> 0x14) | ((sr[c + 0x11] & 0x0000FFFF) << 0x0C);
		ds[t + 0x14] = (sr[c + 0x11] >> 0x10) | ((sr[c + 0x12] & 0x00000FFF) << 0x10);
		ds[t + 0x15] = (sr[c + 0x12] >> 0x0C) | ((sr[c + 0x13] & 0x000000FF) << 0x14);
		ds[t + 0x16] = (sr[c + 0x13] >> 0x08) | ((sr[c + 0x14] & 0x0000000F) << 0x18);
		ds[t + 0x17] = (sr[c + 0x14] >> 0x04);
		ds[t + 0x18] = (sr[c + 0x15] >> 0x00) & 0x0FFFFFFF;
		ds[t + 0x19] = (sr[c + 0x15] >> 0x1C) | ((sr[c + 0x16] & 0x00FFFFFF) << 0x04);
		ds[t + 0x1A] = (sr[c + 0x16] >> 0x18) | ((sr[c + 0x17] & 0x000FFFFF) << 0x08);
		ds[t + 0x1B] = (sr[c + 0x17] >> 0x14) | ((sr[c + 0x18] & 0x0000FFFF) << 0x0C);
		ds[t + 0x1C] = (sr[c + 0x18] >> 0x10) | ((sr[c + 0x19] & 0x00000FFF) << 0x10);
		ds[t + 0x1D] = (sr[c + 0x19] >> 0x0C) | ((sr[c + 0x1A] & 0x000000FF) << 0x14);
		ds[t + 0x1E] = (sr[c + 0x1A] >> 0x08) | ((sr[c + 0x1B] & 0x0000000F) << 0x18);
		ds[t + 0x1F] = (sr[c + 0x1B] >> 0x04);
	}

	static inline void unpack29(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x1FFFFFFF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x1D) | ((sr[c + 0x01] & 0x03FFFFFF) << 0x03);
		ds[t + 0x02] = (sr[c + 0x01] >> 0x1A) | ((sr[c + 0x02] & 0x007FFFFF) << 0x06);
		ds[t + 0x03] = (sr[c + 0x02] >> 0x17) | ((sr[c + 0x03] & 0x000FFFFF) << 0x09);
		ds[t + 0x04] = (sr[c + 0x03] >> 0x14) | ((sr[c + 0x04] & 0x0001FFFF) << 0x0C);
		ds[t + 0x05] = (sr[c + 0x04] >> 0x11) | ((sr[c + 0x05] & 0x00003FFF) << 0x0F);
		ds[t + 0x06] = (sr[c + 0x05] >> 0x0E) | ((sr[c + 0x06] & 0x000007FF) << 0x12);
		ds[t + 0x07] = (sr[c + 0x06] >> 0x0B) | ((sr[c + 0x07] & 0x000000FF) << 0x15);
		ds[t + 0x08] = (sr[c + 0x07] >> 0x08) | ((sr[c + 0x08] & 0x0000001F) << 0x18);
		ds[t + 0x09] = (sr[c + 0x08] >> 0x05) | ((sr[c + 0x09] & 0x00000003) << 0x1B);
		ds[t + 0x0A] = (sr[c + 0x09] >> 0x02) & 0x1FFFFFFF;
		ds[t + 0x0B] = (sr[c + 0x09] >> 0x1F) | ((sr[c + 0x0A] & 0x0FFFFFFF) << 0x01);
		ds[t + 0x0C] = (sr[c + 0x0A] >> 0x1C) | ((sr[c + 0x0B] & 0x01FFFFFF) << 0x04);
		ds[t + 0x0D] = (sr[c + 0x0B] >> 0x19) | ((sr[c + 0x0C] & 0x003FFFFF) << 0x07);
		ds[t + 0x0E] = (sr[c + 0x0C] >> 0x16) | ((sr[c + 0x0D] & 0x0007FFFF) << 0x0A);
		ds[t + 0x0F] = (sr[c + 0x0D] >> 0x13) | ((sr[c + 0x0E] & 0x0000FFFF) << 0x0D);
		ds[t + 0x10] = (sr[c + 0x0E] >> 0x10) | ((sr[c + 0x0F] & 0x00001FFF) << 0x10);
		ds[t + 0x11] = (sr[c + 0x0F] >> 0x0D) | ((sr[c + 0x10] & 0x000003FF) << 0x13);
		ds[t + 0x12] = (sr[c + 0x10] >> 0x0A) | ((sr[c + 0x11] & 0x0000007F) << 0x16);
		ds[t + 0x13] = (sr[c + 0x11] >> 0x07) | ((sr[c + 0x12] & 0x0000000F) << 0x19);
		ds[t + 0x14] = (sr[c + 0x12] >> 0x04) | ((sr[c + 0x13] & 0x00000001) << 0x1C);
		ds[t + 0x15] = (sr[c + 0x13] >> 0x01) & 0x1FFFFFFF;
		ds[t + 0x16] = (sr[c + 0x13] >> 0x1E) | ((sr[c + 0x14] & 0x07FFFFFF) << 0x02);
		ds[t + 0x17] = (sr[c + 0x14] >> 0x1B) | ((sr[c + 0x15] & 0x00FFFFFF) << 0x05);
		ds[t + 0x18] = (sr[c + 0x15] >> 0x18) | ((sr[c + 0x16] & 0x001FFFFF) << 0x08);
		ds[t + 0x19] = (sr[c + 0x16] >> 0x15) | ((sr[c + 0x17] & 0x0003FFFF) << 0x0B);
		ds[t + 0x1A] = (sr[c + 0x17] >> 0x12) | ((sr[c + 0x18] & 0x00007FFF) << 0x0E);
		ds[t + 0x1B] = (sr[c + 0x18] >> 0x0F) | ((sr[c + 0x19] & 0x00000FFF) << 0x11);
		ds[t + 0x1C] = (sr[c + 0x19] >> 0x0C) | ((sr[c + 0x1A] & 0x000001FF) << 0x14);
		ds[t + 0x1D] = (sr[c + 0x1A] >> 0x09) | ((sr[c + 0x1B] & 0x0000003F) << 0x17);
		ds[t + 0x1E] = (sr[c + 0x1B] >> 0x06) | ((sr[c + 0x1C] & 0x00000007) << 0x1A);
		ds[t + 0x1F] = (sr[c + 0x1C] >> 0x03);
	}

	static inline void unpack30(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x3FFFFFFF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x1E) | ((sr[c + 0x01] & 0x0FFFFFFF) << 0x02);
		ds[t + 0x02] = (sr[c + 0x01] >> 0x1C) | ((sr[c + 0x02] & 0x03FFFFFF) << 0x04);
		ds[t + 0x03] = (sr[c + 0x02] >> 0x1A) | ((sr[c + 0x03] & 0x00FFFFFF) << 0x06);
		ds[t + 0x04] = (sr[c + 0x03] >> 0x18) | ((sr[c + 0x04] & 0x003FFFFF) << 0x08);
		ds[t + 0x05] = (sr[c + 0x04] >> 0x16) | ((sr[c + 0x05] & 0x000FFFFF) << 0x0A);
		ds[t + 0x06] = (sr[c + 0x05] >> 0x14) | ((sr[c + 0x06] & 0x0003FFFF) << 0x0C);
		ds[t + 0x07] = (sr[c + 0x06] >> 0x12) | ((sr[c + 0x07] & 0x0000FFFF) << 0x0E);
		ds[t + 0x08] = (sr[c + 0x07] >> 0x10) | ((sr[c + 0x08] & 0x00003FFF) << 0x10);
		ds[t + 0x09] = (sr[c + 0x08] >> 0x0E) | ((sr[c + 0x09] & 0x00000FFF) << 0x12);
		ds[t + 0x0A] = (sr[c + 0x09] >> 0x0C) | ((sr[c + 0x0A] & 0x000003FF) << 0x14);
		ds[t + 0x0B] = (sr[c + 0x0A] >> 0x0A) | ((sr[c + 0x0B] & 0x000000FF) << 0x16);
		ds[t + 0x0C] = (sr[c + 0x0B] >> 0x08) | ((sr[c + 0x0C] & 0x0000003F) << 0x18);
		ds[t + 0x0D] = (sr[c + 0x0C] >> 0x06) | ((sr[c + 0x0D] & 0x0000000F) << 0x1A);
		ds[t + 0x0E] = (sr[c + 0x0D] >> 0x04) | ((sr[c + 0x0E] & 0x00000003) << 0x1C);
		ds[t + 0x0F] = (sr[c + 0x0E] >> 0x02);
		ds[t + 0x10] = (sr[c + 0x0F] >> 0x00) & 0x3FFFFFFF;
		ds[t + 0x11] = (sr[c + 0x0F] >> 0x1E) | ((sr[c + 0x10] & 0x0FFFFFFF) << 0x02);
		ds[t + 0x12] = (sr[c + 0x10] >> 0x1C) | ((sr[c + 0x11] & 0x03FFFFFF) << 0x04);
		ds[t + 0x13] = (sr[c + 0x11] >> 0x1A) | ((sr[c + 0x12] & 0x00FFFFFF) << 0x06);
		ds[t + 0x14] = (sr[c + 0x12] >> 0x18) | ((sr[c + 0x13] & 0x003FFFFF) << 0x08);
		ds[t + 0x15] = (sr[c + 0x13] >> 0x16) | ((sr[c + 0x14] & 0x000FFFFF) << 0x0A);
		ds[t + 0x16] = (sr[c + 0x14] >> 0x14) | ((sr[c + 0x15] & 0x0003FFFF) << 0x0C);
		ds[t + 0x17] = (sr[c + 0x15] >> 0x12) | ((sr[c + 0x16] & 0x0000FFFF) << 0x0E);
		ds[t + 0x18] = (sr[c + 0x16] >> 0x10) | ((sr[c + 0x17] & 0x00003FFF) << 0x10);
		ds[t + 0x19] = (sr[c + 0x17] >> 0x0E) | ((sr[c + 0x18] & 0x00000FFF) << 0x12);
		ds[t + 0x1A] = (sr[c + 0x18] >> 0x0C) | ((sr[c + 0x19] & 0x000003FF) << 0x14);
		ds[t + 0x1B] = (sr[c + 0x19] >> 0x0A) | ((sr[c + 0x1A] & 0x000000FF) << 0x16);
		ds[t + 0x1C] = (sr[c + 0x1A] >> 0x08) | ((sr[c + 0x1B] & 0x0000003F) << 0x18);
		ds[t + 0x1D] = (sr[c + 0x1B] >> 0x06) | ((sr[c + 0x1C] & 0x0000000F) << 0x1A);
		ds[t + 0x1E] = (sr[c + 0x1C] >> 0x04) | ((sr[c + 0x1D] & 0x00000003) << 0x1C);
		ds[t + 0x1F] = (sr[c + 0x1D] >> 0x02);
	}

	static inline void unpack31(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = (sr[c + 0x00] >> 0x00) & 0x7FFFFFFF;
		ds[t + 0x01] = (sr[c + 0x00] >> 0x1F) | ((sr[c + 0x01] & 0x3FFFFFFF) << 0x01);
		ds[t + 0x02] = (sr[c + 0x01] >> 0x1E) | ((sr[c + 0x02] & 0x1FFFFFFF) << 0x02);
		ds[t + 0x03] = (sr[c + 0x02] >> 0x1D) | ((sr[c + 0x03] & 0x0FFFFFFF) << 0x03);
		ds[t + 0x04] = (sr[c + 0x03] >> 0x1C) | ((sr[c + 0x04] & 0x07FFFFFF) << 0x04);
		ds[t + 0x05] = (sr[c + 0x04] >> 0x1B) | ((sr[c + 0x05] & 0x03FFFFFF) << 0x05);
		ds[t + 0x06] = (sr[c + 0x05] >> 0x1A) | ((sr[c + 0x06] & 0x01FFFFFF) << 0x06);
		ds[t + 0x07] = (sr[c + 0x06] >> 0x19) | ((sr[c + 0x07] & 0x00FFFFFF) << 0x07);
		ds[t + 0x08] = (sr[c + 0x07] >> 0x18) | ((sr[c + 0x08] & 0x007FFFFF) << 0x08);
		ds[t + 0x09] = (sr[c + 0x08] >> 0x17) | ((sr[c + 0x09] & 0x003FFFFF) << 0x09);
		ds[t + 0x0A] = (sr[c + 0x09] >> 0x16) | ((sr[c + 0x0A] & 0x001FFFFF) << 0x0A);
		ds[t + 0x0B] = (sr[c + 0x0A] >> 0x15) | ((sr[c + 0x0B] & 0x000FFFFF) << 0x0B);
		ds[t + 0x0C] = (sr[c + 0x0B] >> 0x14) | ((sr[c + 0x0C] & 0x0007FFFF) << 0x0C);
		ds[t + 0x0D] = (sr[c + 0x0C] >> 0x13) | ((sr[c + 0x0D] & 0x0003FFFF) << 0x0D);
		ds[t + 0x0E] = (sr[c + 0x0D] >> 0x12) | ((sr[c + 0x0E] & 0x0001FFFF) << 0x0E);
		ds[t + 0x0F] = (sr[c + 0x0E] >> 0x11) | ((sr[c + 0x0F] & 0x0000FFFF) << 0x0F);
		ds[t + 0x10] = (sr[c + 0x0F] >> 0x10) | ((sr[c + 0x10] & 0x00007FFF) << 0x10);
		ds[t + 0x11] = (sr[c + 0x10] >> 0x0F) | ((sr[c + 0x11] & 0x00003FFF) << 0x11);
		ds[t + 0x12] = (sr[c + 0x11] >> 0x0E) | ((sr[c + 0x12] & 0x00001FFF) << 0x12);
		ds[t + 0x13] = (sr[c + 0x12] >> 0x0D) | ((sr[c + 0x13] & 0x00000FFF) << 0x13);
		ds[t + 0x14] = (sr[c + 0x13] >> 0x0C) | ((sr[c + 0x14] & 0x000007FF) << 0x14);
		ds[t + 0x15] = (sr[c + 0x14] >> 0x0B) | ((sr[c + 0x15] & 0x000003FF) << 0x15);
		ds[t + 0x16] = (sr[c + 0x15] >> 0x0A) | ((sr[c + 0x16] & 0x000001FF) << 0x16);
		ds[t + 0x17] = (sr[c + 0x16] >> 0x09) | ((sr[c + 0x17] & 0x000000FF) << 0x17);
		ds[t + 0x18] = (sr[c + 0x17] >> 0x08) | ((sr[c + 0x18] & 0x0000007F) << 0x18);
		ds[t + 0x19] = (sr[c + 0x18] >> 0x07) | ((sr[c + 0x19] & 0x0000003F) << 0x19);
		ds[t + 0x1A] = (sr[c + 0x19] >> 0x06) | ((sr[c + 0x1A] & 0x0000001F) << 0x1A);
		ds[t + 0x1B] = (sr[c + 0x1A] >> 0x05) | ((sr[c + 0x1B] & 0x0000000F) << 0x1B);
		ds[t + 0x1C] = (sr[c + 0x1B] >> 0x04) | ((sr[c + 0x1C] & 0x00000007) << 0x1C);
		ds[t + 0x1D] = (sr[c + 0x1C] >> 0x03) | ((sr[c + 0x1D] & 0x00000003) << 0x1D);
		ds[t + 0x1E] = (sr[c + 0x1D] >> 0x02) | ((sr[c + 0x1E] & 0x00000001) << 0x1E);
		ds[t + 0x1F] = (sr[c + 0x1E] >> 0x01);
	}

	static inline void diffUnpack00(u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF];
		ds[t + 0x01] = ds[t + 0x01 - DIFF];
		ds[t + 0x02] = ds[t + 0x02 - DIFF];
		ds[t + 0x03] = ds[t + 0x03 - DIFF];
		ds[t + 0x04] = ds[t + 0x04 - DIFF];
		ds[t + 0x05] = ds[t + 0x05 - DIFF];
		ds[t + 0x06] = ds[t + 0x06 - DIFF];
		ds[t + 0x07] = ds[t + 0x07 - DIFF];
		ds[t + 0x08] = ds[t + 0x08 - DIFF];
		ds[t + 0x09] = ds[t + 0x09 - DIFF];
		ds[t + 0x0A] = ds[t + 0x0A - DIFF];
		ds[t + 0x0B] = ds[t + 0x0B - DIFF];
		ds[t + 0x0C] = ds[t + 0x0C - DIFF];
		ds[t + 0x0D] = ds[t + 0x0D - DIFF];
		ds[t + 0x0E] = ds[t + 0x0E - DIFF];
		ds[t + 0x0F] = ds[t + 0x0F - DIFF];
		ds[t + 0x10] = ds[t + 0x10 - DIFF];
		ds[t + 0x11] = ds[t + 0x11 - DIFF];
		ds[t + 0x12] = ds[t + 0x12 - DIFF];
		ds[t + 0x13] = ds[t + 0x13 - DIFF];
		ds[t + 0x14] = ds[t + 0x14 - DIFF];
		ds[t + 0x15] = ds[t + 0x15 - DIFF];
		ds[t + 0x16] = ds[t + 0x16 - DIFF];
		ds[t + 0x17] = ds[t + 0x17 - DIFF];
		ds[t + 0x18] = ds[t + 0x18 - DIFF];
		ds[t + 0x19] = ds[t + 0x19 - DIFF];
		ds[t + 0x1A] = ds[t + 0x1A - DIFF];
		ds[t + 0x1B] = ds[t + 0x1B - DIFF];
		ds[t + 0x1C] = ds[t + 0x1C - DIFF];
		ds[t + 0x1D] = ds[t + 0x1D - DIFF];
		ds[t + 0x1E] = ds[t + 0x1E - DIFF];
		ds[t + 0x1F] = ds[t + 0x1F - DIFF];
	}

	static inline void diffUnpack01(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x00000001);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x01) & 0x00000001);
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x00] >> 0x02) & 0x00000001);
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x00] >> 0x03) & 0x00000001);
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x00] >> 0x04) & 0x00000001);
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x00] >> 0x05) & 0x00000001);
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x00] >> 0x06) & 0x00000001);
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x00] >> 0x07) & 0x00000001);
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x00] >> 0x08) & 0x00000001);
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x00] >> 0x09) & 0x00000001);
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x00] >> 0x0A) & 0x00000001);
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x00] >> 0x0B) & 0x00000001);
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x00] >> 0x0C) & 0x00000001);
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x00] >> 0x0D) & 0x00000001);
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x00] >> 0x0E) & 0x00000001);
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x00] >> 0x0F) & 0x00000001);
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x00] >> 0x10) & 0x00000001);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x00] >> 0x11) & 0x00000001);
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x00] >> 0x12) & 0x00000001);
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x00] >> 0x13) & 0x00000001);
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x00] >> 0x14) & 0x00000001);
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x00] >> 0x15) & 0x00000001);
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x00] >> 0x16) & 0x00000001);
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x00] >> 0x17) & 0x00000001);
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x00] >> 0x18) & 0x00000001);
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x00] >> 0x19) & 0x00000001);
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x00] >> 0x1A) & 0x00000001);
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x00] >> 0x1B) & 0x00000001);
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x00] >> 0x1C) & 0x00000001);
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x00] >> 0x1D) & 0x00000001);
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x00] >> 0x1E) & 0x00000001);
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x00] >> 0x1F));
	}

	static inline void diffUnpack02(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x00000003);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x02) & 0x00000003);
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x00] >> 0x04) & 0x00000003);
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x00] >> 0x06) & 0x00000003);
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x00] >> 0x08) & 0x00000003);
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x00] >> 0x0A) & 0x00000003);
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x00] >> 0x0C) & 0x00000003);
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x00] >> 0x0E) & 0x00000003);
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x00] >> 0x10) & 0x00000003);
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x00] >> 0x12) & 0x00000003);
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x00] >> 0x14) & 0x00000003);
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x00] >> 0x16) & 0x00000003);
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x00] >> 0x18) & 0x00000003);
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x00] >> 0x1A) & 0x00000003);
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x00] >> 0x1C) & 0x00000003);
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x00] >> 0x1E));
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x01] >> 0x00) & 0x00000003);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x01] >> 0x02) & 0x00000003);
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x01] >> 0x04) & 0x00000003);
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x01] >> 0x06) & 0x00000003);
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x01] >> 0x08) & 0x00000003);
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x01] >> 0x0A) & 0x00000003);
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x01] >> 0x0C) & 0x00000003);
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x01] >> 0x0E) & 0x00000003);
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x01] >> 0x10) & 0x00000003);
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x01] >> 0x12) & 0x00000003);
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x01] >> 0x14) & 0x00000003);
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x01] >> 0x16) & 0x00000003);
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x01] >> 0x18) & 0x00000003);
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x01] >> 0x1A) & 0x00000003);
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x01] >> 0x1C) & 0x00000003);
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x01] >> 0x1E));
	}

	static inline void diffUnpack03(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x00000007);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x03) & 0x00000007);
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x00] >> 0x06) & 0x00000007);
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x00] >> 0x09) & 0x00000007);
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x00] >> 0x0C) & 0x00000007);
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x00] >> 0x0F) & 0x00000007);
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x00] >> 0x12) & 0x00000007);
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x00] >> 0x15) & 0x00000007);
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x00] >> 0x18) & 0x00000007);
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x00] >> 0x1B) & 0x00000007);
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x00] >> 0x1E) | ((sr[c + 0x01] & 0x00000001) << 0x02));
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x01] >> 0x01) & 0x00000007);
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x01] >> 0x04) & 0x00000007);
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x01] >> 0x07) & 0x00000007);
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x01] >> 0x0A) & 0x00000007);
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x01] >> 0x0D) & 0x00000007);
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x01] >> 0x10) & 0x00000007);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x01] >> 0x13) & 0x00000007);
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x01] >> 0x16) & 0x00000007);
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x01] >> 0x19) & 0x00000007);
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x01] >> 0x1C) & 0x00000007);
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x01] >> 0x1F) | ((sr[c + 0x02] & 0x00000003) << 0x01));
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x02] >> 0x02) & 0x00000007);
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x02] >> 0x05) & 0x00000007);
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x02] >> 0x08) & 0x00000007);
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x02] >> 0x0B) & 0x00000007);
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x02] >> 0x0E) & 0x00000007);
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x02] >> 0x11) & 0x00000007);
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x02] >> 0x14) & 0x00000007);
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x02] >> 0x17) & 0x00000007);
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x02] >> 0x1A) & 0x00000007);
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x02] >> 0x1D));
	}

	static inline void diffUnpack04(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x0000000F);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x04) & 0x0000000F);
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x00] >> 0x08) & 0x0000000F);
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x00] >> 0x0C) & 0x0000000F);
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x00] >> 0x10) & 0x0000000F);
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x00] >> 0x14) & 0x0000000F);
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x00] >> 0x18) & 0x0000000F);
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x00] >> 0x1C));
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x01] >> 0x00) & 0x0000000F);
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x01] >> 0x04) & 0x0000000F);
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x01] >> 0x08) & 0x0000000F);
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x01] >> 0x0C) & 0x0000000F);
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x01] >> 0x10) & 0x0000000F);
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x01] >> 0x14) & 0x0000000F);
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x01] >> 0x18) & 0x0000000F);
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x01] >> 0x1C));
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x02] >> 0x00) & 0x0000000F);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x02] >> 0x04) & 0x0000000F);
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x02] >> 0x08) & 0x0000000F);
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x02] >> 0x0C) & 0x0000000F);
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x02] >> 0x10) & 0x0000000F);
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x02] >> 0x14) & 0x0000000F);
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x02] >> 0x18) & 0x0000000F);
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x02] >> 0x1C));
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x03] >> 0x00) & 0x0000000F);
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x03] >> 0x04) & 0x0000000F);
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x03] >> 0x08) & 0x0000000F);
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x03] >> 0x0C) & 0x0000000F);
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x03] >> 0x10) & 0x0000000F);
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x03] >> 0x14) & 0x0000000F);
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x03] >> 0x18) & 0x0000000F);
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x03] >> 0x1C));
	}

	static inline void diffUnpack05(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x0000001F);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x05) & 0x0000001F);
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x00] >> 0x0A) & 0x0000001F);
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x00] >> 0x0F) & 0x0000001F);
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x00] >> 0x14) & 0x0000001F);
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x00] >> 0x19) & 0x0000001F);
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x00] >> 0x1E) | ((sr[c + 0x01] & 0x00000007) << 0x02));
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x01] >> 0x03) & 0x0000001F);
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x01] >> 0x08) & 0x0000001F);
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x01] >> 0x0D) & 0x0000001F);
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x01] >> 0x12) & 0x0000001F);
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x01] >> 0x17) & 0x0000001F);
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x01] >> 0x1C) | ((sr[c + 0x02] & 0x00000001) << 0x04));
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x02] >> 0x01) & 0x0000001F);
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x02] >> 0x06) & 0x0000001F);
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x02] >> 0x0B) & 0x0000001F);
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x02] >> 0x10) & 0x0000001F);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x02] >> 0x15) & 0x0000001F);
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x02] >> 0x1A) & 0x0000001F);
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x02] >> 0x1F) | ((sr[c + 0x03] & 0x0000000F) << 0x01));
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x03] >> 0x04) & 0x0000001F);
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x03] >> 0x09) & 0x0000001F);
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x03] >> 0x0E) & 0x0000001F);
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x03] >> 0x13) & 0x0000001F);
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x03] >> 0x18) & 0x0000001F);
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x03] >> 0x1D) | ((sr[c + 0x04] & 0x00000003) << 0x03));
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x04] >> 0x02) & 0x0000001F);
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x04] >> 0x07) & 0x0000001F);
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x04] >> 0x0C) & 0x0000001F);
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x04] >> 0x11) & 0x0000001F);
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x04] >> 0x16) & 0x0000001F);
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x04] >> 0x1B));
	}

	static inline void diffUnpack06(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x0000003F);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x06) & 0x0000003F);
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x00] >> 0x0C) & 0x0000003F);
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x00] >> 0x12) & 0x0000003F);
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x00] >> 0x18) & 0x0000003F);
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x00] >> 0x1E) | ((sr[c + 0x01] & 0x0000000F) << 0x02));
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x01] >> 0x04) & 0x0000003F);
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x01] >> 0x0A) & 0x0000003F);
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x01] >> 0x10) & 0x0000003F);
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x01] >> 0x16) & 0x0000003F);
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x01] >> 0x1C) | ((sr[c + 0x02] & 0x00000003) << 0x04));
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x02] >> 0x02) & 0x0000003F);
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x02] >> 0x08) & 0x0000003F);
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x02] >> 0x0E) & 0x0000003F);
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x02] >> 0x14) & 0x0000003F);
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x02] >> 0x1A));
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x03] >> 0x00) & 0x0000003F);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x03] >> 0x06) & 0x0000003F);
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x03] >> 0x0C) & 0x0000003F);
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x03] >> 0x12) & 0x0000003F);
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x03] >> 0x18) & 0x0000003F);
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x03] >> 0x1E) | ((sr[c + 0x04] & 0x0000000F) << 0x02));
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x04] >> 0x04) & 0x0000003F);
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x04] >> 0x0A) & 0x0000003F);
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x04] >> 0x10) & 0x0000003F);
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x04] >> 0x16) & 0x0000003F);
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x04] >> 0x1C) | ((sr[c + 0x05] & 0x00000003) << 0x04));
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x05] >> 0x02) & 0x0000003F);
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x05] >> 0x08) & 0x0000003F);
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x05] >> 0x0E) & 0x0000003F);
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x05] >> 0x14) & 0x0000003F);
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x05] >> 0x1A));
	}

	static inline void diffUnpack07(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x0000007F);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x07) & 0x0000007F);
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x00] >> 0x0E) & 0x0000007F);
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x00] >> 0x15) & 0x0000007F);
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x00] >> 0x1C) | ((sr[c + 0x01] & 0x00000007) << 0x04));
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x01] >> 0x03) & 0x0000007F);
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x01] >> 0x0A) & 0x0000007F);
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x01] >> 0x11) & 0x0000007F);
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x01] >> 0x18) & 0x0000007F);
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x01] >> 0x1F) | ((sr[c + 0x02] & 0x0000003F) << 0x01));
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x02] >> 0x06) & 0x0000007F);
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x02] >> 0x0D) & 0x0000007F);
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x02] >> 0x14) & 0x0000007F);
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x02] >> 0x1B) | ((sr[c + 0x03] & 0x00000003) << 0x05));
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x03] >> 0x02) & 0x0000007F);
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x03] >> 0x09) & 0x0000007F);
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x03] >> 0x10) & 0x0000007F);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x03] >> 0x17) & 0x0000007F);
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x03] >> 0x1E) | ((sr[c + 0x04] & 0x0000001F) << 0x02));
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x04] >> 0x05) & 0x0000007F);
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x04] >> 0x0C) & 0x0000007F);
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x04] >> 0x13) & 0x0000007F);
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x04] >> 0x1A) | ((sr[c + 0x05] & 0x00000001) << 0x06));
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x05] >> 0x01) & 0x0000007F);
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x05] >> 0x08) & 0x0000007F);
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x05] >> 0x0F) & 0x0000007F);
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x05] >> 0x16) & 0x0000007F);
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x05] >> 0x1D) | ((sr[c + 0x06] & 0x0000000F) << 0x03));
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x06] >> 0x04) & 0x0000007F);
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x06] >> 0x0B) & 0x0000007F);
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x06] >> 0x12) & 0x0000007F);
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x06] >> 0x19));
	}

	static inline void diffUnpack08(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x000000FF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x08) & 0x000000FF);
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x00] >> 0x10) & 0x000000FF);
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x00] >> 0x18));
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x01] >> 0x00) & 0x000000FF);
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x01] >> 0x08) & 0x000000FF);
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x01] >> 0x10) & 0x000000FF);
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x01] >> 0x18));
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x02] >> 0x00) & 0x000000FF);
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x02] >> 0x08) & 0x000000FF);
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x02] >> 0x10) & 0x000000FF);
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x02] >> 0x18));
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x03] >> 0x00) & 0x000000FF);
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x03] >> 0x08) & 0x000000FF);
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x03] >> 0x10) & 0x000000FF);
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x03] >> 0x18));
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x04] >> 0x00) & 0x000000FF);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x04] >> 0x08) & 0x000000FF);
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x04] >> 0x10) & 0x000000FF);
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x04] >> 0x18));
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x05] >> 0x00) & 0x000000FF);
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x05] >> 0x08) & 0x000000FF);
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x05] >> 0x10) & 0x000000FF);
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x05] >> 0x18));
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x06] >> 0x00) & 0x000000FF);
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x06] >> 0x08) & 0x000000FF);
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x06] >> 0x10) & 0x000000FF);
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x06] >> 0x18));
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x07] >> 0x00) & 0x000000FF);
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x07] >> 0x08) & 0x000000FF);
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x07] >> 0x10) & 0x000000FF);
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x07] >> 0x18));
	}

	static inline void diffUnpack09(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x000001FF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x09) & 0x000001FF);
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x00] >> 0x12) & 0x000001FF);
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x00] >> 0x1B) | ((sr[c + 0x01] & 0x0000000F) << 0x05));
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x01] >> 0x04) & 0x000001FF);
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x01] >> 0x0D) & 0x000001FF);
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x01] >> 0x16) & 0x000001FF);
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x01] >> 0x1F) | ((sr[c + 0x02] & 0x000000FF) << 0x01));
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x02] >> 0x08) & 0x000001FF);
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x02] >> 0x11) & 0x000001FF);
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x02] >> 0x1A) | ((sr[c + 0x03] & 0x00000007) << 0x06));
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x03] >> 0x03) & 0x000001FF);
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x03] >> 0x0C) & 0x000001FF);
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x03] >> 0x15) & 0x000001FF);
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x03] >> 0x1E) | ((sr[c + 0x04] & 0x0000007F) << 0x02));
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x04] >> 0x07) & 0x000001FF);
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x04] >> 0x10) & 0x000001FF);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x04] >> 0x19) | ((sr[c + 0x05] & 0x00000003) << 0x07));
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x05] >> 0x02) & 0x000001FF);
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x05] >> 0x0B) & 0x000001FF);
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x05] >> 0x14) & 0x000001FF);
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x05] >> 0x1D) | ((sr[c + 0x06] & 0x0000003F) << 0x03));
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x06] >> 0x06) & 0x000001FF);
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x06] >> 0x0F) & 0x000001FF);
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x06] >> 0x18) | ((sr[c + 0x07] & 0x00000001) << 0x08));
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x07] >> 0x01) & 0x000001FF);
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x07] >> 0x0A) & 0x000001FF);
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x07] >> 0x13) & 0x000001FF);
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x07] >> 0x1C) | ((sr[c + 0x08] & 0x0000001F) << 0x04));
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x08] >> 0x05) & 0x000001FF);
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x08] >> 0x0E) & 0x000001FF);
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x08] >> 0x17));
	}

	static inline void diffUnpack10(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x000003FF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x0A) & 0x000003FF);
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x00] >> 0x14) & 0x000003FF);
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x00] >> 0x1E) | ((sr[c + 0x01] & 0x000000FF) << 0x02));
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x01] >> 0x08) & 0x000003FF);
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x01] >> 0x12) & 0x000003FF);
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x01] >> 0x1C) | ((sr[c + 0x02] & 0x0000003F) << 0x04));
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x02] >> 0x06) & 0x000003FF);
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x02] >> 0x10) & 0x000003FF);
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x02] >> 0x1A) | ((sr[c + 0x03] & 0x0000000F) << 0x06));
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x03] >> 0x04) & 0x000003FF);
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x03] >> 0x0E) & 0x000003FF);
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x03] >> 0x18) | ((sr[c + 0x04] & 0x00000003) << 0x08));
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x04] >> 0x02) & 0x000003FF);
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x04] >> 0x0C) & 0x000003FF);
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x04] >> 0x16));
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x05] >> 0x00) & 0x000003FF);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x05] >> 0x0A) & 0x000003FF);
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x05] >> 0x14) & 0x000003FF);
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x05] >> 0x1E) | ((sr[c + 0x06] & 0x000000FF) << 0x02));
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x06] >> 0x08) & 0x000003FF);
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x06] >> 0x12) & 0x000003FF);
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x06] >> 0x1C) | ((sr[c + 0x07] & 0x0000003F) << 0x04));
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x07] >> 0x06) & 0x000003FF);
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x07] >> 0x10) & 0x000003FF);
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x07] >> 0x1A) | ((sr[c + 0x08] & 0x0000000F) << 0x06));
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x08] >> 0x04) & 0x000003FF);
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x08] >> 0x0E) & 0x000003FF);
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x08] >> 0x18) | ((sr[c + 0x09] & 0x00000003) << 0x08));
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x09] >> 0x02) & 0x000003FF);
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x09] >> 0x0C) & 0x000003FF);
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x09] >> 0x16));
	}

	static inline void diffUnpack11(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x000007FF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x0B) & 0x000007FF);
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x00] >> 0x16) | ((sr[c + 0x01] & 0x00000001) << 0x0A));
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x01] >> 0x01) & 0x000007FF);
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x01] >> 0x0C) & 0x000007FF);
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x01] >> 0x17) | ((sr[c + 0x02] & 0x00000003) << 0x09));
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x02] >> 0x02) & 0x000007FF);
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x02] >> 0x0D) & 0x000007FF);
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x02] >> 0x18) | ((sr[c + 0x03] & 0x00000007) << 0x08));
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x03] >> 0x03) & 0x000007FF);
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x03] >> 0x0E) & 0x000007FF);
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x03] >> 0x19) | ((sr[c + 0x04] & 0x0000000F) << 0x07));
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x04] >> 0x04) & 0x000007FF);
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x04] >> 0x0F) & 0x000007FF);
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x04] >> 0x1A) | ((sr[c + 0x05] & 0x0000001F) << 0x06));
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x05] >> 0x05) & 0x000007FF);
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x05] >> 0x10) & 0x000007FF);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x05] >> 0x1B) | ((sr[c + 0x06] & 0x0000003F) << 0x05));
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x06] >> 0x06) & 0x000007FF);
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x06] >> 0x11) & 0x000007FF);
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x06] >> 0x1C) | ((sr[c + 0x07] & 0x0000007F) << 0x04));
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x07] >> 0x07) & 0x000007FF);
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x07] >> 0x12) & 0x000007FF);
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x07] >> 0x1D) | ((sr[c + 0x08] & 0x000000FF) << 0x03));
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x08] >> 0x08) & 0x000007FF);
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x08] >> 0x13) & 0x000007FF);
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x08] >> 0x1E) | ((sr[c + 0x09] & 0x000001FF) << 0x02));
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x09] >> 0x09) & 0x000007FF);
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x09] >> 0x14) & 0x000007FF);
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x09] >> 0x1F) | ((sr[c + 0x0A] & 0x000003FF) << 0x01));
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x0A] >> 0x0A) & 0x000007FF);
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x0A] >> 0x15));
	}

	static inline void diffUnpack12(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x00000FFF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x0C) & 0x00000FFF);
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x00] >> 0x18) | ((sr[c + 0x01] & 0x0000000F) << 0x08));
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x01] >> 0x04) & 0x00000FFF);
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x01] >> 0x10) & 0x00000FFF);
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x01] >> 0x1C) | ((sr[c + 0x02] & 0x000000FF) << 0x04));
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x02] >> 0x08) & 0x00000FFF);
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x02] >> 0x14));
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x03] >> 0x00) & 0x00000FFF);
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x03] >> 0x0C) & 0x00000FFF);
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x03] >> 0x18) | ((sr[c + 0x04] & 0x0000000F) << 0x08));
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x04] >> 0x04) & 0x00000FFF);
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x04] >> 0x10) & 0x00000FFF);
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x04] >> 0x1C) | ((sr[c + 0x05] & 0x000000FF) << 0x04));
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x05] >> 0x08) & 0x00000FFF);
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x05] >> 0x14));
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x06] >> 0x00) & 0x00000FFF);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x06] >> 0x0C) & 0x00000FFF);
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x06] >> 0x18) | ((sr[c + 0x07] & 0x0000000F) << 0x08));
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x07] >> 0x04) & 0x00000FFF);
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x07] >> 0x10) & 0x00000FFF);
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x07] >> 0x1C) | ((sr[c + 0x08] & 0x000000FF) << 0x04));
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x08] >> 0x08) & 0x00000FFF);
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x08] >> 0x14));
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x09] >> 0x00) & 0x00000FFF);
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x09] >> 0x0C) & 0x00000FFF);
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x09] >> 0x18) | ((sr[c + 0x0A] & 0x0000000F) << 0x08));
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x0A] >> 0x04) & 0x00000FFF);
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x0A] >> 0x10) & 0x00000FFF);
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x0A] >> 0x1C) | ((sr[c + 0x0B] & 0x000000FF) << 0x04));
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x0B] >> 0x08) & 0x00000FFF);
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x0B] >> 0x14));
	}

	static inline void diffUnpack13(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x00001FFF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x0D) & 0x00001FFF);
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x00] >> 0x1A) | ((sr[c + 0x01] & 0x0000007F) << 0x06));
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x01] >> 0x07) & 0x00001FFF);
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x01] >> 0x14) | ((sr[c + 0x02] & 0x00000001) << 0x0C));
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x02] >> 0x01) & 0x00001FFF);
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x02] >> 0x0E) & 0x00001FFF);
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x02] >> 0x1B) | ((sr[c + 0x03] & 0x000000FF) << 0x05));
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x03] >> 0x08) & 0x00001FFF);
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x03] >> 0x15) | ((sr[c + 0x04] & 0x00000003) << 0x0B));
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x04] >> 0x02) & 0x00001FFF);
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x04] >> 0x0F) & 0x00001FFF);
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x04] >> 0x1C) | ((sr[c + 0x05] & 0x000001FF) << 0x04));
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x05] >> 0x09) & 0x00001FFF);
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x05] >> 0x16) | ((sr[c + 0x06] & 0x00000007) << 0x0A));
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x06] >> 0x03) & 0x00001FFF);
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x06] >> 0x10) & 0x00001FFF);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x06] >> 0x1D) | ((sr[c + 0x07] & 0x000003FF) << 0x03));
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x07] >> 0x0A) & 0x00001FFF);
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x07] >> 0x17) | ((sr[c + 0x08] & 0x0000000F) << 0x09));
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x08] >> 0x04) & 0x00001FFF);
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x08] >> 0x11) & 0x00001FFF);
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x08] >> 0x1E) | ((sr[c + 0x09] & 0x000007FF) << 0x02));
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x09] >> 0x0B) & 0x00001FFF);
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x09] >> 0x18) | ((sr[c + 0x0A] & 0x0000001F) << 0x08));
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x0A] >> 0x05) & 0x00001FFF);
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x0A] >> 0x12) & 0x00001FFF);
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x0A] >> 0x1F) | ((sr[c + 0x0B] & 0x00000FFF) << 0x01));
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x0B] >> 0x0C) & 0x00001FFF);
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x0B] >> 0x19) | ((sr[c + 0x0C] & 0x0000003F) << 0x07));
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x0C] >> 0x06) & 0x00001FFF);
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x0C] >> 0x13));
	}

	static inline void diffUnpack14(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x00003FFF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x0E) & 0x00003FFF);
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x00] >> 0x1C) | ((sr[c + 0x01] & 0x000003FF) << 0x04));
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x01] >> 0x0A) & 0x00003FFF);
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x01] >> 0x18) | ((sr[c + 0x02] & 0x0000003F) << 0x08));
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x02] >> 0x06) & 0x00003FFF);
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x02] >> 0x14) | ((sr[c + 0x03] & 0x00000003) << 0x0C));
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x03] >> 0x02) & 0x00003FFF);
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x03] >> 0x10) & 0x00003FFF);
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x03] >> 0x1E) | ((sr[c + 0x04] & 0x00000FFF) << 0x02));
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x04] >> 0x0C) & 0x00003FFF);
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x04] >> 0x1A) | ((sr[c + 0x05] & 0x000000FF) << 0x06));
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x05] >> 0x08) & 0x00003FFF);
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x05] >> 0x16) | ((sr[c + 0x06] & 0x0000000F) << 0x0A));
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x06] >> 0x04) & 0x00003FFF);
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x06] >> 0x12));
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x07] >> 0x00) & 0x00003FFF);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x07] >> 0x0E) & 0x00003FFF);
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x07] >> 0x1C) | ((sr[c + 0x08] & 0x000003FF) << 0x04));
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x08] >> 0x0A) & 0x00003FFF);
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x08] >> 0x18) | ((sr[c + 0x09] & 0x0000003F) << 0x08));
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x09] >> 0x06) & 0x00003FFF);
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x09] >> 0x14) | ((sr[c + 0x0A] & 0x00000003) << 0x0C));
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x0A] >> 0x02) & 0x00003FFF);
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x0A] >> 0x10) & 0x00003FFF);
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x0A] >> 0x1E) | ((sr[c + 0x0B] & 0x00000FFF) << 0x02));
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x0B] >> 0x0C) & 0x00003FFF);
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x0B] >> 0x1A) | ((sr[c + 0x0C] & 0x000000FF) << 0x06));
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x0C] >> 0x08) & 0x00003FFF);
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x0C] >> 0x16) | ((sr[c + 0x0D] & 0x0000000F) << 0x0A));
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x0D] >> 0x04) & 0x00003FFF);
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x0D] >> 0x12));
	}

	static inline void diffUnpack15(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x00007FFF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x0F) & 0x00007FFF);
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x00] >> 0x1E) | ((sr[c + 0x01] & 0x00001FFF) << 0x02));
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x01] >> 0x0D) & 0x00007FFF);
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x01] >> 0x1C) | ((sr[c + 0x02] & 0x000007FF) << 0x04));
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x02] >> 0x0B) & 0x00007FFF);
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x02] >> 0x1A) | ((sr[c + 0x03] & 0x000001FF) << 0x06));
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x03] >> 0x09) & 0x00007FFF);
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x03] >> 0x18) | ((sr[c + 0x04] & 0x0000007F) << 0x08));
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x04] >> 0x07) & 0x00007FFF);
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x04] >> 0x16) | ((sr[c + 0x05] & 0x0000001F) << 0x0A));
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x05] >> 0x05) & 0x00007FFF);
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x05] >> 0x14) | ((sr[c + 0x06] & 0x00000007) << 0x0C));
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x06] >> 0x03) & 0x00007FFF);
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x06] >> 0x12) | ((sr[c + 0x07] & 0x00000001) << 0x0E));
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x07] >> 0x01) & 0x00007FFF);
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x07] >> 0x10) & 0x00007FFF);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x07] >> 0x1F) | ((sr[c + 0x08] & 0x00003FFF) << 0x01));
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x08] >> 0x0E) & 0x00007FFF);
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x08] >> 0x1D) | ((sr[c + 0x09] & 0x00000FFF) << 0x03));
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x09] >> 0x0C) & 0x00007FFF);
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x09] >> 0x1B) | ((sr[c + 0x0A] & 0x000003FF) << 0x05));
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x0A] >> 0x0A) & 0x00007FFF);
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x0A] >> 0x19) | ((sr[c + 0x0B] & 0x000000FF) << 0x07));
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x0B] >> 0x08) & 0x00007FFF);
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x0B] >> 0x17) | ((sr[c + 0x0C] & 0x0000003F) << 0x09));
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x0C] >> 0x06) & 0x00007FFF);
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x0C] >> 0x15) | ((sr[c + 0x0D] & 0x0000000F) << 0x0B));
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x0D] >> 0x04) & 0x00007FFF);
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x0D] >> 0x13) | ((sr[c + 0x0E] & 0x00000003) << 0x0D));
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x0E] >> 0x02) & 0x00007FFF);
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x0E] >> 0x11));
	}

	static inline void diffUnpack16(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag(sr[c + 0x00] & 0x0000FFFF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag(sr[c + 0x00] >> 0x10);
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag(sr[c + 0x01] & 0x0000FFFF);
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag(sr[c + 0x01] >> 0x10);
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag(sr[c + 0x02] & 0x0000FFFF);
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag(sr[c + 0x02] >> 0x10);
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag(sr[c + 0x03] & 0x0000FFFF);
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag(sr[c + 0x03] >> 0x10);
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag(sr[c + 0x04] & 0x0000FFFF);
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag(sr[c + 0x04] >> 0x10);
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag(sr[c + 0x05] & 0x0000FFFF);
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag(sr[c + 0x05] >> 0x10);
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag(sr[c + 0x06] & 0x0000FFFF);
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag(sr[c + 0x06] >> 0x10);
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag(sr[c + 0x07] & 0x0000FFFF);
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag(sr[c + 0x07] >> 0x10);
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag(sr[c + 0x08] & 0x0000FFFF);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag(sr[c + 0x08] >> 0x10);
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag(sr[c + 0x09] & 0x0000FFFF);
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag(sr[c + 0x09] >> 0x10);
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag(sr[c + 0x0A] & 0x0000FFFF);
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag(sr[c + 0x0A] >> 0x10);
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag(sr[c + 0x0B] & 0x0000FFFF);
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag(sr[c + 0x0B] >> 0x10);
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag(sr[c + 0x0C] & 0x0000FFFF);
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag(sr[c + 0x0C] >> 0x10);
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag(sr[c + 0x0D] & 0x0000FFFF);
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag(sr[c + 0x0D] >> 0x10);
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag(sr[c + 0x0E] & 0x0000FFFF);
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag(sr[c + 0x0E] >> 0x10);
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag(sr[c + 0x0F] & 0x0000FFFF);
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag(sr[c + 0x0F] >> 0x10);
	}

	static inline void diffUnpack17(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x0001FFFF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x11) | ((sr[c + 0x01] & 0x00000003) << 0x0F));
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x01] >> 0x02) & 0x0001FFFF);
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x01] >> 0x13) | ((sr[c + 0x02] & 0x0000000F) << 0x0D));
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x02] >> 0x04) & 0x0001FFFF);
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x02] >> 0x15) | ((sr[c + 0x03] & 0x0000003F) << 0x0B));
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x03] >> 0x06) & 0x0001FFFF);
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x03] >> 0x17) | ((sr[c + 0x04] & 0x000000FF) << 0x09));
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x04] >> 0x08) & 0x0001FFFF);
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x04] >> 0x19) | ((sr[c + 0x05] & 0x000003FF) << 0x07));
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x05] >> 0x0A) & 0x0001FFFF);
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x05] >> 0x1B) | ((sr[c + 0x06] & 0x00000FFF) << 0x05));
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x06] >> 0x0C) & 0x0001FFFF);
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x06] >> 0x1D) | ((sr[c + 0x07] & 0x00003FFF) << 0x03));
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x07] >> 0x0E) & 0x0001FFFF);
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x07] >> 0x1F) | ((sr[c + 0x08] & 0x0000FFFF) << 0x01));
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x08] >> 0x10) | ((sr[c + 0x09] & 0x00000001) << 0x10));
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x09] >> 0x01) & 0x0001FFFF);
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x09] >> 0x12) | ((sr[c + 0x0A] & 0x00000007) << 0x0E));
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x0A] >> 0x03) & 0x0001FFFF);
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x0A] >> 0x14) | ((sr[c + 0x0B] & 0x0000001F) << 0x0C));
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x0B] >> 0x05) & 0x0001FFFF);
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x0B] >> 0x16) | ((sr[c + 0x0C] & 0x0000007F) << 0x0A));
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x0C] >> 0x07) & 0x0001FFFF);
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x0C] >> 0x18) | ((sr[c + 0x0D] & 0x000001FF) << 0x08));
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x0D] >> 0x09) & 0x0001FFFF);
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x0D] >> 0x1A) | ((sr[c + 0x0E] & 0x000007FF) << 0x06));
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x0E] >> 0x0B) & 0x0001FFFF);
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x0E] >> 0x1C) | ((sr[c + 0x0F] & 0x00001FFF) << 0x04));
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x0F] >> 0x0D) & 0x0001FFFF);
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x0F] >> 0x1E) | ((sr[c + 0x10] & 0x00007FFF) << 0x02));
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x10] >> 0x0F));
	}

	static inline void diffUnpack18(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x0003FFFF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x12) | ((sr[c + 0x01] & 0x0000000F) << 0x0E));
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x01] >> 0x04) & 0x0003FFFF);
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x01] >> 0x16) | ((sr[c + 0x02] & 0x000000FF) << 0x0A));
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x02] >> 0x08) & 0x0003FFFF);
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x02] >> 0x1A) | ((sr[c + 0x03] & 0x00000FFF) << 0x06));
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x03] >> 0x0C) & 0x0003FFFF);
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x03] >> 0x1E) | ((sr[c + 0x04] & 0x0000FFFF) << 0x02));
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x04] >> 0x10) | ((sr[c + 0x05] & 0x00000003) << 0x10));
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x05] >> 0x02) & 0x0003FFFF);
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x05] >> 0x14) | ((sr[c + 0x06] & 0x0000003F) << 0x0C));
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x06] >> 0x06) & 0x0003FFFF);
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x06] >> 0x18) | ((sr[c + 0x07] & 0x000003FF) << 0x08));
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x07] >> 0x0A) & 0x0003FFFF);
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x07] >> 0x1C) | ((sr[c + 0x08] & 0x00003FFF) << 0x04));
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x08] >> 0x0E));
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x09] >> 0x00) & 0x0003FFFF);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x09] >> 0x12) | ((sr[c + 0x0A] & 0x0000000F) << 0x0E));
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x0A] >> 0x04) & 0x0003FFFF);
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x0A] >> 0x16) | ((sr[c + 0x0B] & 0x000000FF) << 0x0A));
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x0B] >> 0x08) & 0x0003FFFF);
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x0B] >> 0x1A) | ((sr[c + 0x0C] & 0x00000FFF) << 0x06));
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x0C] >> 0x0C) & 0x0003FFFF);
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x0C] >> 0x1E) | ((sr[c + 0x0D] & 0x0000FFFF) << 0x02));
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x0D] >> 0x10) | ((sr[c + 0x0E] & 0x00000003) << 0x10));
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x0E] >> 0x02) & 0x0003FFFF);
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x0E] >> 0x14) | ((sr[c + 0x0F] & 0x0000003F) << 0x0C));
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x0F] >> 0x06) & 0x0003FFFF);
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x0F] >> 0x18) | ((sr[c + 0x10] & 0x000003FF) << 0x08));
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x10] >> 0x0A) & 0x0003FFFF);
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x10] >> 0x1C) | ((sr[c + 0x11] & 0x00003FFF) << 0x04));
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x11] >> 0x0E));
	}

	static inline void diffUnpack19(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x0007FFFF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x13) | ((sr[c + 0x01] & 0x0000003F) << 0x0D));
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x01] >> 0x06) & 0x0007FFFF);
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x01] >> 0x19) | ((sr[c + 0x02] & 0x00000FFF) << 0x07));
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x02] >> 0x0C) & 0x0007FFFF);
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x02] >> 0x1F) | ((sr[c + 0x03] & 0x0003FFFF) << 0x01));
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x03] >> 0x12) | ((sr[c + 0x04] & 0x0000001F) << 0x0E));
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x04] >> 0x05) & 0x0007FFFF);
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x04] >> 0x18) | ((sr[c + 0x05] & 0x000007FF) << 0x08));
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x05] >> 0x0B) & 0x0007FFFF);
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x05] >> 0x1E) | ((sr[c + 0x06] & 0x0001FFFF) << 0x02));
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x06] >> 0x11) | ((sr[c + 0x07] & 0x0000000F) << 0x0F));
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x07] >> 0x04) & 0x0007FFFF);
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x07] >> 0x17) | ((sr[c + 0x08] & 0x000003FF) << 0x09));
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x08] >> 0x0A) & 0x0007FFFF);
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x08] >> 0x1D) | ((sr[c + 0x09] & 0x0000FFFF) << 0x03));
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x09] >> 0x10) | ((sr[c + 0x0A] & 0x00000007) << 0x10));
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x0A] >> 0x03) & 0x0007FFFF);
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x0A] >> 0x16) | ((sr[c + 0x0B] & 0x000001FF) << 0x0A));
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x0B] >> 0x09) & 0x0007FFFF);
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x0B] >> 0x1C) | ((sr[c + 0x0C] & 0x00007FFF) << 0x04));
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x0C] >> 0x0F) | ((sr[c + 0x0D] & 0x00000003) << 0x11));
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x0D] >> 0x02) & 0x0007FFFF);
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x0D] >> 0x15) | ((sr[c + 0x0E] & 0x000000FF) << 0x0B));
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x0E] >> 0x08) & 0x0007FFFF);
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x0E] >> 0x1B) | ((sr[c + 0x0F] & 0x00003FFF) << 0x05));
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x0F] >> 0x0E) | ((sr[c + 0x10] & 0x00000001) << 0x12));
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x10] >> 0x01) & 0x0007FFFF);
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x10] >> 0x14) | ((sr[c + 0x11] & 0x0000007F) << 0x0C));
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x11] >> 0x07) & 0x0007FFFF);
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x11] >> 0x1A) | ((sr[c + 0x12] & 0x00001FFF) << 0x06));
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x12] >> 0x0D));
	}

	static inline void diffUnpack20(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x000FFFFF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x14) | ((sr[c + 0x01] & 0x000000FF) << 0x0C));
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x01] >> 0x08) & 0x000FFFFF);
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x01] >> 0x1C) | ((sr[c + 0x02] & 0x0000FFFF) << 0x04));
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x02] >> 0x10) | ((sr[c + 0x03] & 0x0000000F) << 0x10));
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x03] >> 0x04) & 0x000FFFFF);
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x03] >> 0x18) | ((sr[c + 0x04] & 0x00000FFF) << 0x08));
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x04] >> 0x0C));
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x05] >> 0x00) & 0x000FFFFF);
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x05] >> 0x14) | ((sr[c + 0x06] & 0x000000FF) << 0x0C));
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x06] >> 0x08) & 0x000FFFFF);
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x06] >> 0x1C) | ((sr[c + 0x07] & 0x0000FFFF) << 0x04));
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x07] >> 0x10) | ((sr[c + 0x08] & 0x0000000F) << 0x10));
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x08] >> 0x04) & 0x000FFFFF);
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x08] >> 0x18) | ((sr[c + 0x09] & 0x00000FFF) << 0x08));
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x09] >> 0x0C));
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x0A] >> 0x00) & 0x000FFFFF);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x0A] >> 0x14) | ((sr[c + 0x0B] & 0x000000FF) << 0x0C));
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x0B] >> 0x08) & 0x000FFFFF);
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x0B] >> 0x1C) | ((sr[c + 0x0C] & 0x0000FFFF) << 0x04));
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x0C] >> 0x10) | ((sr[c + 0x0D] & 0x0000000F) << 0x10));
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x0D] >> 0x04) & 0x000FFFFF);
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x0D] >> 0x18) | ((sr[c + 0x0E] & 0x00000FFF) << 0x08));
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x0E] >> 0x0C));
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x0F] >> 0x00) & 0x000FFFFF);
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x0F] >> 0x14) | ((sr[c + 0x10] & 0x000000FF) << 0x0C));
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x10] >> 0x08) & 0x000FFFFF);
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x10] >> 0x1C) | ((sr[c + 0x11] & 0x0000FFFF) << 0x04));
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x11] >> 0x10) | ((sr[c + 0x12] & 0x0000000F) << 0x10));
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x12] >> 0x04) & 0x000FFFFF);
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x12] >> 0x18) | ((sr[c + 0x13] & 0x00000FFF) << 0x08));
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x13] >> 0x0C));
	}

	static inline void diffUnpack21(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x001FFFFF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x15) | ((sr[c + 0x01] & 0x000003FF) << 0x0B));
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x01] >> 0x0A) & 0x001FFFFF);
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x01] >> 0x1F) | ((sr[c + 0x02] & 0x000FFFFF) << 0x01));
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x02] >> 0x14) | ((sr[c + 0x03] & 0x000001FF) << 0x0C));
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x03] >> 0x09) & 0x001FFFFF);
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x03] >> 0x1E) | ((sr[c + 0x04] & 0x0007FFFF) << 0x02));
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x04] >> 0x13) | ((sr[c + 0x05] & 0x000000FF) << 0x0D));
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x05] >> 0x08) & 0x001FFFFF);
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x05] >> 0x1D) | ((sr[c + 0x06] & 0x0003FFFF) << 0x03));
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x06] >> 0x12) | ((sr[c + 0x07] & 0x0000007F) << 0x0E));
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x07] >> 0x07) & 0x001FFFFF);
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x07] >> 0x1C) | ((sr[c + 0x08] & 0x0001FFFF) << 0x04));
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x08] >> 0x11) | ((sr[c + 0x09] & 0x0000003F) << 0x0F));
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x09] >> 0x06) & 0x001FFFFF);
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x09] >> 0x1B) | ((sr[c + 0x0A] & 0x0000FFFF) << 0x05));
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x0A] >> 0x10) | ((sr[c + 0x0B] & 0x0000001F) << 0x10));
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x0B] >> 0x05) & 0x001FFFFF);
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x0B] >> 0x1A) | ((sr[c + 0x0C] & 0x00007FFF) << 0x06));
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x0C] >> 0x0F) | ((sr[c + 0x0D] & 0x0000000F) << 0x11));
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x0D] >> 0x04) & 0x001FFFFF);
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x0D] >> 0x19) | ((sr[c + 0x0E] & 0x00003FFF) << 0x07));
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x0E] >> 0x0E) | ((sr[c + 0x0F] & 0x00000007) << 0x12));
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x0F] >> 0x03) & 0x001FFFFF);
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x0F] >> 0x18) | ((sr[c + 0x10] & 0x00001FFF) << 0x08));
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x10] >> 0x0D) | ((sr[c + 0x11] & 0x00000003) << 0x13));
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x11] >> 0x02) & 0x001FFFFF);
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x11] >> 0x17) | ((sr[c + 0x12] & 0x00000FFF) << 0x09));
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x12] >> 0x0C) | ((sr[c + 0x13] & 0x00000001) << 0x14));
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x13] >> 0x01) & 0x001FFFFF);
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x13] >> 0x16) | ((sr[c + 0x14] & 0x000007FF) << 0x0A));
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x14] >> 0x0B));
	}

	static inline void diffUnpack22(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x003FFFFF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x16) | ((sr[c + 0x01] & 0x00000FFF) << 0x0A));
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x01] >> 0x0C) | ((sr[c + 0x02] & 0x00000003) << 0x14));
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x02] >> 0x02) & 0x003FFFFF);
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x02] >> 0x18) | ((sr[c + 0x03] & 0x00003FFF) << 0x08));
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x03] >> 0x0E) | ((sr[c + 0x04] & 0x0000000F) << 0x12));
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x04] >> 0x04) & 0x003FFFFF);
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x04] >> 0x1A) | ((sr[c + 0x05] & 0x0000FFFF) << 0x06));
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x05] >> 0x10) | ((sr[c + 0x06] & 0x0000003F) << 0x10));
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x06] >> 0x06) & 0x003FFFFF);
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x06] >> 0x1C) | ((sr[c + 0x07] & 0x0003FFFF) << 0x04));
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x07] >> 0x12) | ((sr[c + 0x08] & 0x000000FF) << 0x0E));
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x08] >> 0x08) & 0x003FFFFF);
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x08] >> 0x1E) | ((sr[c + 0x09] & 0x000FFFFF) << 0x02));
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x09] >> 0x14) | ((sr[c + 0x0A] & 0x000003FF) << 0x0C));
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x0A] >> 0x0A));
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x0B] >> 0x00) & 0x003FFFFF);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x0B] >> 0x16) | ((sr[c + 0x0C] & 0x00000FFF) << 0x0A));
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x0C] >> 0x0C) | ((sr[c + 0x0D] & 0x00000003) << 0x14));
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x0D] >> 0x02) & 0x003FFFFF);
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x0D] >> 0x18) | ((sr[c + 0x0E] & 0x00003FFF) << 0x08));
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x0E] >> 0x0E) | ((sr[c + 0x0F] & 0x0000000F) << 0x12));
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x0F] >> 0x04) & 0x003FFFFF);
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x0F] >> 0x1A) | ((sr[c + 0x10] & 0x0000FFFF) << 0x06));
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x10] >> 0x10) | ((sr[c + 0x11] & 0x0000003F) << 0x10));
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x11] >> 0x06) & 0x003FFFFF);
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x11] >> 0x1C) | ((sr[c + 0x12] & 0x0003FFFF) << 0x04));
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x12] >> 0x12) | ((sr[c + 0x13] & 0x000000FF) << 0x0E));
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x13] >> 0x08) & 0x003FFFFF);
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x13] >> 0x1E) | ((sr[c + 0x14] & 0x000FFFFF) << 0x02));
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x14] >> 0x14) | ((sr[c + 0x15] & 0x000003FF) << 0x0C));
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x15] >> 0x0A));
	}

	static inline void diffUnpack23(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x007FFFFF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x17) | ((sr[c + 0x01] & 0x00003FFF) << 0x09));
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x01] >> 0x0E) | ((sr[c + 0x02] & 0x0000001F) << 0x12));
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x02] >> 0x05) & 0x007FFFFF);
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x02] >> 0x1C) | ((sr[c + 0x03] & 0x0007FFFF) << 0x04));
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x03] >> 0x13) | ((sr[c + 0x04] & 0x000003FF) << 0x0D));
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x04] >> 0x0A) | ((sr[c + 0x05] & 0x00000001) << 0x16));
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x05] >> 0x01) & 0x007FFFFF);
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x05] >> 0x18) | ((sr[c + 0x06] & 0x00007FFF) << 0x08));
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x06] >> 0x0F) | ((sr[c + 0x07] & 0x0000003F) << 0x11));
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x07] >> 0x06) & 0x007FFFFF);
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x07] >> 0x1D) | ((sr[c + 0x08] & 0x000FFFFF) << 0x03));
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x08] >> 0x14) | ((sr[c + 0x09] & 0x000007FF) << 0x0C));
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x09] >> 0x0B) | ((sr[c + 0x0A] & 0x00000003) << 0x15));
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x0A] >> 0x02) & 0x007FFFFF);
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x0A] >> 0x19) | ((sr[c + 0x0B] & 0x0000FFFF) << 0x07));
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x0B] >> 0x10) | ((sr[c + 0x0C] & 0x0000007F) << 0x10));
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x0C] >> 0x07) & 0x007FFFFF);
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x0C] >> 0x1E) | ((sr[c + 0x0D] & 0x001FFFFF) << 0x02));
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x0D] >> 0x15) | ((sr[c + 0x0E] & 0x00000FFF) << 0x0B));
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x0E] >> 0x0C) | ((sr[c + 0x0F] & 0x00000007) << 0x14));
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x0F] >> 0x03) & 0x007FFFFF);
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x0F] >> 0x1A) | ((sr[c + 0x10] & 0x0001FFFF) << 0x06));
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x10] >> 0x11) | ((sr[c + 0x11] & 0x000000FF) << 0x0F));
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x11] >> 0x08) & 0x007FFFFF);
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x11] >> 0x1F) | ((sr[c + 0x12] & 0x003FFFFF) << 0x01));
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x12] >> 0x16) | ((sr[c + 0x13] & 0x00001FFF) << 0x0A));
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x13] >> 0x0D) | ((sr[c + 0x14] & 0x0000000F) << 0x13));
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x14] >> 0x04) & 0x007FFFFF);
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x14] >> 0x1B) | ((sr[c + 0x15] & 0x0003FFFF) << 0x05));
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x15] >> 0x12) | ((sr[c + 0x16] & 0x000001FF) << 0x0E));
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x16] >> 0x09));
	}

	static inline void diffUnpack24(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x00FFFFFF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x18) | ((sr[c + 0x01] & 0x0000FFFF) << 0x08));
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x01] >> 0x10) | ((sr[c + 0x02] & 0x000000FF) << 0x10));
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x02] >> 0x08));
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x03] >> 0x00) & 0x00FFFFFF);
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x03] >> 0x18) | ((sr[c + 0x04] & 0x0000FFFF) << 0x08));
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x04] >> 0x10) | ((sr[c + 0x05] & 0x000000FF) << 0x10));
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x05] >> 0x08));
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x06] >> 0x00) & 0x00FFFFFF);
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x06] >> 0x18) | ((sr[c + 0x07] & 0x0000FFFF) << 0x08));
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x07] >> 0x10) | ((sr[c + 0x08] & 0x000000FF) << 0x10));
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x08] >> 0x08));
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x09] >> 0x00) & 0x00FFFFFF);
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x09] >> 0x18) | ((sr[c + 0x0A] & 0x0000FFFF) << 0x08));
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x0A] >> 0x10) | ((sr[c + 0x0B] & 0x000000FF) << 0x10));
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x0B] >> 0x08));
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x0C] >> 0x00) & 0x00FFFFFF);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x0C] >> 0x18) | ((sr[c + 0x0D] & 0x0000FFFF) << 0x08));
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x0D] >> 0x10) | ((sr[c + 0x0E] & 0x000000FF) << 0x10));
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x0E] >> 0x08));
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x0F] >> 0x00) & 0x00FFFFFF);
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x0F] >> 0x18) | ((sr[c + 0x10] & 0x0000FFFF) << 0x08));
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x10] >> 0x10) | ((sr[c + 0x11] & 0x000000FF) << 0x10));
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x11] >> 0x08));
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x12] >> 0x00) & 0x00FFFFFF);
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x12] >> 0x18) | ((sr[c + 0x13] & 0x0000FFFF) << 0x08));
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x13] >> 0x10) | ((sr[c + 0x14] & 0x000000FF) << 0x10));
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x14] >> 0x08));
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x15] >> 0x00) & 0x00FFFFFF);
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x15] >> 0x18) | ((sr[c + 0x16] & 0x0000FFFF) << 0x08));
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x16] >> 0x10) | ((sr[c + 0x17] & 0x000000FF) << 0x10));
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x17] >> 0x08));
	}

	static inline void diffUnpack25(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x01FFFFFF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x19) | ((sr[c + 0x01] & 0x0003FFFF) << 0x07));
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x01] >> 0x12) | ((sr[c + 0x02] & 0x000007FF) << 0x0E));
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x02] >> 0x0B) | ((sr[c + 0x03] & 0x0000000F) << 0x15));
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x03] >> 0x04) & 0x01FFFFFF);
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x03] >> 0x1D) | ((sr[c + 0x04] & 0x003FFFFF) << 0x03));
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x04] >> 0x16) | ((sr[c + 0x05] & 0x00007FFF) << 0x0A));
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x05] >> 0x0F) | ((sr[c + 0x06] & 0x000000FF) << 0x11));
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x06] >> 0x08) | ((sr[c + 0x07] & 0x00000001) << 0x18));
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x07] >> 0x01) & 0x01FFFFFF);
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x07] >> 0x1A) | ((sr[c + 0x08] & 0x0007FFFF) << 0x06));
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x08] >> 0x13) | ((sr[c + 0x09] & 0x00000FFF) << 0x0D));
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x09] >> 0x0C) | ((sr[c + 0x0A] & 0x0000001F) << 0x14));
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x0A] >> 0x05) & 0x01FFFFFF);
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x0A] >> 0x1E) | ((sr[c + 0x0B] & 0x007FFFFF) << 0x02));
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x0B] >> 0x17) | ((sr[c + 0x0C] & 0x0000FFFF) << 0x09));
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x0C] >> 0x10) | ((sr[c + 0x0D] & 0x000001FF) << 0x10));
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x0D] >> 0x09) | ((sr[c + 0x0E] & 0x00000003) << 0x17));
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x0E] >> 0x02) & 0x01FFFFFF);
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x0E] >> 0x1B) | ((sr[c + 0x0F] & 0x000FFFFF) << 0x05));
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x0F] >> 0x14) | ((sr[c + 0x10] & 0x00001FFF) << 0x0C));
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x10] >> 0x0D) | ((sr[c + 0x11] & 0x0000003F) << 0x13));
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x11] >> 0x06) & 0x01FFFFFF);
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x11] >> 0x1F) | ((sr[c + 0x12] & 0x00FFFFFF) << 0x01));
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x12] >> 0x18) | ((sr[c + 0x13] & 0x0001FFFF) << 0x08));
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x13] >> 0x11) | ((sr[c + 0x14] & 0x000003FF) << 0x0F));
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x14] >> 0x0A) | ((sr[c + 0x15] & 0x00000007) << 0x16));
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x15] >> 0x03) & 0x01FFFFFF);
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x15] >> 0x1C) | ((sr[c + 0x16] & 0x001FFFFF) << 0x04));
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x16] >> 0x15) | ((sr[c + 0x17] & 0x00003FFF) << 0x0B));
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x17] >> 0x0E) | ((sr[c + 0x18] & 0x0000007F) << 0x12));
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x18] >> 0x07));
	}

	static inline void diffUnpack26(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x03FFFFFF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x1A) | ((sr[c + 0x01] & 0x000FFFFF) << 0x06));
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x01] >> 0x14) | ((sr[c + 0x02] & 0x00003FFF) << 0x0C));
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x02] >> 0x0E) | ((sr[c + 0x03] & 0x000000FF) << 0x12));
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x03] >> 0x08) | ((sr[c + 0x04] & 0x00000003) << 0x18));
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x04] >> 0x02) & 0x03FFFFFF);
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x04] >> 0x1C) | ((sr[c + 0x05] & 0x003FFFFF) << 0x04));
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x05] >> 0x16) | ((sr[c + 0x06] & 0x0000FFFF) << 0x0A));
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x06] >> 0x10) | ((sr[c + 0x07] & 0x000003FF) << 0x10));
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x07] >> 0x0A) | ((sr[c + 0x08] & 0x0000000F) << 0x16));
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x08] >> 0x04) & 0x03FFFFFF);
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x08] >> 0x1E) | ((sr[c + 0x09] & 0x00FFFFFF) << 0x02));
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x09] >> 0x18) | ((sr[c + 0x0A] & 0x0003FFFF) << 0x08));
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x0A] >> 0x12) | ((sr[c + 0x0B] & 0x00000FFF) << 0x0E));
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x0B] >> 0x0C) | ((sr[c + 0x0C] & 0x0000003F) << 0x14));
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x0C] >> 0x06));
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x0D] >> 0x00) & 0x03FFFFFF);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x0D] >> 0x1A) | ((sr[c + 0x0E] & 0x000FFFFF) << 0x06));
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x0E] >> 0x14) | ((sr[c + 0x0F] & 0x00003FFF) << 0x0C));
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x0F] >> 0x0E) | ((sr[c + 0x10] & 0x000000FF) << 0x12));
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x10] >> 0x08) | ((sr[c + 0x11] & 0x00000003) << 0x18));
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x11] >> 0x02) & 0x03FFFFFF);
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x11] >> 0x1C) | ((sr[c + 0x12] & 0x003FFFFF) << 0x04));
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x12] >> 0x16) | ((sr[c + 0x13] & 0x0000FFFF) << 0x0A));
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x13] >> 0x10) | ((sr[c + 0x14] & 0x000003FF) << 0x10));
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x14] >> 0x0A) | ((sr[c + 0x15] & 0x0000000F) << 0x16));
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x15] >> 0x04) & 0x03FFFFFF);
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x15] >> 0x1E) | ((sr[c + 0x16] & 0x00FFFFFF) << 0x02));
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x16] >> 0x18) | ((sr[c + 0x17] & 0x0003FFFF) << 0x08));
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x17] >> 0x12) | ((sr[c + 0x18] & 0x00000FFF) << 0x0E));
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x18] >> 0x0C) | ((sr[c + 0x19] & 0x0000003F) << 0x14));
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x19] >> 0x06));
	}

	static inline void diffUnpack27(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x07FFFFFF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x1B) | ((sr[c + 0x01] & 0x003FFFFF) << 0x05));
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x01] >> 0x16) | ((sr[c + 0x02] & 0x0001FFFF) << 0x0A));
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x02] >> 0x11) | ((sr[c + 0x03] & 0x00000FFF) << 0x0F));
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x03] >> 0x0C) | ((sr[c + 0x04] & 0x0000007F) << 0x14));
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x04] >> 0x07) | ((sr[c + 0x05] & 0x00000003) << 0x19));
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x05] >> 0x02) & 0x07FFFFFF);
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x05] >> 0x1D) | ((sr[c + 0x06] & 0x00FFFFFF) << 0x03));
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x06] >> 0x18) | ((sr[c + 0x07] & 0x0007FFFF) << 0x08));
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x07] >> 0x13) | ((sr[c + 0x08] & 0x00003FFF) << 0x0D));
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x08] >> 0x0E) | ((sr[c + 0x09] & 0x000001FF) << 0x12));
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x09] >> 0x09) | ((sr[c + 0x0A] & 0x0000000F) << 0x17));
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x0A] >> 0x04) & 0x07FFFFFF);
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x0A] >> 0x1F) | ((sr[c + 0x0B] & 0x03FFFFFF) << 0x01));
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x0B] >> 0x1A) | ((sr[c + 0x0C] & 0x001FFFFF) << 0x06));
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x0C] >> 0x15) | ((sr[c + 0x0D] & 0x0000FFFF) << 0x0B));
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x0D] >> 0x10) | ((sr[c + 0x0E] & 0x000007FF) << 0x10));
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x0E] >> 0x0B) | ((sr[c + 0x0F] & 0x0000003F) << 0x15));
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x0F] >> 0x06) | ((sr[c + 0x10] & 0x00000001) << 0x1A));
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x10] >> 0x01) & 0x07FFFFFF);
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x10] >> 0x1C) | ((sr[c + 0x11] & 0x007FFFFF) << 0x04));
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x11] >> 0x17) | ((sr[c + 0x12] & 0x0003FFFF) << 0x09));
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x12] >> 0x12) | ((sr[c + 0x13] & 0x00001FFF) << 0x0E));
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x13] >> 0x0D) | ((sr[c + 0x14] & 0x000000FF) << 0x13));
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x14] >> 0x08) | ((sr[c + 0x15] & 0x00000007) << 0x18));
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x15] >> 0x03) & 0x07FFFFFF);
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x15] >> 0x1E) | ((sr[c + 0x16] & 0x01FFFFFF) << 0x02));
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x16] >> 0x19) | ((sr[c + 0x17] & 0x000FFFFF) << 0x07));
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x17] >> 0x14) | ((sr[c + 0x18] & 0x00007FFF) << 0x0C));
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x18] >> 0x0F) | ((sr[c + 0x19] & 0x000003FF) << 0x11));
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x19] >> 0x0A) | ((sr[c + 0x1A] & 0x0000001F) << 0x16));
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x1A] >> 0x05));
	}

	static inline void diffUnpack28(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x0FFFFFFF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x1C) | ((sr[c + 0x01] & 0x00FFFFFF) << 0x04));
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x01] >> 0x18) | ((sr[c + 0x02] & 0x000FFFFF) << 0x08));
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x02] >> 0x14) | ((sr[c + 0x03] & 0x0000FFFF) << 0x0C));
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x03] >> 0x10) | ((sr[c + 0x04] & 0x00000FFF) << 0x10));
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x04] >> 0x0C) | ((sr[c + 0x05] & 0x000000FF) << 0x14));
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x05] >> 0x08) | ((sr[c + 0x06] & 0x0000000F) << 0x18));
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x06] >> 0x04));
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x07] >> 0x00) & 0x0FFFFFFF);
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x07] >> 0x1C) | ((sr[c + 0x08] & 0x00FFFFFF) << 0x04));
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x08] >> 0x18) | ((sr[c + 0x09] & 0x000FFFFF) << 0x08));
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x09] >> 0x14) | ((sr[c + 0x0A] & 0x0000FFFF) << 0x0C));
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x0A] >> 0x10) | ((sr[c + 0x0B] & 0x00000FFF) << 0x10));
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x0B] >> 0x0C) | ((sr[c + 0x0C] & 0x000000FF) << 0x14));
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x0C] >> 0x08) | ((sr[c + 0x0D] & 0x0000000F) << 0x18));
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x0D] >> 0x04));
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x0E] >> 0x00) & 0x0FFFFFFF);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x0E] >> 0x1C) | ((sr[c + 0x0F] & 0x00FFFFFF) << 0x04));
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x0F] >> 0x18) | ((sr[c + 0x10] & 0x000FFFFF) << 0x08));
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x10] >> 0x14) | ((sr[c + 0x11] & 0x0000FFFF) << 0x0C));
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x11] >> 0x10) | ((sr[c + 0x12] & 0x00000FFF) << 0x10));
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x12] >> 0x0C) | ((sr[c + 0x13] & 0x000000FF) << 0x14));
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x13] >> 0x08) | ((sr[c + 0x14] & 0x0000000F) << 0x18));
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x14] >> 0x04));
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x15] >> 0x00) & 0x0FFFFFFF);
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x15] >> 0x1C) | ((sr[c + 0x16] & 0x00FFFFFF) << 0x04));
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x16] >> 0x18) | ((sr[c + 0x17] & 0x000FFFFF) << 0x08));
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x17] >> 0x14) | ((sr[c + 0x18] & 0x0000FFFF) << 0x0C));
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x18] >> 0x10) | ((sr[c + 0x19] & 0x00000FFF) << 0x10));
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x19] >> 0x0C) | ((sr[c + 0x1A] & 0x000000FF) << 0x14));
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x1A] >> 0x08) | ((sr[c + 0x1B] & 0x0000000F) << 0x18));
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x1B] >> 0x04));
	}

	static inline void diffUnpack29(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x1FFFFFFF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x1D) | ((sr[c + 0x01] & 0x03FFFFFF) << 0x03));
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x01] >> 0x1A) | ((sr[c + 0x02] & 0x007FFFFF) << 0x06));
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x02] >> 0x17) | ((sr[c + 0x03] & 0x000FFFFF) << 0x09));
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x03] >> 0x14) | ((sr[c + 0x04] & 0x0001FFFF) << 0x0C));
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x04] >> 0x11) | ((sr[c + 0x05] & 0x00003FFF) << 0x0F));
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x05] >> 0x0E) | ((sr[c + 0x06] & 0x000007FF) << 0x12));
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x06] >> 0x0B) | ((sr[c + 0x07] & 0x000000FF) << 0x15));
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x07] >> 0x08) | ((sr[c + 0x08] & 0x0000001F) << 0x18));
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x08] >> 0x05) | ((sr[c + 0x09] & 0x00000003) << 0x1B));
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x09] >> 0x02) & 0x1FFFFFFF);
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x09] >> 0x1F) | ((sr[c + 0x0A] & 0x0FFFFFFF) << 0x01));
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x0A] >> 0x1C) | ((sr[c + 0x0B] & 0x01FFFFFF) << 0x04));
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x0B] >> 0x19) | ((sr[c + 0x0C] & 0x003FFFFF) << 0x07));
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x0C] >> 0x16) | ((sr[c + 0x0D] & 0x0007FFFF) << 0x0A));
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x0D] >> 0x13) | ((sr[c + 0x0E] & 0x0000FFFF) << 0x0D));
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x0E] >> 0x10) | ((sr[c + 0x0F] & 0x00001FFF) << 0x10));
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x0F] >> 0x0D) | ((sr[c + 0x10] & 0x000003FF) << 0x13));
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x10] >> 0x0A) | ((sr[c + 0x11] & 0x0000007F) << 0x16));
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x11] >> 0x07) | ((sr[c + 0x12] & 0x0000000F) << 0x19));
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x12] >> 0x04) | ((sr[c + 0x13] & 0x00000001) << 0x1C));
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x13] >> 0x01) & 0x1FFFFFFF);
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x13] >> 0x1E) | ((sr[c + 0x14] & 0x07FFFFFF) << 0x02));
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x14] >> 0x1B) | ((sr[c + 0x15] & 0x00FFFFFF) << 0x05));
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x15] >> 0x18) | ((sr[c + 0x16] & 0x001FFFFF) << 0x08));
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x16] >> 0x15) | ((sr[c + 0x17] & 0x0003FFFF) << 0x0B));
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x17] >> 0x12) | ((sr[c + 0x18] & 0x00007FFF) << 0x0E));
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x18] >> 0x0F) | ((sr[c + 0x19] & 0x00000FFF) << 0x11));
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x19] >> 0x0C) | ((sr[c + 0x1A] & 0x000001FF) << 0x14));
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x1A] >> 0x09) | ((sr[c + 0x1B] & 0x0000003F) << 0x17));
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x1B] >> 0x06) | ((sr[c + 0x1C] & 0x00000007) << 0x1A));
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x1C] >> 0x03));
	}

	static inline void diffUnpack30(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x3FFFFFFF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x1E) | ((sr[c + 0x01] & 0x0FFFFFFF) << 0x02));
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x01] >> 0x1C) | ((sr[c + 0x02] & 0x03FFFFFF) << 0x04));
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x02] >> 0x1A) | ((sr[c + 0x03] & 0x00FFFFFF) << 0x06));
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x03] >> 0x18) | ((sr[c + 0x04] & 0x003FFFFF) << 0x08));
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x04] >> 0x16) | ((sr[c + 0x05] & 0x000FFFFF) << 0x0A));
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x05] >> 0x14) | ((sr[c + 0x06] & 0x0003FFFF) << 0x0C));
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x06] >> 0x12) | ((sr[c + 0x07] & 0x0000FFFF) << 0x0E));
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x07] >> 0x10) | ((sr[c + 0x08] & 0x00003FFF) << 0x10));
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x08] >> 0x0E) | ((sr[c + 0x09] & 0x00000FFF) << 0x12));
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x09] >> 0x0C) | ((sr[c + 0x0A] & 0x000003FF) << 0x14));
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x0A] >> 0x0A) | ((sr[c + 0x0B] & 0x000000FF) << 0x16));
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x0B] >> 0x08) | ((sr[c + 0x0C] & 0x0000003F) << 0x18));
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x0C] >> 0x06) | ((sr[c + 0x0D] & 0x0000000F) << 0x1A));
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x0D] >> 0x04) | ((sr[c + 0x0E] & 0x00000003) << 0x1C));
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x0E] >> 0x02));
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x0F] >> 0x00) & 0x3FFFFFFF);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x0F] >> 0x1E) | ((sr[c + 0x10] & 0x0FFFFFFF) << 0x02));
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x10] >> 0x1C) | ((sr[c + 0x11] & 0x03FFFFFF) << 0x04));
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x11] >> 0x1A) | ((sr[c + 0x12] & 0x00FFFFFF) << 0x06));
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x12] >> 0x18) | ((sr[c + 0x13] & 0x003FFFFF) << 0x08));
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x13] >> 0x16) | ((sr[c + 0x14] & 0x000FFFFF) << 0x0A));
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x14] >> 0x14) | ((sr[c + 0x15] & 0x0003FFFF) << 0x0C));
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x15] >> 0x12) | ((sr[c + 0x16] & 0x0000FFFF) << 0x0E));
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x16] >> 0x10) | ((sr[c + 0x17] & 0x00003FFF) << 0x10));
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x17] >> 0x0E) | ((sr[c + 0x18] & 0x00000FFF) << 0x12));
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x18] >> 0x0C) | ((sr[c + 0x19] & 0x000003FF) << 0x14));
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x19] >> 0x0A) | ((sr[c + 0x1A] & 0x000000FF) << 0x16));
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x1A] >> 0x08) | ((sr[c + 0x1B] & 0x0000003F) << 0x18));
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x1B] >> 0x06) | ((sr[c + 0x1C] & 0x0000000F) << 0x1A));
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x1C] >> 0x04) | ((sr[c + 0x1D] & 0x00000003) << 0x1C));
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x1D] >> 0x02));
	}

	static inline void diffUnpack31(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag((sr[c + 0x00] >> 0x00) & 0x7FFFFFFF);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag((sr[c + 0x00] >> 0x1F) | ((sr[c + 0x01] & 0x3FFFFFFF) << 0x01));
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag((sr[c + 0x01] >> 0x1E) | ((sr[c + 0x02] & 0x1FFFFFFF) << 0x02));
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag((sr[c + 0x02] >> 0x1D) | ((sr[c + 0x03] & 0x0FFFFFFF) << 0x03));
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag((sr[c + 0x03] >> 0x1C) | ((sr[c + 0x04] & 0x07FFFFFF) << 0x04));
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag((sr[c + 0x04] >> 0x1B) | ((sr[c + 0x05] & 0x03FFFFFF) << 0x05));
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag((sr[c + 0x05] >> 0x1A) | ((sr[c + 0x06] & 0x01FFFFFF) << 0x06));
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag((sr[c + 0x06] >> 0x19) | ((sr[c + 0x07] & 0x00FFFFFF) << 0x07));
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag((sr[c + 0x07] >> 0x18) | ((sr[c + 0x08] & 0x007FFFFF) << 0x08));
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag((sr[c + 0x08] >> 0x17) | ((sr[c + 0x09] & 0x003FFFFF) << 0x09));
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag((sr[c + 0x09] >> 0x16) | ((sr[c + 0x0A] & 0x001FFFFF) << 0x0A));
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag((sr[c + 0x0A] >> 0x15) | ((sr[c + 0x0B] & 0x000FFFFF) << 0x0B));
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag((sr[c + 0x0B] >> 0x14) | ((sr[c + 0x0C] & 0x0007FFFF) << 0x0C));
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag((sr[c + 0x0C] >> 0x13) | ((sr[c + 0x0D] & 0x0003FFFF) << 0x0D));
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag((sr[c + 0x0D] >> 0x12) | ((sr[c + 0x0E] & 0x0001FFFF) << 0x0E));
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag((sr[c + 0x0E] >> 0x11) | ((sr[c + 0x0F] & 0x0000FFFF) << 0x0F));
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag((sr[c + 0x0F] >> 0x10) | ((sr[c + 0x10] & 0x00007FFF) << 0x10));
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag((sr[c + 0x10] >> 0x0F) | ((sr[c + 0x11] & 0x00003FFF) << 0x11));
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag((sr[c + 0x11] >> 0x0E) | ((sr[c + 0x12] & 0x00001FFF) << 0x12));
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag((sr[c + 0x12] >> 0x0D) | ((sr[c + 0x13] & 0x00000FFF) << 0x13));
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag((sr[c + 0x13] >> 0x0C) | ((sr[c + 0x14] & 0x000007FF) << 0x14));
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag((sr[c + 0x14] >> 0x0B) | ((sr[c + 0x15] & 0x000003FF) << 0x15));
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag((sr[c + 0x15] >> 0x0A) | ((sr[c + 0x16] & 0x000001FF) << 0x16));
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag((sr[c + 0x16] >> 0x09) | ((sr[c + 0x17] & 0x000000FF) << 0x17));
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag((sr[c + 0x17] >> 0x08) | ((sr[c + 0x18] & 0x0000007F) << 0x18));
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag((sr[c + 0x18] >> 0x07) | ((sr[c + 0x19] & 0x0000003F) << 0x19));
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag((sr[c + 0x19] >> 0x06) | ((sr[c + 0x1A] & 0x0000001F) << 0x1A));
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag((sr[c + 0x1A] >> 0x05) | ((sr[c + 0x1B] & 0x0000000F) << 0x1B));
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag((sr[c + 0x1B] >> 0x04) | ((sr[c + 0x1C] & 0x00000007) << 0x1C));
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag((sr[c + 0x1C] >> 0x03) | ((sr[c + 0x1D] & 0x00000003) << 0x1D));
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag((sr[c + 0x1D] >> 0x02) | ((sr[c + 0x1E] & 0x00000001) << 0x1E));
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag((sr[c + 0x1E] >> 0x01));
	}

	static inline void diffUnpack32(const u32* const sr, const u32 c, u32* const ds, const u32 t) {
		ds[t + 0x00] = ds[t + 0x00 - DIFF] + zag(sr[c + 0x00]);
		ds[t + 0x01] = ds[t + 0x01 - DIFF] + zag(sr[c + 0x01]);
		ds[t + 0x02] = ds[t + 0x02 - DIFF] + zag(sr[c + 0x02]);
		ds[t + 0x03] = ds[t + 0x03 - DIFF] + zag(sr[c + 0x03]);
		ds[t + 0x04] = ds[t + 0x04 - DIFF] + zag(sr[c + 0x04]);
		ds[t + 0x05] = ds[t + 0x05 - DIFF] + zag(sr[c + 0x05]);
		ds[t + 0x06] = ds[t + 0x06 - DIFF] + zag(sr[c + 0x06]);
		ds[t + 0x07] = ds[t + 0x07 - DIFF] + zag(sr[c + 0x07]);
		ds[t + 0x08] = ds[t + 0x08 - DIFF] + zag(sr[c + 0x08]);
		ds[t + 0x09] = ds[t + 0x09 - DIFF] + zag(sr[c + 0x09]);
		ds[t + 0x0A] = ds[t + 0x0A - DIFF] + zag(sr[c + 0x0A]);
		ds[t + 0x0B] = ds[t + 0x0B - DIFF] + zag(sr[c + 0x0B]);
		ds[t + 0x0C] = ds[t + 0x0C - DIFF] + zag(sr[c + 0x0C]);
		ds[t + 0x0D] = ds[t + 0x0D - DIFF] + zag(sr[c + 0x0D]);
		ds[t + 0x0E] = ds[t + 0x0E - DIFF] + zag(sr[c + 0x0E]);
		ds[t + 0x0F] = ds[t + 0x0F - DIFF] + zag(sr[c + 0x0F]);
		ds[t + 0x10] = ds[t + 0x10 - DIFF] + zag(sr[c + 0x10]);
		ds[t + 0x11] = ds[t + 0x11 - DIFF] + zag(sr[c + 0x11]);
		ds[t + 0x12] = ds[t + 0x12 - DIFF] + zag(sr[c + 0x12]);
		ds[t + 0x13] = ds[t + 0x13 - DIFF] + zag(sr[c + 0x13]);
		ds[t + 0x14] = ds[t + 0x14 - DIFF] + zag(sr[c + 0x14]);
		ds[t + 0x15] = ds[t + 0x15 - DIFF] + zag(sr[c + 0x15]);
		ds[t + 0x16] = ds[t + 0x16 - DIFF] + zag(sr[c + 0x16]);
		ds[t + 0x17] = ds[t + 0x17 - DIFF] + zag(sr[c + 0x17]);
		ds[t + 0x18] = ds[t + 0x18 - DIFF] + zag(sr[c + 0x18]);
		ds[t + 0x19] = ds[t + 0x19 - DIFF] + zag(sr[c + 0x19]);
		ds[t + 0x1A] = ds[t + 0x1A - DIFF] + zag(sr[c + 0x1A]);
		ds[t + 0x1B] = ds[t + 0x1B - DIFF] + zag(sr[c + 0x1B]);
		ds[t + 0x1C] = ds[t + 0x1C - DIFF] + zag(sr[c + 0x1C]);
		ds[t + 0x1D] = ds[t + 0x1D - DIFF] + zag(sr[c + 0x1D]);
		ds[t + 0x1E] = ds[t + 0x1E - DIFF] + zag(sr[c + 0x1E]);
		ds[t + 0x1F] = ds[t + 0x1F - DIFF] + zag(sr[c + 0x1F]);
	}
};
